From 14c01fe1c15d376012568ebb4595fb0dcfed3c3a Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 10 Feb 2026 15:55:10 +1100
Subject: [PATCH] Updated vkd3d to 116d4405e05a653aecbfd72a85be7099eec9170a.

---
 libs/vkd3d/libs/vkd3d-shader/dxil.c           | 14 +++---
 libs/vkd3d/libs/vkd3d-shader/hlsl.c           |  2 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.h           |  5 +++
 libs/vkd3d/libs/vkd3d-shader/hlsl.y           | 43 +++++++++++--------
 libs/vkd3d/libs/vkd3d-shader/ir.c             | 16 +++----
 libs/vkd3d/libs/vkd3d-shader/tpf.c            |  3 ++
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |  2 +
 7 files changed, 52 insertions(+), 33 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index ea532001dc9..243188d16c4 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -9551,23 +9551,23 @@ static enum vkd3d_result sm6_parser_module_init(struct sm6_parser *sm6, const st
     return sm6->p.status;
 }
 
-static enum vkd3d_result sm6_function_emit_instructions(const struct sm6_function *function, struct sm6_parser *dxil)
+static enum vkd3d_result sm6_function_emit_instructions(struct sm6_function *function, struct sm6_parser *dxil)
 {
+    struct vsir_program_iterator it = vsir_program_iterator(&function->instructions);
     struct vsir_program *program = dxil->program;
-    struct vkd3d_shader_instruction *ins;
-    unsigned int i;
+    struct vkd3d_shader_instruction *dst, *src;
 
     program->block_count = max(program->block_count, function->block_count);
 
-    for (i = 0; i < function->instructions.count; ++i)
+    for (src = vsir_program_iterator_head(&it); src; src = vsir_program_iterator_next(&it))
     {
-        if (!(ins = vsir_program_append(program)))
+        if (!(dst = vsir_program_append(program)))
         {
             vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                     "Out of memory while emitting instructions.");
             return dxil->p.status;
         }
-        *ins = function->instructions.elements[i];
+        *dst = *src;
     }
 
     return dxil->p.status;
@@ -11528,7 +11528,7 @@ static void sm6_functions_cleanup(struct sm6_function *functions, size_t count)
 
     for (i = 0; i < count; ++i)
     {
-        vkd3d_free(functions[i].instructions.elements);
+        shader_instruction_array_cleanup(&functions[i].instructions);
     }
     vkd3d_free(functions);
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 1d0bafa4cd8..01c73ee46b4 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -4627,7 +4627,7 @@ static void free_function_decl(struct hlsl_ir_function_decl *decl)
         hlsl_free_attribute((void *)decl->attrs[i]);
     vkd3d_free((void *)decl->attrs);
 
-    vkd3d_free(decl->parameters.vars);
+    hlsl_func_parameters_cleanup(&decl->parameters);
     hlsl_block_cleanup(&decl->body);
     vkd3d_free(decl);
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index f37b86ecdf0..0ac5adca554 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -616,6 +616,11 @@ struct hlsl_func_parameters
     size_t count, capacity;
 };
 
+static inline void hlsl_func_parameters_cleanup(struct hlsl_func_parameters *p)
+{
+    vkd3d_free(p->vars);
+}
+
 struct hlsl_ir_function
 {
     /* Item entry in hlsl_ctx.functions */
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index e382255938d..fcef2bd8e94 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -760,7 +760,13 @@ static void cleanup_parse_attribute_list(struct parse_attribute_list *attr_list)
     vkd3d_free(attr_list->attrs);
 }
 
-static void free_parse_initializer(struct parse_initializer *initializer)
+static void parse_function_cleanup(struct parse_function *f)
+{
+    hlsl_func_parameters_cleanup(&f->parameters);
+    hlsl_cleanup_semantic(&f->return_semantic);
+}
+
+static void cleanup_parse_initializer(struct parse_initializer *initializer)
 {
     destroy_block(initializer->instrs);
     vkd3d_free(initializer->args);
@@ -1016,7 +1022,7 @@ static struct hlsl_type *apply_type_modifiers(struct hlsl_ctx *ctx, struct hlsl_
 
 static void free_parse_variable_def(struct parse_variable_def *v)
 {
-    free_parse_initializer(&v->initializer);
+    cleanup_parse_initializer(&v->initializer);
     vkd3d_free(v->arrays.sizes);
     vkd3d_free(v->name);
     hlsl_cleanup_semantic(&v->semantic);
@@ -1108,7 +1114,7 @@ static bool gen_struct_fields(struct hlsl_ctx *ctx, struct parse_fields *fields,
         if (v->initializer.args_count)
         {
             hlsl_error(ctx, &v->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX, "Illegal initializer on a struct field.");
-            free_parse_initializer(&v->initializer);
+            cleanup_parse_initializer(&v->initializer);
         }
         if (v->reg_reservation.offset_type)
             hlsl_error(ctx, &v->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_RESERVATION,
@@ -1211,7 +1217,7 @@ static bool add_typedef(struct hlsl_ctx *ctx, struct hlsl_type *const orig_type,
         if (!ret)
             hlsl_error(ctx, &v->loc, VKD3D_SHADER_ERROR_HLSL_REDEFINED,
                     "Type '%s' is already defined.", v->name);
-        free_parse_initializer(&v->initializer);
+        cleanup_parse_initializer(&v->initializer);
         vkd3d_free(v);
     }
     vkd3d_free(list);
@@ -1297,7 +1303,7 @@ static bool add_func_parameter(struct hlsl_ctx *ctx, struct hlsl_func_parameters
                     &store_index, param->initializer.args[i], true);
         }
 
-        free_parse_initializer(&param->initializer);
+        cleanup_parse_initializer(&param->initializer);
     }
 
     hlsl_add_var(ctx, var);
@@ -5907,7 +5913,7 @@ static struct hlsl_block *add_shader_compilation(struct hlsl_ctx *ctx, const cha
     block = make_block(ctx, compile);
 
 out:
-    free_parse_initializer(args);
+    cleanup_parse_initializer(args);
     return block;
 }
 
@@ -7342,6 +7348,7 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
 
 %type <attr_list> attribute_list
 %type <attr_list> attribute_list_optional
+%destructor { cleanup_parse_attribute_list(&$$); } <attr_list>
 
 %type <block> add_expr
 %type <block> assignment_expr
@@ -7389,6 +7396,7 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
 %type <initializer> complex_initializer_list
 %type <initializer> func_arguments
 %type <initializer> initializer_expr_list
+%destructor { cleanup_parse_initializer(&$$); } <initializer>
 
 %type <if_body> if_body
 
@@ -7407,6 +7415,7 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
 
 %type <parameters> param_list
 %type <parameters> parameters
+%destructor { hlsl_func_parameters_cleanup(&$$); } <parameters>
 
 %type <reg_reservation> register_reservation
 %type <reg_reservation> packoffset_reservation
@@ -7419,6 +7428,7 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
 %type <so_type> so_type
 
 %type <state_block> state_block
+%destructor { hlsl_free_state_block($$); } <state_block>
 
 %type <state_block_index> state_block_index_opt
 
@@ -7778,7 +7788,7 @@ attribute:
             if (!($$ = hlsl_alloc(ctx, offsetof(struct hlsl_attribute, args[$4.args_count]))))
             {
                 vkd3d_free($2);
-                free_parse_initializer(&$4);
+                cleanup_parse_initializer(&$4);
                 YYABORT;
             }
             $$->name = $2;
@@ -7788,7 +7798,7 @@ attribute:
             $$->args_count = $4.args_count;
             for (i = 0; i < $4.args_count; ++i)
                 hlsl_src_from_node(&$$->args[i], $4.args[i]);
-            free_parse_initializer(&$4);
+            cleanup_parse_initializer(&$4);
         }
 
 attribute_list:
@@ -7876,14 +7886,13 @@ func_declaration:
             hlsl_pop_scope(ctx);
 
             if (!$1.first)
-            {
-                vkd3d_free($1.parameters.vars);
-                hlsl_cleanup_semantic(&$1.return_semantic);
-            }
+                parse_function_cleanup(&$1);
         }
     | func_prototype ';'
         {
             hlsl_pop_scope(ctx);
+            if (!$1.first)
+                parse_function_cleanup(&$1);
         }
 
 func_prototype_no_attrs:
@@ -9305,15 +9314,15 @@ complex_initializer_list:
             $$ = $1;
             if (!(new_args = hlsl_realloc(ctx, $$.args, ($$.args_count + $3.args_count) * sizeof(*$$.args))))
             {
-                free_parse_initializer(&$$);
-                free_parse_initializer(&$3);
+                cleanup_parse_initializer(&$$);
+                cleanup_parse_initializer(&$3);
                 YYABORT;
             }
             $$.args = new_args;
             for (i = 0; i < $3.args_count; ++i)
                 $$.args[$$.args_count++] = $3.args[i];
             hlsl_block_add_block($$.instrs, $3.instrs);
-            free_parse_initializer(&$3);
+            cleanup_parse_initializer(&$3);
             $$.loc = @$;
         }
 
@@ -9341,7 +9350,7 @@ initializer_expr_list:
             $$ = $1;
             if (!(new_args = hlsl_realloc(ctx, $$.args, ($$.args_count + 1) * sizeof(*$$.args))))
             {
-                free_parse_initializer(&$$);
+                cleanup_parse_initializer(&$$);
                 destroy_block($3);
                 YYABORT;
             }
@@ -9857,7 +9866,7 @@ postfix_expr:
 
             if (!($$ = add_constructor(ctx, $2, &$4, &@2)))
             {
-                free_parse_initializer(&$4);
+                cleanup_parse_initializer(&$4);
                 YYABORT;
             }
         }
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index 06ce5801066..a4eaac97ebf 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -614,12 +614,12 @@ static struct vsir_src_operand *vsir_program_clone_src_operands(
     return ret;
 }
 
-static void shader_instruction_array_destroy(struct vkd3d_shader_instruction_array *array)
+void shader_instruction_array_cleanup(struct vkd3d_shader_instruction_array *array)
 {
     vkd3d_free(array->elements);
 }
 
-static bool shader_instruction_array_init(struct vkd3d_shader_instruction_array *array, size_t reserve)
+bool shader_instruction_array_init(struct vkd3d_shader_instruction_array *array, size_t reserve)
 {
     memset(array, 0, sizeof(*array));
 
@@ -724,7 +724,7 @@ void vsir_program_cleanup(struct vsir_program *program)
         vkd3d_free((void *)program->block_names[i]);
     vkd3d_free(program->block_names);
     vkd3d_shader_source_list_cleanup(&program->source_files);
-    shader_instruction_array_destroy(&program->instructions);
+    shader_instruction_array_cleanup(&program->instructions);
     shader_signature_cleanup(&program->input_signature);
     shader_signature_cleanup(&program->output_signature);
     shader_signature_cleanup(&program->patch_constant_signature);
@@ -3131,7 +3131,7 @@ static enum vkd3d_result vsir_program_lower_d3dbc_loops(
     struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
     bool has_loop = false, has_input_with_loop_rel_addr = false;
     struct vkd3d_shader_instruction *ins;
-    unsigned int idxtemp_idx, i;
+    unsigned int idxtemp_idx = 0, i;
     enum vkd3d_result ret;
 
     for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
@@ -5101,7 +5101,7 @@ static enum vkd3d_result vsir_program_remove_dead_code(struct vsir_program *prog
 static void vsir_program_replace_instructions(struct vsir_program *program,
         struct vkd3d_shader_instruction_array *array)
 {
-    shader_instruction_array_destroy(&program->instructions);
+    shader_instruction_array_cleanup(&program->instructions);
 
     program->instructions = *array;
     memset(array, 0, sizeof(*array));
@@ -5762,7 +5762,7 @@ static enum vkd3d_result vsir_program_flatten_control_flow_constructs(struct vsi
     }
     else
     {
-        shader_instruction_array_destroy(&flattener.instructions);
+        shader_instruction_array_cleanup(&flattener.instructions);
     }
 
     vkd3d_free(flattener.control_flow_info);
@@ -5938,7 +5938,7 @@ static enum vkd3d_result vsir_program_lower_switch_to_selection_ladder(struct vs
     return VKD3D_OK;
 
 fail:
-    shader_instruction_array_destroy(&instructions);
+    shader_instruction_array_cleanup(&instructions);
     vkd3d_free(block_map);
 
     return VKD3D_ERROR_OUT_OF_MEMORY;
@@ -8392,7 +8392,7 @@ static enum vkd3d_result vsir_program_structurize(struct vsir_program *program,
     return VKD3D_OK;
 
 fail:
-    shader_instruction_array_destroy(&target.instructions);
+    shader_instruction_array_cleanup(&target.instructions);
 
     return ret;
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index 5a75c0bc5fd..003a6635aaf 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -3267,7 +3267,10 @@ static void tpf_write_signature(struct tpf_compiler *tpf, const struct shader_si
     put_u32(&buffer, 8); /* unknown */
 
     if (!(sorted_elements = vkd3d_calloc(signature->element_count, sizeof(*sorted_elements))))
+    {
+        vkd3d_bytecode_buffer_cleanup(&buffer);
         return;
+    }
     for (i = 0; i < signature->element_count; ++i)
         sorted_elements[i] = &signature->elements[i];
     qsort(sorted_elements, signature->element_count, sizeof(*sorted_elements), signature_element_pointer_compare);
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index 8e4254352b0..7c278a63b80 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -1502,6 +1502,8 @@ struct vkd3d_shader_instruction_array
     size_t count;
 };
 
+bool shader_instruction_array_init(struct vkd3d_shader_instruction_array *array, size_t reserve);
+void shader_instruction_array_cleanup(struct vkd3d_shader_instruction_array *array);
 struct vkd3d_shader_instruction *shader_instruction_array_append(struct vkd3d_shader_instruction_array *array);
 bool shader_instruction_array_insert_at(struct vkd3d_shader_instruction_array *instructions, size_t idx, size_t count);
 
-- 
2.51.0

