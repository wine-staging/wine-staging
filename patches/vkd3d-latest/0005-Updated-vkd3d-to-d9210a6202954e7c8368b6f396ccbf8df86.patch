From f7f8b553950c886626220e2f425a93ca89e7819d Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 22 Jan 2026 10:26:48 +1100
Subject: [PATCH] Updated vkd3d to d9210a6202954e7c8368b6f396ccbf8df866cd4d.

---
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c        |   2 +
 libs/vkd3d/libs/vkd3d-shader/ir.c             |  64 ++++++++++-
 libs/vkd3d/libs/vkd3d-shader/tpf.c            | 101 +++++++++++-------
 .../libs/vkd3d-shader/vkd3d_shader_main.c     |  16 +++
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |  18 ++++
 libs/vkd3d/libs/vkd3d/command.c               |   8 ++
 libs/vkd3d/libs/vkd3d/vkd3d_private.h         |   1 +
 7 files changed, 169 insertions(+), 41 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index 992f1876d42..4fcdd0e4246 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -2118,6 +2118,7 @@ enum vkd3d_result d3d_asm_compile(struct vsir_program *program, const struct vkd
             case VSIR_OP_ELSE:
             case VSIR_OP_ENDIF:
             case VSIR_OP_ENDLOOP:
+            case VSIR_OP_ENDREP:
             case VSIR_OP_ENDSWITCH:
                 if (indent)
                     --indent;
@@ -2148,6 +2149,7 @@ enum vkd3d_result d3d_asm_compile(struct vsir_program *program, const struct vkd
             case VSIR_OP_IF:
             case VSIR_OP_IFC:
             case VSIR_OP_LOOP:
+            case VSIR_OP_REP:
             case VSIR_OP_SWITCH:
             case VSIR_OP_LABEL:
                 ++indent;
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index 9e7ded9a2fa..c56fee6426e 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -2467,6 +2467,54 @@ static enum vkd3d_result vsir_program_lower_bem(struct vsir_program *program, st
     return VKD3D_OK;
 }
 
+static enum vkd3d_result vsir_program_lower_rep(struct vsir_program *program, struct vsir_program_iterator *rep)
+{
+    struct vkd3d_shader_instruction *ins = vsir_program_iterator_current(rep);
+    struct vkd3d_shader_location location = ins->location;
+    const struct vsir_src_operand *src = ins->src;
+    unsigned int iter_id = program->temp_count++;
+    struct vsir_program_iterator it;
+
+    /* rep SRC0
+     *      ->
+     * mov rITER, SRC0
+     * loop
+     *     breakp_z rITER
+     *     iadd rITER, rITER, -1 */
+
+    /* NOTE: `endrep -> endloop` is done by another pass. */
+
+    if (!(ins = vsir_program_iterator_insert_before(rep, &it, 3)))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    if (!vsir_instruction_init_with_params(program, ins, &location, VSIR_OP_MOV, 1, 1))
+        goto fail;
+    ins->src[0] = src[0];
+    vsir_dst_operand_init_temp_u32(&ins->dst[0], iter_id);
+
+    ins = vsir_program_iterator_next(&it);
+    vsir_instruction_init(ins, &location, VSIR_OP_LOOP);
+
+    ins = vsir_program_iterator_next(&it);
+    if (!vsir_instruction_init_with_params(program, ins, &location, VSIR_OP_BREAKP, 0, 1))
+        goto fail;
+    ins->flags = VKD3D_SHADER_CONDITIONAL_OP_Z;
+    vsir_src_operand_init_temp_u32(&ins->src[0], iter_id);
+
+    ins = vsir_program_iterator_next(&it);
+    if (!vsir_instruction_init_with_params(program, ins, &location, VSIR_OP_IADD, 1, 2))
+        goto fail;
+    vsir_dst_operand_init_temp_u32(&ins->dst[0], iter_id);
+    vsir_src_operand_init_temp_u32(&ins->src[0], iter_id);
+    vsir_src_operand_init_const_u32(&ins->src[1], ~0u);
+
+    return VKD3D_OK;
+
+fail:
+    vsir_program_iterator_nop_range(&it, rep, &location);
+
+    return VKD3D_ERROR_OUT_OF_MEMORY;
+}
+
 static enum vkd3d_result vsir_program_lower_texbem(struct vsir_program *program,
         struct vsir_program_iterator *it, struct vkd3d_shader_message_context *message_context)
 {
@@ -2687,6 +2735,15 @@ static enum vkd3d_result vsir_program_lower_d3dbc_instructions(struct vsir_progr
                 ret = vsir_program_lower_dp2add(program, &it);
                 break;
 
+            case VSIR_OP_ENDREP:
+                ins->opcode = VSIR_OP_ENDLOOP;
+                ret = VKD3D_OK;
+                break;
+
+            case VSIR_OP_REP:
+                ret = vsir_program_lower_rep(program, &it);
+                break;
+
             case VSIR_OP_IFC:
                 ret = vsir_program_lower_ifc(program, &it, &tmp_idx, message_context);
                 break;
@@ -2764,6 +2821,11 @@ static enum vkd3d_result vsir_program_lower_d3dbc_instructions(struct vsir_progr
                         vsir_opcode_get_name(ins->opcode, "<unknown>"), ins->opcode);
                 return VKD3D_ERROR_NOT_IMPLEMENTED;
 
+            case VSIR_OP_LOOP:
+                vkd3d_shader_error(ctx->message_context, &ins->location, VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED,
+                        "Aborting due to unimplemented feature: Lower SM1 loops.");
+                return VKD3D_ERROR_NOT_IMPLEMENTED;
+
             default:
                 ret = VKD3D_OK;
                 break;
@@ -13997,7 +14059,7 @@ static void vsir_validate_label(struct validation_context *ctx, const struct vkd
 static void vsir_validate_loop(struct validation_context *ctx, const struct vkd3d_shader_instruction *instruction)
 {
     vsir_validate_cf_type(ctx, instruction, VSIR_CF_STRUCTURED);
-    vsir_validate_src_count(ctx, instruction, ctx->program->shader_version.major <= 3 ? 2 : 0);
+    vsir_validate_src_count(ctx, instruction, ctx->program->normalisation_level >= VSIR_NORMALISED_SM4 ? 0 : 2);
     vsir_validator_push_block(ctx, VSIR_OP_LOOP);
 }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index ff749c26e1e..cd253700e4d 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -1398,15 +1398,31 @@ struct sm4_stat
 struct tpf_compiler
 {
     struct vsir_program *program;
+
+    struct vkd3d_shader_location location;
+    struct vkd3d_shader_message_context *message_context;
+    enum vkd3d_shader_error first_error;
+
     struct vkd3d_sm4_lookup_tables lookup;
     struct sm4_stat *stat;
 
-    int result;
-
     struct vkd3d_bytecode_buffer *buffer;
     struct dxbc_writer dxbc;
 };
 
+static void VKD3D_PRINTF_FUNC(3, 4) tpf_compiler_error(struct tpf_compiler *tpf,
+        enum vkd3d_shader_error error, const char *fmt, ...)
+{
+    va_list args;
+
+    va_start(args, fmt);
+    vkd3d_shader_verror(tpf->message_context, &tpf->location, error, fmt, args);
+    va_end(args);
+
+    if (!tpf->first_error)
+        tpf->first_error = error;
+}
+
 static void init_sm4_lookup_tables(struct vkd3d_sm4_lookup_tables *lookup)
 {
     unsigned int i;
@@ -3216,8 +3232,8 @@ static void add_section(struct tpf_compiler *tpf, uint32_t tag, struct vkd3d_byt
 
     dxbc_writer_add_section(&tpf->dxbc, tag, buffer->data, size);
 
-    if (buffer->status < 0)
-        tpf->result = buffer->status;
+    if (buffer->status < 0 && !tpf->first_error)
+        tpf->first_error = VKD3D_SHADER_ERROR_TPF_OUT_OF_MEMORY;
 }
 
 static int signature_element_pointer_compare(const void *x, const void *y)
@@ -3517,7 +3533,7 @@ static void sm4_write_dst_register(const struct tpf_compiler *tpf, const struct
         sm4_write_register_index(tpf, &dst->reg, j);
 }
 
-static void sm4_write_src_register(const struct tpf_compiler *tpf, const struct vsir_src_operand *src)
+static void sm4_write_src_register(struct tpf_compiler *tpf, const struct vsir_src_operand *src)
 {
     struct vkd3d_bytecode_buffer *buffer = tpf->buffer;
     uint32_t token = 0, mod_token = 0;
@@ -3547,8 +3563,8 @@ static void sm4_write_src_register(const struct tpf_compiler *tpf, const struct
             break;
 
         default:
-            ERR("Unhandled register modifier %#x.\n", src->modifiers);
-            vkd3d_unreachable();
+            tpf_compiler_error(tpf, VKD3D_SHADER_ERROR_TPF_NOT_IMPLEMENTED,
+                    "Unhandled register modifier %#x.\n", src->modifiers);
             break;
     }
 
@@ -3623,7 +3639,7 @@ static void sm4_update_stat_counters(const struct tpf_compiler *tpf, const struc
     }
 }
 
-static void write_sm4_instruction(const struct tpf_compiler *tpf, const struct sm4_instruction *instr)
+static void write_sm4_instruction(struct tpf_compiler *tpf, const struct sm4_instruction *instr)
 {
     uint32_t token = instr->opcode | instr->extra_bits;
     struct vkd3d_bytecode_buffer *buffer = tpf->buffer;
@@ -3663,7 +3679,7 @@ static void write_sm4_instruction(const struct tpf_compiler *tpf, const struct s
     sm4_update_stat_counters(tpf, instr);
 }
 
-static void tpf_dcl_constant_buffer(const struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
+static void tpf_dcl_constant_buffer(struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
     const struct vkd3d_shader_constant_buffer *cb = &ins->declaration.cb;
     size_t size = cb->size / VKD3D_VEC4_SIZE / sizeof(float);
@@ -3700,7 +3716,7 @@ static void tpf_dcl_constant_buffer(const struct tpf_compiler *tpf, const struct
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_dcl_temps(const struct tpf_compiler *tpf, unsigned int count)
+static void tpf_dcl_temps(struct tpf_compiler *tpf, unsigned int count)
 {
     struct sm4_instruction instr =
     {
@@ -3713,7 +3729,7 @@ static void tpf_dcl_temps(const struct tpf_compiler *tpf, unsigned int count)
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_dcl_indexable_temp(const struct tpf_compiler *tpf, const struct vkd3d_shader_indexable_temp *temp)
+static void tpf_dcl_indexable_temp(struct tpf_compiler *tpf, const struct vkd3d_shader_indexable_temp *temp)
 {
     struct sm4_instruction instr =
     {
@@ -3726,7 +3742,7 @@ static void tpf_dcl_indexable_temp(const struct tpf_compiler *tpf, const struct
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_dcl_semantic(const struct tpf_compiler *tpf, enum vkd3d_sm4_opcode opcode,
+static void tpf_dcl_semantic(struct tpf_compiler *tpf, enum vkd3d_sm4_opcode opcode,
         const struct vsir_dst_operand *dst, uint32_t interpolation_flags)
 {
     struct sm4_instruction instr =
@@ -3742,7 +3758,7 @@ static void tpf_dcl_semantic(const struct tpf_compiler *tpf, enum vkd3d_sm4_opco
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_dcl_siv_semantic(const struct tpf_compiler *tpf, enum vkd3d_sm4_opcode opcode,
+static void tpf_dcl_siv_semantic(struct tpf_compiler *tpf, enum vkd3d_sm4_opcode opcode,
         const struct vkd3d_shader_register_semantic *semantic, uint32_t interpolation_flags)
 {
     struct sm4_instruction instr =
@@ -3761,7 +3777,7 @@ static void tpf_dcl_siv_semantic(const struct tpf_compiler *tpf, enum vkd3d_sm4_
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_dcl_thread_group(const struct tpf_compiler *tpf, const struct vsir_thread_group_size *group_size)
+static void tpf_dcl_thread_group(struct tpf_compiler *tpf, const struct vsir_thread_group_size *group_size)
 {
     struct sm4_instruction instr =
     {
@@ -3774,7 +3790,7 @@ static void tpf_dcl_thread_group(const struct tpf_compiler *tpf, const struct vs
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_dcl_sampler(const struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
+static void tpf_dcl_sampler(struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
     const struct vkd3d_shader_sampler *sampler = &ins->declaration.sampler;
     struct sm4_instruction instr =
@@ -3824,7 +3840,7 @@ static uint32_t pack_resource_data_type(const enum vsir_data_type *resource_data
     return type;
 }
 
-static void tpf_dcl_texture(const struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
+static void tpf_dcl_texture(struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
     const struct vkd3d_shader_version *version = &tpf->program->shader_version;
     const struct vkd3d_shader_resource *resource;
@@ -3885,7 +3901,7 @@ static void tpf_dcl_texture(const struct tpf_compiler *tpf, const struct vkd3d_s
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_dcl_tgsm_raw(const struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
+static void tpf_dcl_tgsm_raw(struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
     const struct vkd3d_shader_tgsm_raw *tgsm = &ins->declaration.tgsm_raw;
     struct sm4_instruction instr =
@@ -3902,7 +3918,7 @@ static void tpf_dcl_tgsm_raw(const struct tpf_compiler *tpf, const struct vkd3d_
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_dcl_tgsm_structured(const struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
+static void tpf_dcl_tgsm_structured(struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
     const struct vkd3d_shader_tgsm_structured *tgsm = &ins->declaration.tgsm_structured;
     struct sm4_instruction instr =
@@ -3920,7 +3936,7 @@ static void tpf_dcl_tgsm_structured(const struct tpf_compiler *tpf, const struct
     write_sm4_instruction(tpf, &instr);
 }
 
-static void write_sm4_dcl_global_flags(const struct tpf_compiler *tpf, uint32_t flags)
+static void write_sm4_dcl_global_flags(struct tpf_compiler *tpf, uint32_t flags)
 {
     struct sm4_instruction instr =
     {
@@ -3931,7 +3947,7 @@ static void write_sm4_dcl_global_flags(const struct tpf_compiler *tpf, uint32_t
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_hs_decls(const struct tpf_compiler *tpf)
+static void tpf_write_hs_decls(struct tpf_compiler *tpf)
 {
     struct sm4_instruction instr =
     {
@@ -3941,7 +3957,7 @@ static void tpf_write_hs_decls(const struct tpf_compiler *tpf)
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_dcl_input_control_point_count(const struct tpf_compiler *tpf, const uint32_t count)
+static void tpf_write_dcl_input_control_point_count(struct tpf_compiler *tpf, const uint32_t count)
 {
     struct sm4_instruction instr =
     {
@@ -3952,7 +3968,7 @@ static void tpf_write_dcl_input_control_point_count(const struct tpf_compiler *t
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_dcl_output_control_point_count(const struct tpf_compiler *tpf, const uint32_t count)
+static void tpf_write_dcl_output_control_point_count(struct tpf_compiler *tpf, const uint32_t count)
 {
     struct sm4_instruction instr =
     {
@@ -3963,7 +3979,7 @@ static void tpf_write_dcl_output_control_point_count(const struct tpf_compiler *
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_dcl_tessellator_domain(const struct tpf_compiler *tpf, enum vkd3d_tessellator_domain domain)
+static void tpf_write_dcl_tessellator_domain(struct tpf_compiler *tpf, enum vkd3d_tessellator_domain domain)
 {
     struct sm4_instruction instr =
     {
@@ -3974,7 +3990,7 @@ static void tpf_write_dcl_tessellator_domain(const struct tpf_compiler *tpf, enu
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_dcl_tessellator_partitioning(const struct tpf_compiler *tpf,
+static void tpf_write_dcl_tessellator_partitioning(struct tpf_compiler *tpf,
         enum vkd3d_shader_tessellator_partitioning partitioning)
 {
     struct sm4_instruction instr =
@@ -3986,7 +4002,7 @@ static void tpf_write_dcl_tessellator_partitioning(const struct tpf_compiler *tp
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_dcl_tessellator_output_primitive(const struct tpf_compiler *tpf,
+static void tpf_write_dcl_tessellator_output_primitive(struct tpf_compiler *tpf,
         enum vkd3d_shader_tessellator_output_primitive output_primitive)
 {
     struct sm4_instruction instr =
@@ -3998,7 +4014,7 @@ static void tpf_write_dcl_tessellator_output_primitive(const struct tpf_compiler
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_dcl_input_primitive(const struct tpf_compiler *tpf, enum vkd3d_primitive_type input_primitive,
+static void tpf_write_dcl_input_primitive(struct tpf_compiler *tpf, enum vkd3d_primitive_type input_primitive,
         unsigned int patch_vertex_count)
 {
     enum vkd3d_sm4_input_primitive_type sm4_input_primitive;
@@ -4023,7 +4039,7 @@ static void tpf_write_dcl_input_primitive(const struct tpf_compiler *tpf, enum v
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_dcl_output_topology(const struct tpf_compiler *tpf, enum vkd3d_primitive_type output_topology)
+static void tpf_write_dcl_output_topology(struct tpf_compiler *tpf, enum vkd3d_primitive_type output_topology)
 {
     struct sm4_instruction instr =
     {
@@ -4036,7 +4052,7 @@ static void tpf_write_dcl_output_topology(const struct tpf_compiler *tpf, enum v
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_dcl_vertices_out(const struct tpf_compiler *tpf, unsigned int count)
+static void tpf_write_dcl_vertices_out(struct tpf_compiler *tpf, unsigned int count)
 {
     struct sm4_instruction instr =
     {
@@ -4097,16 +4113,19 @@ static void tpf_simple_instruction(struct tpf_compiler *tpf, const struct vkd3d_
 
     if (ins->dst_count != dst_count)
     {
-        ERR("Invalid destination count %zu for vsir instruction %#x (expected %u).\n",
-                ins->dst_count, ins->opcode, dst_count);
-        tpf->result = VKD3D_ERROR_INVALID_SHADER;
+        tpf_compiler_error(tpf, VKD3D_SHADER_ERROR_TPF_INTERNAL,
+                "Internal compiler error: Invalid destination operand count %zu "
+                "for instruction \"%s\" (%#x), expected %u.",
+                ins->dst_count, vsir_opcode_get_name(ins->opcode, "<unknown>"), ins->opcode, dst_count);
         return;
     }
+
     if (ins->src_count != src_count)
     {
-        ERR("Invalid source count %zu for vsir instruction %#x (expected %u).\n",
-                ins->src_count, ins->opcode, src_count);
-        tpf->result = VKD3D_ERROR_INVALID_SHADER;
+        tpf_compiler_error(tpf, VKD3D_SHADER_ERROR_TPF_INTERNAL,
+                "Internal compiler error: Invalid source operand count %zu "
+                "for instruction \"%s\" (%#x), expected %u.",
+                ins->src_count, vsir_opcode_get_name(ins->opcode, "<unknown>"), ins->opcode, src_count);
         return;
     }
 
@@ -4155,6 +4174,8 @@ static void tpf_simple_instruction(struct tpf_compiler *tpf, const struct vkd3d_
 
 static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
+    tpf->location = ins->location;
+
     switch (ins->opcode)
     {
         case VSIR_OP_NOP:
@@ -4356,7 +4377,9 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
             break;
 
         default:
-            vkd3d_unreachable();
+            tpf_compiler_error(tpf, VKD3D_SHADER_ERROR_TPF_NOT_IMPLEMENTED,
+                    "Unhandled instruction \"%s\" (%#x).\n",
+                    vsir_opcode_get_name(ins->opcode, "<unknown>"), ins->opcode);
             break;
     }
 }
@@ -4534,6 +4557,8 @@ int tpf_compile(struct vsir_program *program, uint64_t config_flags,
         return ret;
 
     tpf.program = program;
+    tpf.location.source_name = compile_info->source_name;
+    tpf.message_context = message_context;
     tpf.buffer = NULL;
     tpf.stat = &stat;
     init_sm4_lookup_tables(&tpf.lookup);
@@ -4548,11 +4573,7 @@ int tpf_compile(struct vsir_program *program, uint64_t config_flags,
     tpf_write_sfi0(&tpf);
     tpf_write_stat(&tpf);
 
-    ret = VKD3D_OK;
-    if (tpf.result)
-        ret = tpf.result;
-
-    if (!ret)
+    if (!(ret = vkd3d_result_from_shader_error(tpf.first_error)))
         ret = dxbc_writer_write(&tpf.dxbc, out);
     for (i = 0; i < tpf.dxbc.section_count; ++i)
         vkd3d_shader_free_shader_code(&tpf.dxbc.sections[i].data);
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index a8a84ad3f7f..d19ff27a882 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -976,6 +976,7 @@ struct vkd3d_shader_scan_context
         {
             VKD3D_SHADER_BLOCK_IF,
             VKD3D_SHADER_BLOCK_LOOP,
+            VKD3D_SHADER_BLOCK_REP,
             VKD3D_SHADER_BLOCK_SWITCH,
         } type;
         bool inside_block;
@@ -1087,6 +1088,7 @@ static struct vkd3d_shader_cf_info *vkd3d_shader_scan_find_innermost_breakable_c
     {
         cf_info = &context->cf_info[--count];
         if (cf_info->type == VKD3D_SHADER_BLOCK_LOOP
+                || cf_info->type == VKD3D_SHADER_BLOCK_REP
                 || cf_info->type == VKD3D_SHADER_BLOCK_SWITCH)
             return cf_info;
     }
@@ -1436,6 +1438,20 @@ static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *conte
             }
             vkd3d_shader_scan_pop_cf_info(context);
             break;
+        case VSIR_OP_REP:
+            cf_info = vkd3d_shader_scan_push_cf_info(context);
+            cf_info->type = VKD3D_SHADER_BLOCK_REP;
+            cf_info->inside_block = true;
+            break;
+        case VSIR_OP_ENDREP:
+            if (!(cf_info = vkd3d_shader_scan_get_current_cf_info(context)) || cf_info->type != VKD3D_SHADER_BLOCK_REP)
+            {
+                vkd3d_shader_scan_error(context, VKD3D_SHADER_ERROR_TPF_MISMATCHED_CF,
+                        "Encountered ‘endrep’ instruction without corresponding ‘rep’ block.");
+                return VKD3D_ERROR_INVALID_SHADER;
+            }
+            vkd3d_shader_scan_pop_cf_info(context);
+            break;
         case VSIR_OP_SWITCH:
             cf_info = vkd3d_shader_scan_push_cf_info(context);
             cf_info->type = VKD3D_SHADER_BLOCK_SWITCH;
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index 8809019ef59..2f52ed5527b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -90,6 +90,8 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_TPF_INVALID_REGISTER_DIMENSION   = 1008,
     VKD3D_SHADER_ERROR_TPF_INVALID_REGISTER_SWIZZLE     = 1009,
     VKD3D_SHADER_ERROR_TPF_INVALID_REGISTER_DCL         = 1010,
+    VKD3D_SHADER_ERROR_TPF_INTERNAL                     = 1011,
+    VKD3D_SHADER_ERROR_TPF_NOT_IMPLEMENTED              = 1012,
 
     VKD3D_SHADER_WARNING_TPF_MASK_NOT_CONTIGUOUS        = 1300,
     VKD3D_SHADER_WARNING_TPF_UNHANDLED_INDEX_RANGE_MASK = 1301,
@@ -291,6 +293,22 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_FX_OUT_OF_MEMORY                 = 11004,
 };
 
+static inline enum vkd3d_result vkd3d_result_from_shader_error(enum vkd3d_shader_error e)
+{
+    if (!e)
+        return VKD3D_OK;
+
+    switch (e)
+    {
+        case VKD3D_SHADER_ERROR_TPF_OUT_OF_MEMORY:
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+        case VKD3D_SHADER_ERROR_TPF_NOT_IMPLEMENTED:
+            return VKD3D_ERROR_NOT_IMPLEMENTED;
+        default:
+            return VKD3D_ERROR_INVALID_SHADER;
+    }
+}
+
 enum vkd3d_shader_opcode
 {
     VSIR_OP_ABS,
diff --git a/libs/vkd3d/libs/vkd3d/command.c b/libs/vkd3d/libs/vkd3d/command.c
index 7d9a86e909f..84407e05cdb 100644
--- a/libs/vkd3d/libs/vkd3d/command.c
+++ b/libs/vkd3d/libs/vkd3d/command.c
@@ -1271,6 +1271,7 @@ static HRESULT d3d12_fence_init(struct d3d12_fence *fence, struct d3d12_device *
     fence->timeline_semaphore = VK_NULL_HANDLE;
     fence->timeline_value = 0;
     fence->pending_timeline_value = 0;
+    fence->last_waited_value = 0;
     if (device->vk_info.KHR_timeline_semaphore && (vr = vkd3d_create_timeline_semaphore(device, 0,
             &fence->timeline_semaphore)) < 0)
     {
@@ -7334,6 +7335,7 @@ static HRESULT d3d12_command_queue_wait_binary_semaphore_locked(struct d3d12_com
 
         command_queue->last_waited_fence = fence;
         command_queue->last_waited_fence_value = value;
+        fence->last_waited_value = value;
     }
 
     vkd3d_queue_release(queue);
@@ -7660,8 +7662,14 @@ static HRESULT d3d12_command_queue_flush_ops_locked(struct d3d12_command_queue *
                     vkd3d_mutex_lock(&fence->mutex);
                     if (op->u.wait.value > fence->max_pending_value)
                     {
+                        uint64_t last_waited_value = fence->last_waited_value;
+
                         vkd3d_mutex_unlock(&fence->mutex);
                         d3d12_command_queue_delete_aux_ops(queue, i);
+                        if (op->u.wait.value <= last_waited_value)
+                            ERR("Waiting on a value already waited on by a fence (%p %"PRIx64" <= %"PRIx64").  "
+                                "This application probably requires Vulkan timeline semaphores to work correctly.\n",
+                                fence, op->u.wait.value, last_waited_value);
                         vkd3d_mutex_lock(&queue->op_mutex);
                         return d3d12_command_queue_fixup_after_flush_locked(queue);
                     }
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
index f2e78503302..e9f835acddd 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -396,6 +396,7 @@ struct d3d12_fence
 
     uint64_t value;
     uint64_t max_pending_value;
+    uint64_t last_waited_value;
     struct vkd3d_mutex mutex;
 
     struct vkd3d_waiting_event
-- 
2.51.0

