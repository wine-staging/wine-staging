From bde94d21a682ec4cd30860b2bd293bb158910006 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 23 Jul 2025 07:16:58 +1000
Subject: [PATCH] Updated vkd3d to 68cd72c7fc7a364ecce87a19617acb382c70762f.

---
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c        |  33 ++---
 libs/vkd3d/libs/vkd3d-shader/d3dbc.c          |  21 ++--
 libs/vkd3d/libs/vkd3d-shader/dxil.c           |  60 ++++-----
 libs/vkd3d/libs/vkd3d-shader/glsl.c           |  54 ++++----
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c   |  22 ++--
 libs/vkd3d/libs/vkd3d-shader/ir.c             | 116 ++++++++----------
 libs/vkd3d/libs/vkd3d-shader/msl.c            |  43 +++----
 libs/vkd3d/libs/vkd3d-shader/spirv.c          |  63 +++++-----
 libs/vkd3d/libs/vkd3d-shader/tpf.c            |  44 ++++---
 .../libs/vkd3d-shader/vkd3d_shader_main.c     |  18 +--
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |  46 ++++---
 11 files changed, 260 insertions(+), 260 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index 7d10cf98f71..5e3e7daab83 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -388,21 +388,21 @@ static void shader_print_data_type(struct vkd3d_d3d_asm_compiler *compiler, enum
 {
     static const char *const data_type_names[] =
     {
-        [VKD3D_DATA_INT      ] = "int",
-        [VKD3D_DATA_UINT     ] = "uint",
         [VKD3D_DATA_UNORM    ] = "unorm",
         [VKD3D_DATA_SNORM    ] = "snorm",
         [VKD3D_DATA_OPAQUE   ] = "opaque",
         [VKD3D_DATA_MIXED    ] = "mixed",
         [VKD3D_DATA_CONTINUED] = "<continued>",
         [VKD3D_DATA_UNUSED   ] = "<unused>",
-        [VKD3D_DATA_UINT8    ] = "uint8",
-        [VKD3D_DATA_UINT64   ] = "uint64",
         [VKD3D_DATA_BOOL     ] = "bool",
-        [VKD3D_DATA_UINT16   ] = "uint16",
         [VSIR_DATA_F16      ] = "half",
         [VSIR_DATA_F32      ] = "float",
         [VSIR_DATA_F64      ] = "double",
+        [VSIR_DATA_I32      ] = "int",
+        [VSIR_DATA_U8       ] = "uint8",
+        [VSIR_DATA_U16      ] = "uint16",
+        [VSIR_DATA_U32      ] = "uint",
+        [VSIR_DATA_U64      ] = "uint64",
     };
 
     if (type < ARRAY_SIZE(data_type_names))
@@ -736,10 +736,10 @@ static void shader_print_register(struct vkd3d_d3d_asm_compiler *compiler, const
                         else
                             shader_print_float_literal(compiler, "", reg->u.immconst_f32[0], "");
                         break;
-                    case VKD3D_DATA_INT:
+                    case VSIR_DATA_I32:
                         shader_print_int_literal(compiler, "", reg->u.immconst_u32[0], "");
                         break;
-                    case VKD3D_DATA_UINT:
+                    case VSIR_DATA_U32:
                         shader_print_uint_literal(compiler, "", reg->u.immconst_u32[0], "");
                         break;
                     default:
@@ -768,13 +768,13 @@ static void shader_print_register(struct vkd3d_d3d_asm_compiler *compiler, const
                             shader_print_float_literal(compiler, ", ", reg->u.immconst_f32[3], "");
                         }
                         break;
-                    case VKD3D_DATA_INT:
+                    case VSIR_DATA_I32:
                         shader_print_int_literal(compiler, "", reg->u.immconst_u32[0], "");
                         shader_print_int_literal(compiler, ", ", reg->u.immconst_u32[1], "");
                         shader_print_int_literal(compiler, ", ", reg->u.immconst_u32[2], "");
                         shader_print_int_literal(compiler, ", ", reg->u.immconst_u32[3], "");
                         break;
-                    case VKD3D_DATA_UINT:
+                    case VSIR_DATA_U32:
                         shader_print_uint_literal(compiler, "", reg->u.immconst_u32[0], "");
                         shader_print_uint_literal(compiler, ", ", reg->u.immconst_u32[1], "");
                         shader_print_uint_literal(compiler, ", ", reg->u.immconst_u32[2], "");
@@ -806,7 +806,7 @@ static void shader_print_register(struct vkd3d_d3d_asm_compiler *compiler, const
                 if (reg->dimension == VSIR_DIMENSION_VEC4)
                     shader_print_double_literal(compiler, ", ", reg->u.immconst_f64[1], "");
             }
-            else if (reg->data_type == VKD3D_DATA_UINT64)
+            else if (reg->data_type == VSIR_DATA_U64)
             {
                 shader_print_uint64_literal(compiler, "", reg->u.immconst_u64[0], "");
                 if (reg->dimension == VSIR_DIMENSION_VEC4)
@@ -1951,8 +1951,7 @@ static void shader_print_descriptors(struct vkd3d_d3d_asm_compiler *compiler,
     }
 }
 
-enum vkd3d_result d3d_asm_compile(const struct vsir_program *program,
-        const struct vkd3d_shader_compile_info *compile_info,
+enum vkd3d_result d3d_asm_compile(struct vsir_program *program, const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_code *out, enum vsir_asm_flags flags)
 {
     const struct vkd3d_shader_version *shader_version = &program->shader_version;
@@ -1961,8 +1960,10 @@ enum vkd3d_result d3d_asm_compile(const struct vsir_program *program,
     {
         .flags = flags,
     };
+    struct vkd3d_shader_instruction *ins;
     enum vkd3d_result result = VKD3D_OK;
     struct vkd3d_string_buffer *buffer;
+    struct vsir_program_iterator it;
     unsigned int indent, i, j;
     const char *indent_str;
 
@@ -2042,10 +2043,10 @@ enum vkd3d_result d3d_asm_compile(const struct vsir_program *program,
         vkd3d_string_buffer_printf(buffer, "%s.text%s\n", compiler.colours.opcode, compiler.colours.reset);
 
     indent = 0;
-    for (i = 0; i < program->instructions.count; ++i)
-    {
-        struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
 
+    it = vsir_program_iterator(&program->instructions);
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
+    {
         switch (ins->opcode)
         {
             case VSIR_OP_ELSE:
@@ -2236,7 +2237,7 @@ static void trace_io_declarations(const struct vsir_program *program)
     vkd3d_string_buffer_cleanup(&buffer);
 }
 
-void vsir_program_trace(const struct vsir_program *program)
+void vsir_program_trace(struct vsir_program *program)
 {
     const unsigned int flags = VSIR_ASM_FLAG_DUMP_TYPES | VSIR_ASM_FLAG_DUMP_ALL_INDICES
             | VSIR_ASM_FLAG_DUMP_SIGNATURES | VSIR_ASM_FLAG_DUMP_DESCRIPTORS;
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index 2dd9c731010..49e1a529369 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -1301,13 +1301,13 @@ static void shader_sm1_read_instruction(struct vkd3d_shader_sm1_parser *sm1, str
     else if (ins->opcode == VSIR_OP_DEFB)
     {
         shader_sm1_read_dst_param(sm1, &p, dst_param);
-        shader_sm1_read_immconst(sm1, &p, &src_params[0], VSIR_DIMENSION_SCALAR, VKD3D_DATA_UINT);
+        shader_sm1_read_immconst(sm1, &p, &src_params[0], VSIR_DIMENSION_SCALAR, VSIR_DATA_U32);
         shader_sm1_scan_register(sm1, &dst_param->reg, dst_param->write_mask, true);
     }
     else if (ins->opcode == VSIR_OP_DEFI)
     {
         shader_sm1_read_dst_param(sm1, &p, dst_param);
-        shader_sm1_read_immconst(sm1, &p, &src_params[0], VSIR_DIMENSION_VEC4, VKD3D_DATA_INT);
+        shader_sm1_read_immconst(sm1, &p, &src_params[0], VSIR_DIMENSION_VEC4, VSIR_DATA_I32);
         shader_sm1_scan_register(sm1, &dst_param->reg, dst_param->write_mask, true);
     }
     else if (ins->opcode == VSIR_OP_TEXKILL)
@@ -1472,7 +1472,6 @@ static uint32_t get_external_constant_count(struct vkd3d_shader_sm1_parser *sm1,
 int d3dbc_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t config_flags,
         struct vkd3d_shader_message_context *message_context, struct vsir_program *program)
 {
-    struct vkd3d_shader_instruction_array *instructions;
     struct vkd3d_shader_sm1_parser sm1 = {0};
     struct vkd3d_shader_instruction *ins;
     unsigned int i;
@@ -1484,17 +1483,14 @@ int d3dbc_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t c
         return ret;
     }
 
-    instructions = &program->instructions;
     while (!shader_sm1_is_end(&sm1))
     {
-        if (!shader_instruction_array_reserve(instructions, instructions->count + 1))
+        if (!(ins = vsir_program_append(program)))
         {
-            ERR("Failed to allocate instructions.\n");
             vkd3d_shader_parser_error(&sm1.p, VKD3D_SHADER_ERROR_D3DBC_OUT_OF_MEMORY, "Out of memory.");
             vsir_program_cleanup(program);
             return VKD3D_ERROR_OUT_OF_MEMORY;
         }
-        ins = &instructions->elements[instructions->count];
         shader_sm1_read_instruction(&sm1, ins);
 
         if (ins->opcode == VSIR_OP_INVALID)
@@ -1503,7 +1499,6 @@ int d3dbc_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t c
             vsir_program_cleanup(program);
             return VKD3D_ERROR_INVALID_SHADER;
         }
-        ++instructions->count;
     }
 
     for (i = 0; i < ARRAY_SIZE(program->flat_constant_count); ++i)
@@ -2128,11 +2123,13 @@ static void d3dbc_write_semantic_dcls(struct d3dbc_compiler *d3dbc)
 
 static void d3dbc_write_program_instructions(struct d3dbc_compiler *d3dbc)
 {
-    struct vsir_program *program = d3dbc->program;
-    unsigned int i;
+    struct vsir_program_iterator it = vsir_program_iterator(&d3dbc->program->instructions);
+    struct vkd3d_shader_instruction *ins;
 
-    for (i = 0; i < program->instructions.count; ++i)
-        d3dbc_write_vsir_instruction(d3dbc, &program->instructions.elements[i]);
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
+    {
+        d3dbc_write_vsir_instruction(d3dbc, ins);
+    }
 }
 
 int d3dbc_compile(struct vsir_program *program, uint64_t config_flags,
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index f8f0d2543bd..c3dd606f00f 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -2482,16 +2482,16 @@ static enum vsir_data_type vsir_data_type_from_dxil(const struct sm6_type *type)
             case 1:
                 return VKD3D_DATA_BOOL;
             case 8:
-                return VKD3D_DATA_UINT8;
+                return VSIR_DATA_U8;
             case 16:
-                return VKD3D_DATA_UINT16;
+                return VSIR_DATA_U16;
             case 32:
-                return VKD3D_DATA_UINT;
+                return VSIR_DATA_U32;
             case 64:
-                return VKD3D_DATA_UINT64;
+                return VSIR_DATA_U64;
             default:
                 FIXME("Unhandled width %u.\n", type->u.width);
-                return VKD3D_DATA_UINT;
+                return VSIR_DATA_U32;
         }
     }
     else if (type->class == TYPE_CLASS_FLOAT)
@@ -2511,7 +2511,7 @@ static enum vsir_data_type vsir_data_type_from_dxil(const struct sm6_type *type)
     }
 
     FIXME("Unhandled type %u.\n", type->class);
-    return VKD3D_DATA_UINT;
+    return VSIR_DATA_U32;
 }
 
 /* Based on the implementation in the OpenGL Mathematics library. */
@@ -2572,8 +2572,8 @@ static void register_convert_to_minimum_precision(struct vkd3d_shader_register *
             }
             break;
 
-        case VKD3D_DATA_UINT16:
-            reg->data_type = VKD3D_DATA_UINT;
+        case VSIR_DATA_U16:
+            reg->data_type = VSIR_DATA_U32;
             reg->precision = VKD3D_SHADER_REGISTER_PRECISION_MIN_UINT_16;
             if (reg->type == VKD3DSPR_IMMCONST)
             {
@@ -2668,7 +2668,7 @@ static void sm6_parser_init_ssa_value(struct sm6_parser *sm6, struct sm6_value *
 
 static void register_make_constant_uint(struct vkd3d_shader_register *reg, unsigned int value)
 {
-    vsir_register_init(reg, VKD3DSPR_IMMCONST, VKD3D_DATA_UINT, 0);
+    vsir_register_init(reg, VKD3DSPR_IMMCONST, VSIR_DATA_U32, 0);
     reg->u.immconst_u32[0] = value;
 }
 
@@ -2815,7 +2815,7 @@ static bool instruction_dst_param_init_uint_temp_vector(struct vkd3d_shader_inst
     if (!(param = instruction_dst_params_alloc(ins, 1, sm6)))
         return false;
 
-    vsir_dst_param_init(param, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+    vsir_dst_param_init(param, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
     param->write_mask = VKD3DSP_WRITEMASK_ALL;
     param->reg.idx[0].offset = 0;
     param->reg.dimension = VSIR_DIMENSION_VEC4;
@@ -3254,20 +3254,20 @@ static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, co
             icb->data_type = VSIR_DATA_F32;
             break;
 
-        case VKD3D_DATA_UINT16:
+        case VSIR_DATA_U16:
             for (i = 0; i < count; ++i)
                 icb->data[i] = (int16_t)operands[i];
-            icb->data_type = VKD3D_DATA_UINT;
+            icb->data_type = VSIR_DATA_U32;
             break;
 
         case VSIR_DATA_F32:
-        case VKD3D_DATA_UINT:
+        case VSIR_DATA_U32:
             for (i = 0; i < count; ++i)
                 icb->data[i] = operands[i];
             break;
 
         case VSIR_DATA_F64:
-        case VKD3D_DATA_UINT64:
+        case VSIR_DATA_U64:
             data64 = (uint64_t *)icb->data;
             for (i = 0; i < count; ++i)
                 data64[i] = operands[i];
@@ -4104,6 +4104,7 @@ static enum vkd3d_shader_register_type register_type_from_dxil_semantic_kind(
         case VKD3D_SHADER_SV_SAMPLE_INDEX:
             return VKD3DSPR_NULL;
         case VKD3D_SHADER_SV_COVERAGE:
+            *dimension = is_input ? VSIR_DIMENSION_VEC4 : VSIR_DIMENSION_SCALAR;
             return is_input ? VKD3DSPR_COVERAGE : VKD3DSPR_SAMPLEMASK;
         case VKD3D_SHADER_SV_DEPTH:
             *dimension = VSIR_DIMENSION_SCALAR;
@@ -5223,7 +5224,7 @@ static void sm6_parser_emit_dx_input_register_mov(struct sm6_parser *sm6, struct
 static void sm6_parser_emit_dx_coverage(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_COVERAGE, VKD3D_DATA_UINT, false);
+    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_COVERAGE, VSIR_DATA_U32, false);
 }
 
 static const struct sm6_descriptor_info *sm6_parser_get_descriptor(struct sm6_parser *sm6,
@@ -5300,8 +5301,7 @@ static void sm6_parser_emit_dx_stream(struct sm6_parser *sm6, enum dx_intrinsic_
                 "Output stream index %u is invalid.", i);
     }
 
-    /* VKD3D_DATA_UNUSED would be more reasonable, but TPF uses data type 0 here. */
-    register_init_with_id(&src_param->reg, VKD3DSPR_STREAM, 0, i);
+    register_init_with_id(&src_param->reg, VKD3DSPR_STREAM, VKD3D_DATA_UNUSED, i);
     src_param_init(src_param);
 
     if (op == DX_EMIT_THEN_CUT_STREAM)
@@ -5482,11 +5482,11 @@ static void sm6_parser_emit_dx_compute_builtin(struct sm6_parser *sm6, enum dx_i
             vkd3d_unreachable();
     }
 
-    sm6_parser_dcl_register_builtin(sm6, VSIR_OP_DCL_INPUT, reg_type, VKD3D_DATA_UINT, component_count);
+    sm6_parser_dcl_register_builtin(sm6, VSIR_OP_DCL_INPUT, reg_type, VSIR_DATA_U32, component_count);
     vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_MOV);
     if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
         return;
-    vsir_register_init(&src_param->reg, reg_type, VKD3D_DATA_UINT, 0);
+    vsir_register_init(&src_param->reg, reg_type, VSIR_DATA_U32, 0);
     src_param->reg.dimension = VSIR_DIMENSION_VEC4;
     if (component_count > 1)
         component_idx = sm6_value_get_constant_uint(operands[0], sm6);
@@ -5721,13 +5721,13 @@ static void sm6_parser_emit_dx_make_double(struct sm6_parser *sm6, enum dx_intri
 static void sm6_parser_emit_dx_output_control_point_id(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_OUTPOINTID, VKD3D_DATA_UINT, true);
+    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_OUTPOINTID, VSIR_DATA_U32, true);
 }
 
 static void sm6_parser_emit_dx_primitive_id(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_PRIMID, VKD3D_DATA_UINT, true);
+    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_PRIMID, VSIR_DATA_U32, true);
 }
 
 static enum vkd3d_shader_opcode dx_map_quad_op(enum dxil_quad_op_kind op)
@@ -5875,7 +5875,7 @@ static void sm6_parser_emit_dx_raw_buffer_store(struct sm6_parser *sm6, enum dx_
     if (!(src_params = instruction_src_params_alloc(ins, operand_count, sm6)))
         return;
     src_params_init_from_operands(src_params, &operands[1], operand_count - 1, sm6);
-    data.data_type = VKD3D_DATA_UINT;
+    data.data_type = VSIR_DATA_U32;
     src_param_init_vector_from_reg(&src_params[operand_count - 1], &data);
 
     dst_param = instruction_dst_params_alloc(ins, 1, sm6);
@@ -6543,7 +6543,7 @@ static void sm6_parser_emit_dx_wave_builtin(struct sm6_parser *sm6, enum dx_intr
             vkd3d_unreachable();
     }
 
-    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, type, VKD3D_DATA_UINT, true);
+    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, type, VSIR_DATA_U32, true);
 }
 
 struct sm6_dx_opcode_info
@@ -8441,9 +8441,9 @@ static void sm6_block_emit_terminator(const struct sm6_block *block, struct sm6_
                     continue;
                 }
 
-                if (src_params[0].reg.data_type == VKD3D_DATA_UINT64)
+                if (src_params[0].reg.data_type == VSIR_DATA_U64)
                 {
-                    vsir_src_param_init(&src_params[count], VKD3DSPR_IMMCONST64, VKD3D_DATA_UINT64, 0);
+                    vsir_src_param_init(&src_params[count], VKD3DSPR_IMMCONST64, VSIR_DATA_U64, 0);
                     src_params[count++].reg.u.immconst_u64[0] = switch_case->value;
                 }
                 else
@@ -8454,7 +8454,7 @@ static void sm6_block_emit_terminator(const struct sm6_block *block, struct sm6_
                         vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
                                 "Truncating 64-bit switch case value %"PRIx64" to 32 bits.", switch_case->value);
                     }
-                    vsir_src_param_init(&src_params[count], VKD3DSPR_IMMCONST, VKD3D_DATA_UINT, 0);
+                    vsir_src_param_init(&src_params[count], VKD3DSPR_IMMCONST, VSIR_DATA_U32, 0);
                     src_params[count++].reg.u.immconst_u32[0] = switch_case->value;
                 }
                 vsir_src_param_init_label(&src_params[count++], case_block->id);
@@ -9043,10 +9043,10 @@ static const enum vsir_data_type data_type_table[] =
 {
     [COMPONENT_TYPE_INVALID]     = VKD3D_DATA_UNUSED,
     [COMPONENT_TYPE_I1]          = VKD3D_DATA_UNUSED,
-    [COMPONENT_TYPE_I16]         = VKD3D_DATA_INT,
-    [COMPONENT_TYPE_U16]         = VKD3D_DATA_UINT,
-    [COMPONENT_TYPE_I32]         = VKD3D_DATA_INT,
-    [COMPONENT_TYPE_U32]         = VKD3D_DATA_UINT,
+    [COMPONENT_TYPE_I16]         = VSIR_DATA_I32,
+    [COMPONENT_TYPE_U16]         = VSIR_DATA_U32,
+    [COMPONENT_TYPE_I32]         = VSIR_DATA_I32,
+    [COMPONENT_TYPE_U32]         = VSIR_DATA_U32,
     [COMPONENT_TYPE_I64]         = VKD3D_DATA_UNUSED,
     [COMPONENT_TYPE_U64]         = VKD3D_DATA_UNUSED,
     [COMPONENT_TYPE_F16]         = VSIR_DATA_F32,
diff --git a/libs/vkd3d/libs/vkd3d-shader/glsl.c b/libs/vkd3d/libs/vkd3d-shader/glsl.c
index bf407f0fc9c..dc68e1792d9 100644
--- a/libs/vkd3d/libs/vkd3d-shader/glsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/glsl.c
@@ -345,10 +345,10 @@ static void shader_glsl_print_bitcast(struct vkd3d_string_buffer *dst, struct vk
     {
         switch (dst_data_type)
         {
-            case VKD3D_DATA_INT:
+            case VSIR_DATA_I32:
                 vkd3d_string_buffer_printf(dst, "floatBitsToInt(%s)", src);
                 return;
-            case VKD3D_DATA_UINT:
+            case VSIR_DATA_U32:
                 vkd3d_string_buffer_printf(dst, "floatBitsToUint(%s)", src);
                 return;
             default:
@@ -356,14 +356,14 @@ static void shader_glsl_print_bitcast(struct vkd3d_string_buffer *dst, struct vk
         }
     }
 
-    if (src_data_type == VKD3D_DATA_UINT)
+    if (src_data_type == VSIR_DATA_U32)
     {
         switch (dst_data_type)
         {
             case VSIR_DATA_F32:
                 vkd3d_string_buffer_printf(dst, "uintBitsToFloat(%s)", src);
                 return;
-            case VKD3D_DATA_INT:
+            case VSIR_DATA_I32:
                 if (size == 1)
                     vkd3d_string_buffer_printf(dst, "int(%s)", src);
                 else
@@ -395,7 +395,7 @@ static void shader_glsl_print_src(struct vkd3d_string_buffer *buffer, struct vkd
                 "Internal compiler error: Unhandled 'non-uniform' modifier.");
 
     if (reg->type == VKD3DSPR_IMMCONST || reg->type == VKD3DSPR_THREADID)
-        src_data_type = VKD3D_DATA_UINT;
+        src_data_type = VSIR_DATA_U32;
     else
         src_data_type = VSIR_DATA_F32;
 
@@ -522,10 +522,10 @@ static void VKD3D_PRINTF_FUNC(4, 0) shader_glsl_vprint_assignment(struct vkd3d_g
         case VSIR_DATA_F32:
             close = false;
             break;
-        case VKD3D_DATA_INT:
+        case VSIR_DATA_I32:
             vkd3d_string_buffer_printf(buffer, "intBitsToFloat(");
             break;
-        case VKD3D_DATA_UINT:
+        case VSIR_DATA_U32:
             vkd3d_string_buffer_printf(buffer, "uintBitsToFloat(");
             break;
     }
@@ -1164,12 +1164,12 @@ static void shader_glsl_store_uav_typed(struct vkd3d_glsl_generator *gen, const
     {
         switch (data_type)
         {
-            case VKD3D_DATA_UINT:
-                vkd3d_string_buffer_printf(image_data, "uvec4(");
-                break;
-            case VKD3D_DATA_INT:
+            case VSIR_DATA_I32:
                 vkd3d_string_buffer_printf(image_data, "ivec4(");
                 break;
+            case VSIR_DATA_U32:
+                vkd3d_string_buffer_printf(image_data, "uvec4(");
+                break;
             default:
                 vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
                         "Internal compiler error: Unhandled data type %#x.", data_type);
@@ -1766,14 +1766,14 @@ static void shader_glsl_generate_uav_declaration(struct vkd3d_glsl_generator *ge
 
     switch (uav->resource_data_type)
     {
-        case VKD3D_DATA_UINT:
-            image_type_prefix = "u";
-            read_format = "r32ui";
-            break;
-        case VKD3D_DATA_INT:
+        case VSIR_DATA_I32:
             image_type_prefix = "i";
             read_format = "r32i";
             break;
+        case VSIR_DATA_U32:
+            image_type_prefix = "u";
+            read_format = "r32ui";
+            break;
         default:
             vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
                     "Internal compiler error: Unhandled data type %#x for UAV %u.",
@@ -1995,17 +1995,17 @@ static void shader_glsl_generate_sampler_declaration(struct vkd3d_glsl_generator
 
     switch (srv->resource_data_type)
     {
-        case VKD3D_DATA_UINT:
-            sampler_type_prefix = "u";
-            break;
-        case VKD3D_DATA_INT:
-            sampler_type_prefix = "i";
-            break;
         case VSIR_DATA_F32:
         case VKD3D_DATA_UNORM:
         case VKD3D_DATA_SNORM:
             sampler_type_prefix = "";
             break;
+        case VSIR_DATA_I32:
+            sampler_type_prefix = "i";
+            break;
+        case VSIR_DATA_U32:
+            sampler_type_prefix = "u";
+            break;
         default:
             vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
                     "Internal compiler error: Unhandled data type %#x for combined resource/sampler "
@@ -2325,9 +2325,9 @@ static void shader_glsl_generate_declarations(struct vkd3d_glsl_generator *gen)
 
 static int vkd3d_glsl_generator_generate(struct vkd3d_glsl_generator *gen, struct vkd3d_shader_code *out)
 {
-    const struct vkd3d_shader_instruction_array *instructions = &gen->program->instructions;
     struct vkd3d_string_buffer *buffer = gen->buffer;
-    unsigned int i;
+    struct vkd3d_shader_instruction *ins;
+    struct vsir_program_iterator it;
     void *code;
 
     MESSAGE("Generating a GLSL shader. This is unsupported; you get to keep all the pieces if it breaks.\n");
@@ -2342,9 +2342,11 @@ static int vkd3d_glsl_generator_generate(struct vkd3d_glsl_generator *gen, struc
 
     ++gen->indent;
     shader_glsl_shader_prologue(gen);
-    for (i = 0; i < instructions->count; ++i)
+
+    it = vsir_program_iterator(&gen->program->instructions);
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
     {
-        vkd3d_glsl_handle_instruction(gen, &instructions->elements[i]);
+        vkd3d_glsl_handle_instruction(gen, ins);
     }
 
     vkd3d_string_buffer_printf(buffer, "}\n");
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index 86198ce548f..7707412bf57 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -8245,11 +8245,11 @@ static enum vsir_data_type vsir_data_type_from_hlsl_type(struct hlsl_ctx *ctx, c
             case HLSL_TYPE_HALF:
                 return VSIR_DATA_F16;
             case HLSL_TYPE_INT:
-                return VKD3D_DATA_INT;
+                return VSIR_DATA_I32;
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_BOOL:
             case HLSL_TYPE_MIN16UINT:
-                return VKD3D_DATA_UINT;
+                return VSIR_DATA_U32;
         }
     }
 
@@ -10267,12 +10267,12 @@ static void sm4_generate_vsir_cast_from_bool(struct hlsl_ctx *ctx, struct vsir_p
 
     dst_param = &ins->dst[0];
     vsir_dst_from_hlsl_node(dst_param, ctx, instr);
-    ins->dst[0].reg.data_type = VKD3D_DATA_UINT;
+    ins->dst[0].reg.data_type = VSIR_DATA_U32;
 
     vsir_src_from_hlsl_node(&ins->src[0], ctx, operand, dst_param->write_mask);
 
     value.u[0].u = bits;
-    vsir_src_from_hlsl_constant_value(&ins->src[1], ctx, &value, VKD3D_DATA_UINT, 1, 0);
+    vsir_src_from_hlsl_constant_value(&ins->src[1], ctx, &value, VSIR_DATA_U32, 1, 0);
 }
 
 static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
@@ -10969,10 +10969,10 @@ static bool sm4_generate_vsir_instr_load(struct hlsl_ctx *ctx, struct vsir_progr
 
         memset(&value, 0xff, sizeof(value));
         vsir_src_from_hlsl_constant_value(&ins->src[1], ctx, &value,
-                VKD3D_DATA_UINT, type->e.numeric.dimx, dst_param->write_mask);
+                VSIR_DATA_U32, type->e.numeric.dimx, dst_param->write_mask);
         memset(&value, 0x00, sizeof(value));
         vsir_src_from_hlsl_constant_value(&ins->src[2], ctx, &value,
-                VKD3D_DATA_UINT, type->e.numeric.dimx, dst_param->write_mask);
+                VSIR_DATA_U32, type->e.numeric.dimx, dst_param->write_mask);
     }
     else
     {
@@ -11163,7 +11163,7 @@ static bool sm4_generate_vsir_instr_ld(struct hlsl_ctx *ctx,
     {
         if (sample_index->type == HLSL_IR_CONSTANT)
             vsir_src_from_hlsl_constant_value(&ins->src[2], ctx,
-                    &hlsl_ir_constant(sample_index)->value, VKD3D_DATA_INT, 1, 0);
+                    &hlsl_ir_constant(sample_index)->value, VSIR_DATA_I32, 1, 0);
         else if (version->major == 4 && version->minor == 0)
             hlsl_error(ctx, &sample_index->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE, "Expected literal sample index.");
         else
@@ -11646,7 +11646,7 @@ static void sm4_generate_vsir_instr_switch(struct hlsl_ctx *ctx,
 
             if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VSIR_OP_CASE, 0, 1)))
                 return;
-            vsir_src_from_hlsl_constant_value(&ins->src[0], ctx, &value, VKD3D_DATA_UINT, 1, VKD3DSP_WRITEMASK_ALL);
+            vsir_src_from_hlsl_constant_value(&ins->src[0], ctx, &value, VSIR_DATA_U32, 1, VKD3DSP_WRITEMASK_ALL);
         }
 
         sm4_generate_vsir_block(ctx, &cas->body, program);
@@ -12185,12 +12185,12 @@ static enum vsir_data_type sm4_generate_vsir_get_format_type(const struct hlsl_t
             return VSIR_DATA_F32;
 
         case HLSL_TYPE_INT:
-            return VKD3D_DATA_INT;
+            return VSIR_DATA_I32;
 
         case HLSL_TYPE_BOOL:
         case HLSL_TYPE_MIN16UINT:
         case HLSL_TYPE_UINT:
-            return VKD3D_DATA_UINT;
+            return VSIR_DATA_U32;
     }
 
     vkd3d_unreachable();
@@ -12320,7 +12320,7 @@ static void sm4_generate_vsir_add_dcl_stream(struct hlsl_ctx *ctx,
         return;
     }
 
-    vsir_src_param_init(&ins->src[0], VKD3DSPR_STREAM, VKD3D_DATA_OPAQUE, 1);
+    vsir_src_param_init(&ins->src[0], VKD3DSPR_STREAM, VKD3D_DATA_UNUSED, 1);
     ins->src[0].reg.dimension = VSIR_DIMENSION_NONE;
     ins->src[0].reg.idx[0].offset = var->regs[HLSL_REGSET_STREAM_OUTPUTS].index;
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index 18cda0269af..c322d9dde01 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -590,7 +590,7 @@ void vsir_src_param_init(struct vkd3d_shader_src_param *param, enum vkd3d_shader
 
 static void src_param_init_const_uint(struct vkd3d_shader_src_param *src, uint32_t value)
 {
-    vsir_src_param_init(src, VKD3DSPR_IMMCONST, VKD3D_DATA_UINT, 0);
+    vsir_src_param_init(src, VKD3DSPR_IMMCONST, VSIR_DATA_U32, 0);
     src->reg.u.immconst_u32[0] = value;
 }
 
@@ -696,7 +696,7 @@ static void src_param_init_temp_float4(struct vkd3d_shader_src_param *src, unsig
 
 static void src_param_init_temp_uint(struct vkd3d_shader_src_param *src, unsigned int idx)
 {
-    vsir_src_param_init(src, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+    vsir_src_param_init(src, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
     src->reg.idx[0].offset = idx;
 }
 
@@ -773,7 +773,7 @@ static void dst_param_init_temp_float4(struct vkd3d_shader_dst_param *dst, unsig
 
 static void dst_param_init_temp_uint(struct vkd3d_shader_dst_param *dst, unsigned int idx)
 {
-    vsir_dst_param_init(dst, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+    vsir_dst_param_init(dst, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
     dst->reg.idx[0].offset = idx;
 }
 
@@ -913,7 +913,7 @@ static enum vkd3d_result vsir_program_normalize_addr(struct vsir_program *progra
                 tmp_idx = program->temp_count++;
 
             ins->opcode = VSIR_OP_FTOU;
-            vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+            vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
             ins->dst[0].reg.idx[0].offset = tmp_idx;
             ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
         }
@@ -935,7 +935,7 @@ static enum vkd3d_result vsir_program_normalize_addr(struct vsir_program *progra
             if (!vsir_instruction_init_with_params(program, ins2, &ins->location, VSIR_OP_FTOU, 1, 1))
                 return VKD3D_ERROR_OUT_OF_MEMORY;
 
-            vsir_register_init(&ins2->dst[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+            vsir_register_init(&ins2->dst[0].reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
             ins2->dst[0].reg.idx[0].offset = tmp_idx;
             ins2->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
             ins2->dst[0].write_mask = ins->dst[0].write_mask;
@@ -959,7 +959,7 @@ static enum vkd3d_result vsir_program_normalize_addr(struct vsir_program *progra
                     if (tmp_idx == ~0u)
                         tmp_idx = program->temp_count++;
 
-                    vsir_register_init(&rel->reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+                    vsir_register_init(&rel->reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
                     rel->reg.idx[0].offset = tmp_idx;
                     rel->reg.dimension = VSIR_DIMENSION_VEC4;
                 }
@@ -998,7 +998,7 @@ static enum vkd3d_result vsir_program_lower_ifc(struct vsir_program *program,
     if (!vsir_instruction_init_with_params(program, ins, &ifc->location, opcode, 1, 2))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+    vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
     ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
     ins->dst[0].reg.idx[0].offset = *tmp_idx;
     ins->dst[0].write_mask = VKD3DSP_WRITEMASK_0;
@@ -1012,7 +1012,7 @@ static enum vkd3d_result vsir_program_lower_ifc(struct vsir_program *program,
         return VKD3D_ERROR_OUT_OF_MEMORY;
     ins->flags = VKD3D_SHADER_CONDITIONAL_OP_NZ;
 
-    vsir_register_init(&ins->src[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+    vsir_register_init(&ins->src[0].reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
     ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
     ins->src[0].reg.idx[0].offset = *tmp_idx;
     ins->src[0].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
@@ -1043,7 +1043,7 @@ static enum vkd3d_result vsir_program_lower_texkill(struct vsir_program *program
     if (!vsir_instruction_init_with_params(program, ins, &texkill->location, VSIR_OP_LTO, 1, 2))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+    vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
     ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
     ins->dst[0].reg.idx[0].offset = *tmp_idx;
     ins->dst[0].write_mask = VKD3DSP_WRITEMASK_ALL;
@@ -1067,16 +1067,16 @@ static enum vkd3d_result vsir_program_lower_texkill(struct vsir_program *program
         if (!(vsir_instruction_init_with_params(program, ins, &texkill->location, VSIR_OP_OR, 1, 2)))
             return VKD3D_ERROR_OUT_OF_MEMORY;
 
-        vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+        vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
         ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
         ins->dst[0].reg.idx[0].offset = *tmp_idx;
         ins->dst[0].write_mask = VKD3DSP_WRITEMASK_0;
 
-        vsir_register_init(&ins->src[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+        vsir_register_init(&ins->src[0].reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
         ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
         ins->src[0].reg.idx[0].offset = *tmp_idx;
         ins->src[0].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
-        vsir_register_init(&ins->src[1].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+        vsir_register_init(&ins->src[1].reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
         ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
         ins->src[1].reg.idx[0].offset = *tmp_idx;
         ins->src[1].swizzle = vkd3d_shader_create_swizzle(j, j, j, j);
@@ -1089,7 +1089,7 @@ static enum vkd3d_result vsir_program_lower_texkill(struct vsir_program *program
         return VKD3D_ERROR_OUT_OF_MEMORY;
     ins->flags = VKD3D_SHADER_CONDITIONAL_OP_NZ;
 
-    vsir_register_init(&ins->src[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+    vsir_register_init(&ins->src[0].reg, VKD3DSPR_TEMP, VSIR_DATA_U32, 1);
     ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
     ins->src[0].reg.idx[0].offset = *tmp_idx;
     ins->src[0].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
@@ -2301,7 +2301,7 @@ struct vkd3d_shader_src_param *vsir_program_create_outpointid_param(struct vsir_
     if (!(rel_addr = shader_src_param_allocator_get(&instructions->src_params, 1)))
         return NULL;
 
-    vsir_register_init(&rel_addr->reg, VKD3DSPR_OUTPOINTID, VKD3D_DATA_UINT, 0);
+    vsir_register_init(&rel_addr->reg, VKD3DSPR_OUTPOINTID, VSIR_DATA_U32, 0);
     rel_addr->swizzle = 0;
     rel_addr->modifiers = 0;
 
@@ -3862,7 +3862,7 @@ static enum vkd3d_result cf_flattener_iterate_instruction_array(struct cf_flatte
                 for (j = 0; j < cf_info->u.switch_.cases_count; ++j)
                 {
                     unsigned int index = j * 2 + 3;
-                    vsir_src_param_init(&src_params[index], VKD3DSPR_IMMCONST, VKD3D_DATA_UINT, 0);
+                    vsir_src_param_init(&src_params[index], VKD3DSPR_IMMCONST, VSIR_DATA_U32, 0);
                     src_params[index].reg.u.immconst_u32[0] = cf_info->u.switch_.cases[j].value;
                     vsir_src_param_init_label(&src_params[index + 1], cf_info->u.switch_.cases[j].block_id);
                 }
@@ -6839,7 +6839,7 @@ static enum vkd3d_result insert_alpha_test_before_ret(struct vsir_program *progr
             vsir_instruction_init_with_params(program, ins, &loc, opcodes[compare_func].uint_opcode, 1, 2);
             src_param_init_temp_uint(&ins->src[opcodes[compare_func].swap ? 1 : 0], colour_temp);
             src_param_init_parameter(&ins->src[opcodes[compare_func].swap ? 0 : 1],
-                    VKD3D_SHADER_PARAMETER_NAME_ALPHA_TEST_REF, VKD3D_DATA_UINT);
+                    VKD3D_SHADER_PARAMETER_NAME_ALPHA_TEST_REF, VSIR_DATA_U32);
             break;
 
         case VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32_VEC4:
@@ -9548,12 +9548,18 @@ static void vsir_validate_register(struct validation_context *ctx,
     register_validation_data[] =
     {
         [VKD3DSPR_DEPTHOUT]         = {true, 0, VSIR_DIMENSION_SCALAR},
+        [VKD3DSPR_PRIMID]           = {true, 0, VSIR_DIMENSION_SCALAR},
+        [VKD3DSPR_OUTPOINTID]       = {true, 0, VSIR_DIMENSION_SCALAR},
+        [VKD3DSPR_THREADID]         = {true, 0, VSIR_DIMENSION_VEC4},
         [VKD3DSPR_THREADGROUPID]    = {true, 0, VSIR_DIMENSION_VEC4},
         [VKD3DSPR_LOCALTHREADID]    = {true, 0, VSIR_DIMENSION_VEC4},
         [VKD3DSPR_LOCALTHREADINDEX] = {true, 0, VSIR_DIMENSION_VEC4},
         [VKD3DSPR_COVERAGE]         = {true, 0, VSIR_DIMENSION_VEC4},
+        [VKD3DSPR_SAMPLEMASK]       = {true, 0, VSIR_DIMENSION_SCALAR},
+        [VKD3DSPR_GSINSTID]         = {true, 0, VSIR_DIMENSION_SCALAR},
         [VKD3DSPR_DEPTHOUTGE]       = {true, 0, VSIR_DIMENSION_SCALAR},
         [VKD3DSPR_DEPTHOUTLE]       = {true, 0, VSIR_DIMENSION_SCALAR},
+        [VKD3DSPR_OUTSTENCILREF]    = {true, 0, VSIR_DIMENSION_SCALAR},
     };
 
     const struct register_validation_data *validation_data;
@@ -9642,10 +9648,6 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_constbuffer_register(ctx, reg);
             break;
 
-        case VKD3DSPR_PRIMID:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
         case VKD3DSPR_NULL:
             vsir_validate_register_without_indices(ctx, reg);
             break;
@@ -9662,10 +9664,6 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_uav_register(ctx, reg);
             break;
 
-        case VKD3DSPR_OUTPOINTID:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
         case VKD3DSPR_FORKINSTID:
             vsir_validate_register_without_indices(ctx, reg);
             break;
@@ -9690,22 +9688,6 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_register_without_indices(ctx, reg);
             break;
 
-        case VKD3DSPR_THREADID:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
-        case VKD3DSPR_SAMPLEMASK:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
-        case VKD3DSPR_GSINSTID:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
-        case VKD3DSPR_OUTSTENCILREF:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
         case VKD3DSPR_SSA:
             vsir_validate_ssa_register(ctx, reg);
             break;
@@ -9900,11 +9882,11 @@ static void vsir_validate_io_src_param(struct validation_context *ctx,
 #define F32_BIT (1u << VSIR_DATA_F32)
 #define F16_BIT (1u << VSIR_DATA_F16)
 
-#define I32_BIT (1u << VKD3D_DATA_INT)
+#define I32_BIT (1u << VSIR_DATA_I32)
 
-#define U64_BIT (1u << VKD3D_DATA_UINT64)
-#define U32_BIT (1u << VKD3D_DATA_UINT)
-#define U16_BIT (1u << VKD3D_DATA_UINT16)
+#define U64_BIT (1u << VSIR_DATA_U64)
+#define U32_BIT (1u << VSIR_DATA_U32)
+#define U16_BIT (1u << VSIR_DATA_U16)
 
 static void vsir_validate_src_param(struct validation_context *ctx,
         const struct vkd3d_shader_src_param *src)
@@ -10658,9 +10640,9 @@ static void vsir_validate_integer_elementwise_operation(struct validation_contex
 {
     static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_INT] = true,
-        [VKD3D_DATA_UINT] = true,
-        [VKD3D_DATA_UINT64] = true,
+        [VSIR_DATA_I32] = true,
+        [VSIR_DATA_U32] = true,
+        [VSIR_DATA_U64] = true,
     };
 
     vsir_validate_elementwise_operation(ctx, instruction, types);
@@ -10671,10 +10653,10 @@ static void vsir_validate_logic_elementwise_operation(struct validation_context
 {
     static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_INT] = true,
-        [VKD3D_DATA_UINT] = true,
-        [VKD3D_DATA_UINT64] = true,
         [VKD3D_DATA_BOOL] = true,
+        [VSIR_DATA_I32] = true,
+        [VSIR_DATA_U32] = true,
+        [VSIR_DATA_U64] = true,
     };
 
     vsir_validate_elementwise_operation(ctx, instruction, types);
@@ -10691,7 +10673,7 @@ static void vsir_validate_comparison_operation(struct validation_context *ctx,
 
     dst_data_type = instruction->dst[0].reg.data_type;
 
-    if (dst_data_type != VKD3D_DATA_UINT && dst_data_type != VKD3D_DATA_BOOL)
+    if (dst_data_type != VSIR_DATA_U32 && dst_data_type != VKD3D_DATA_BOOL)
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE,
                 "Invalid data type %#x for result of comparison operation \"%s\" (%#x).",
                 dst_data_type, vsir_opcode_get_name(instruction->opcode, "<unknown>"), instruction->opcode);
@@ -10748,9 +10730,9 @@ static void vsir_validate_integer_comparison_operation(struct validation_context
 {
     static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_INT] = true,
-        [VKD3D_DATA_UINT] = true,
-        [VKD3D_DATA_UINT64] = true,
+        [VSIR_DATA_I32] = true,
+        [VSIR_DATA_U32] = true,
+        [VSIR_DATA_U64] = true,
     };
 
     vsir_validate_comparison_operation(ctx, instruction, types);
@@ -11305,8 +11287,8 @@ static void vsir_validate_ftoi(struct validation_context *ctx, const struct vkd3
     };
     static const bool dst_types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_INT] = true,
-        [VKD3D_DATA_UINT] = true,
+        [VSIR_DATA_I32] = true,
+        [VSIR_DATA_U32] = true,
     };
 
     vsir_validate_cast_operation(ctx, instruction, src_types, dst_types);
@@ -11322,7 +11304,7 @@ static void vsir_validate_ftou(struct validation_context *ctx, const struct vkd3
     };
     static const bool dst_types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_UINT] = true,
+        [VSIR_DATA_U32] = true,
     };
 
     vsir_validate_cast_operation(ctx, instruction, src_types, dst_types);
@@ -11344,10 +11326,10 @@ static void vsir_validate_itof(struct validation_context *ctx, const struct vkd3
 {
     static const bool src_types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_INT] = true,
-        [VKD3D_DATA_UINT] = true,
-        [VKD3D_DATA_UINT64] = true,
         [VKD3D_DATA_BOOL] = true,
+        [VSIR_DATA_I32] = true,
+        [VSIR_DATA_U32] = true,
+        [VSIR_DATA_U64] = true,
     };
     static const bool dst_types[VSIR_DATA_TYPE_COUNT] =
     {
@@ -11363,10 +11345,10 @@ static void vsir_validate_itoi(struct validation_context *ctx, const struct vkd3
 {
     static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_INT] = true,
-        [VKD3D_DATA_UINT] = true,
-        [VKD3D_DATA_UINT64] = true,
         [VKD3D_DATA_BOOL] = true,
+        [VSIR_DATA_I32] = true,
+        [VSIR_DATA_U32] = true,
+        [VSIR_DATA_U64] = true,
     };
 
     vsir_validate_cast_operation(ctx, instruction, types, types);
@@ -11626,10 +11608,18 @@ static const struct vsir_validator_instruction_desc vsir_validator_instructions[
     [VSIR_OP_MAX] =                              {1,   2, vsir_validate_float_elementwise_operation},
     [VSIR_OP_MIN] =                              {1,   2, vsir_validate_float_elementwise_operation},
     [VSIR_OP_MUL] =                              {1,   2, vsir_validate_float_elementwise_operation},
+    [VSIR_OP_NEO] =                              {1,   2, vsir_validate_float_comparison_operation},
+    [VSIR_OP_NEU] =                              {1,   2, vsir_validate_float_comparison_operation},
     [VSIR_OP_NOP] =                              {0,   0, vsir_validate_nop},
+    [VSIR_OP_NOT] =                              {1,   1, vsir_validate_logic_elementwise_operation},
+    [VSIR_OP_OR] =                               {1,   2, vsir_validate_logic_elementwise_operation},
+    [VSIR_OP_ORD] =                              {1,   2, vsir_validate_float_comparison_operation},
     [VSIR_OP_PHI] =                              {1, ~0u, vsir_validate_phi},
+    [VSIR_OP_RCP] =                              {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_REP] =                              {0,   1, vsir_validate_rep},
     [VSIR_OP_RET] =                              {0,   0, vsir_validate_ret},
+    [VSIR_OP_ROUND_NE] =                         {1,   1, vsir_validate_float_elementwise_operation},
+    [VSIR_OP_ROUND_NI] =                         {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_SWITCH] =                           {0,   1, vsir_validate_switch},
     [VSIR_OP_SWITCH_MONOLITHIC] =                {0, ~0u, vsir_validate_switch_monolithic},
 };
diff --git a/libs/vkd3d/libs/vkd3d-shader/msl.c b/libs/vkd3d/libs/vkd3d-shader/msl.c
index 83cdf9feea0..ccfce0f4591 100644
--- a/libs/vkd3d/libs/vkd3d-shader/msl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/msl.c
@@ -142,10 +142,10 @@ static void msl_print_resource_datatype(struct msl_generator *gen,
         case VKD3D_DATA_SNORM:
             vkd3d_string_buffer_printf(buffer, "float");
             break;
-        case VKD3D_DATA_INT:
+        case VSIR_DATA_I32:
             vkd3d_string_buffer_printf(buffer, "int");
             break;
-        case VKD3D_DATA_UINT:
+        case VSIR_DATA_U32:
             vkd3d_string_buffer_printf(buffer, "uint");
             break;
         default:
@@ -165,10 +165,10 @@ static void msl_print_register_datatype(struct vkd3d_string_buffer *buffer,
         case VSIR_DATA_F32:
             vkd3d_string_buffer_printf(buffer, "f");
             break;
-        case VKD3D_DATA_INT:
+        case VSIR_DATA_I32:
             vkd3d_string_buffer_printf(buffer, "i");
             break;
-        case VKD3D_DATA_UINT:
+        case VSIR_DATA_U32:
             vkd3d_string_buffer_printf(buffer, "u");
             break;
         default:
@@ -537,7 +537,7 @@ static void msl_print_bitcast(struct vkd3d_string_buffer *dst, struct msl_genera
             break;
 
         case MSL_DATA_UINT:
-            write_cast = dst_data_type != VKD3D_DATA_UINT;
+            write_cast = dst_data_type != VSIR_DATA_U32;
             break;
 
         case MSL_DATA_UNION:
@@ -1012,19 +1012,19 @@ static void msl_ld(struct msl_generator *gen, const struct vkd3d_shader_instruct
     vkd3d_string_buffer_printf(read, "as_type<uint4>(");
     msl_print_srv_name(read, gen, srv_binding, resource_type_info, data_type, false);
     vkd3d_string_buffer_printf(read, ".read(");
-    msl_print_src_with_type(read, gen, &ins->src[0], coord_mask, VKD3D_DATA_UINT);
+    msl_print_src_with_type(read, gen, &ins->src[0], coord_mask, VSIR_DATA_U32);
     if (resource_type_info->array)
     {
         vkd3d_string_buffer_printf(read, ", ");
-        msl_print_src_with_type(read, gen, &ins->src[0], coord_mask + 1, VKD3D_DATA_UINT);
+        msl_print_src_with_type(read, gen, &ins->src[0], coord_mask + 1, VSIR_DATA_U32);
     }
     if (resource_type != VKD3D_SHADER_RESOURCE_BUFFER)
     {
         vkd3d_string_buffer_printf(read, ", ");
         if (ins->opcode != VSIR_OP_LD2DMS)
-            msl_print_src_with_type(read, gen, &ins->src[0], VKD3DSP_WRITEMASK_3, VKD3D_DATA_UINT);
+            msl_print_src_with_type(read, gen, &ins->src[0], VKD3DSP_WRITEMASK_3, VSIR_DATA_U32);
         else
-            msl_print_src_with_type(read, gen, &ins->src[2], VKD3DSP_WRITEMASK_0, VKD3D_DATA_UINT);
+            msl_print_src_with_type(read, gen, &ins->src[2], VKD3DSP_WRITEMASK_0, VSIR_DATA_U32);
     }
     vkd3d_string_buffer_printf(read, "))");
     msl_print_swizzle(read, ins->src[1].swizzle, ins->dst[0].write_mask);
@@ -1168,7 +1168,7 @@ static void msl_sample(struct msl_generator *gen, const struct vkd3d_shader_inst
     msl_dst_init(&dst, gen, ins, &ins->dst[0]);
     sample = vkd3d_string_buffer_get(&gen->string_buffers);
 
-    if (ins->dst[0].reg.data_type == VKD3D_DATA_UINT)
+    if (ins->dst[0].reg.data_type == VSIR_DATA_U32)
         vkd3d_string_buffer_printf(sample, "as_type<uint4>(");
     msl_print_srv_name(sample, gen, srv_binding, resource_type_info, data_type, compare);
     if (gather && compare)
@@ -1238,7 +1238,7 @@ static void msl_sample(struct msl_generator *gen, const struct vkd3d_shader_inst
         vkd3d_string_buffer_printf(sample, ", component::%c", "xyzw"[component_idx]);
     }
     vkd3d_string_buffer_printf(sample, ")");
-    if (ins->dst[0].reg.data_type == VKD3D_DATA_UINT)
+    if (ins->dst[0].reg.data_type == VSIR_DATA_U32)
         vkd3d_string_buffer_printf(sample, ")");
     if (!compare || gather)
         msl_print_swizzle(sample, resource->swizzle, ins->dst[0].write_mask);
@@ -1309,10 +1309,10 @@ static void msl_store_uav_typed(struct msl_generator *gen, const struct vkd3d_sh
     {
         switch (data_type)
         {
-            case VKD3D_DATA_UINT:
+            case VSIR_DATA_U32:
                 vkd3d_string_buffer_printf(image_data, "uint4(");
                 break;
-            case VKD3D_DATA_INT:
+            case VSIR_DATA_I32:
                 vkd3d_string_buffer_printf(image_data, "int4(");
                 break;
             default:
@@ -1333,7 +1333,7 @@ static void msl_store_uav_typed(struct msl_generator *gen, const struct vkd3d_sh
     msl_print_indent(gen->buffer, gen->indent);
     msl_print_uav_name(gen->buffer, gen, uav_binding, resource_type_info, data_type);
     vkd3d_string_buffer_printf(gen->buffer, ".write(%s, ", image_data->buffer);
-    msl_print_src_with_type(gen->buffer, gen, &ins->src[0], coord_mask, VKD3D_DATA_UINT);
+    msl_print_src_with_type(gen->buffer, gen, &ins->src[0], coord_mask, VSIR_DATA_U32);
     vkd3d_string_buffer_printf(gen->buffer, ");\n");
 
     vkd3d_string_buffer_release(&gen->string_buffers, image_data);
@@ -1894,19 +1894,19 @@ static void msl_generate_entrypoint_prologue(struct msl_generator *gen)
                 break;
 
             case VKD3D_SHADER_SV_VERTEX_ID:
-                msl_print_register_datatype(buffer, gen, VKD3D_DATA_UINT);
+                msl_print_register_datatype(buffer, gen, VSIR_DATA_U32);
                 msl_print_write_mask(buffer, e->mask);
                 vkd3d_string_buffer_printf(buffer, " = uint4(vertex_id, 0u, 0u, 0u)");
                 break;
 
             case VKD3D_SHADER_SV_IS_FRONT_FACE:
-                msl_print_register_datatype(buffer, gen, VKD3D_DATA_UINT);
+                msl_print_register_datatype(buffer, gen, VSIR_DATA_U32);
                 msl_print_write_mask(buffer, e->mask);
                 vkd3d_string_buffer_printf(buffer, " = uint4(input.is_front_face ? 0xffffffffu : 0u, 0, 0, 0)");
                 break;
 
             case VKD3D_SHADER_SV_SAMPLE_INDEX:
-                msl_print_register_datatype(buffer, gen, VKD3D_DATA_UINT);
+                msl_print_register_datatype(buffer, gen, VSIR_DATA_U32);
                 msl_print_write_mask(buffer, e->mask);
                 vkd3d_string_buffer_printf(buffer, " = uint4(input.sample_index, 0u, 0u, 0u)");
                 break;
@@ -2028,8 +2028,8 @@ static void msl_generate_entrypoint(struct msl_generator *gen)
 
 static int msl_generator_generate(struct msl_generator *gen, struct vkd3d_shader_code *out)
 {
-    const struct vkd3d_shader_instruction_array *instructions = &gen->program->instructions;
-    unsigned int i;
+    struct vkd3d_shader_instruction *ins;
+    struct vsir_program_iterator it;
 
     MESSAGE("Generating a MSL shader. This is unsupported; you get to keep all the pieces if it breaks.\n");
 
@@ -2095,9 +2095,10 @@ static int msl_generator_generate(struct msl_generator *gen, struct vkd3d_shader
         vkd3d_string_buffer_printf(gen->buffer, "vkd3d_vec4 r[%u];\n\n", gen->program->temp_count);
     }
 
-    for (i = 0; i < instructions->count; ++i)
+    it = vsir_program_iterator(&gen->program->instructions);
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
     {
-        msl_handle_instruction(gen, &instructions->elements[i]);
+        msl_handle_instruction(gen, ins);
     }
 
     --gen->indent;
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index eb9a90e8b44..d99c7ee27ff 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -3020,7 +3020,7 @@ struct ssa_register_info
 struct spirv_compiler
 {
     struct vkd3d_spirv_builder spirv_builder;
-    const struct vsir_program *program;
+    struct vsir_program *program;
 
     struct vkd3d_shader_message_context *message_context;
     struct vkd3d_shader_location location;
@@ -3150,7 +3150,7 @@ static void spirv_compiler_destroy(struct spirv_compiler *compiler)
     vkd3d_free(compiler);
 }
 
-static struct spirv_compiler *spirv_compiler_create(const struct vsir_program *program,
+static struct spirv_compiler *spirv_compiler_create(struct vsir_program *program,
         const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_message_context *message_context, uint64_t config_flags)
 {
@@ -4060,7 +4060,7 @@ static const struct
 parameter_data_type_map[] =
 {
     [VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32]      = {VSIR_DATA_F32, 1},
-    [VKD3D_SHADER_PARAMETER_DATA_TYPE_UINT32]       = {VKD3D_DATA_UINT,  1},
+    [VKD3D_SHADER_PARAMETER_DATA_TYPE_UINT32]       = {VSIR_DATA_U32, 1},
     [VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32_VEC4] = {VSIR_DATA_F32, 4},
 };
 
@@ -4491,7 +4491,7 @@ static uint32_t spirv_compiler_emit_int_to_bool(struct spirv_compiler *compiler,
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_BOOL, component_count);
     op = condition & VKD3D_SHADER_CONDITIONAL_OP_Z ? SpvOpIEqual : SpvOpINotEqual;
     return vkd3d_spirv_build_op_tr2(builder, &builder->function_stream, op, type_id, val_id,
-            data_type == VKD3D_DATA_UINT64
+            data_type == VSIR_DATA_U64
             ? spirv_compiler_get_constant_uint64_vector(compiler, 0, component_count)
             : spirv_compiler_get_constant_uint_vector(compiler, 0, component_count));
 }
@@ -4660,8 +4660,8 @@ static uint32_t spirv_compiler_emit_load_scalar(struct spirv_compiler *compiler,
                 type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_UINT, 1);
                 val_id = vkd3d_spirv_build_op_bitcast(builder, type_id, val_id);
             }
-            val_id = spirv_compiler_emit_int_to_bool(compiler, VKD3D_SHADER_CONDITIONAL_OP_NZ,
-                    VKD3D_DATA_UINT, 1, val_id);
+            val_id = spirv_compiler_emit_int_to_bool(compiler,
+                    VKD3D_SHADER_CONDITIONAL_OP_NZ, VSIR_DATA_U32, 1, val_id);
         }
         else
         {
@@ -4709,14 +4709,14 @@ static uint32_t spirv_compiler_emit_constant_array(struct spirv_compiler *compil
     switch (icb->data_type)
     {
         case VSIR_DATA_F32:
-        case VKD3D_DATA_INT:
-        case VKD3D_DATA_UINT:
+        case VSIR_DATA_I32:
+        case VSIR_DATA_U32:
             for (i = 0; i < element_count; ++i)
                 elements[i] = spirv_compiler_get_constant(compiler, component_type, component_count,
                         &icb->data[component_count * i]);
             break;
         case VSIR_DATA_F64:
-        case VKD3D_DATA_UINT64:
+        case VSIR_DATA_U64:
         {
             uint64_t *data = (uint64_t *)icb->data;
             for (i = 0; i < element_count; ++i)
@@ -4808,8 +4808,8 @@ static uint32_t spirv_compiler_emit_load_reg(struct spirv_compiler *compiler,
                 type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_UINT, component_count);
                 val_id = vkd3d_spirv_build_op_bitcast(builder, type_id, val_id);
             }
-            val_id = spirv_compiler_emit_int_to_bool(compiler, VKD3D_SHADER_CONDITIONAL_OP_NZ,
-                    VKD3D_DATA_UINT, component_count, val_id);
+            val_id = spirv_compiler_emit_int_to_bool(compiler,
+                    VKD3D_SHADER_CONDITIONAL_OP_NZ, VSIR_DATA_U32, component_count, val_id);
         }
         else
         {
@@ -5718,15 +5718,15 @@ static void spirv_compiler_emit_input(struct spirv_compiler *compiler,
     {
         component_type = builtin->component_type;
         input_component_count = builtin->component_count;
-        component_idx = 0;
     }
     else
     {
         component_type = signature_element->component_type;
         input_component_count = vsir_write_mask_component_count(signature_element->mask);
-        component_idx = vsir_write_mask_get_component_idx(signature_element->mask);
     }
 
+    component_idx = vsir_write_mask_get_component_idx(write_mask);
+
     if (needs_private_io_variable(builtin))
     {
         use_private_var = true;
@@ -5734,7 +5734,6 @@ static void spirv_compiler_emit_input(struct spirv_compiler *compiler,
     }
     else
     {
-        component_idx = vsir_write_mask_get_component_idx(write_mask);
         reg_write_mask = write_mask >> component_idx;
     }
 
@@ -5820,7 +5819,7 @@ static void spirv_compiler_emit_input(struct spirv_compiler *compiler,
                 vkd3d_write_mask_from_component_count(input_component_count),
                 VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_SHADER_NO_SWIZZLE, signature_element->mask >> component_idx);
 
-        spirv_compiler_emit_store_reg(compiler, &dst_reg, signature_element->mask, val_id);
+        spirv_compiler_emit_store_reg(compiler, &dst_reg, signature_element->mask >> component_idx, val_id);
     }
 }
 
@@ -7601,11 +7600,11 @@ static void spirv_compiler_emit_bool_cast(struct spirv_compiler *compiler,
         /* ITOD is not supported. Frontends which emit bool casts must use ITOF for double. */
         val_id = spirv_compiler_emit_bool_to_double(compiler, 1, val_id, instruction->opcode == VSIR_OP_ITOF);
     }
-    else if (dst->reg.data_type == VKD3D_DATA_UINT16 || dst->reg.data_type == VKD3D_DATA_UINT)
+    else if (dst->reg.data_type == VSIR_DATA_U16 || dst->reg.data_type == VSIR_DATA_U32)
     {
         val_id = spirv_compiler_emit_bool_to_int(compiler, 1, val_id, instruction->opcode == VSIR_OP_ITOI);
     }
-    else if (dst->reg.data_type == VKD3D_DATA_UINT64)
+    else if (dst->reg.data_type == VSIR_DATA_U64)
     {
         val_id = spirv_compiler_emit_bool_to_int64(compiler, 1, val_id, instruction->opcode == VSIR_OP_ITOI);
     }
@@ -7631,7 +7630,7 @@ static enum vkd3d_result spirv_compiler_emit_alu_instruction(struct spirv_compil
     SpvOp op = SpvOpMax;
     bool check_zero;
 
-    if (src->reg.data_type == VKD3D_DATA_UINT64 && instruction->opcode == VSIR_OP_COUNTBITS)
+    if (src->reg.data_type == VSIR_DATA_U64 && instruction->opcode == VSIR_OP_COUNTBITS)
     {
         /* At least some drivers support this anyway, but if validation is enabled it will fail. */
         FIXME("Unsupported 64-bit source for bit count.\n");
@@ -7701,7 +7700,7 @@ static enum vkd3d_result spirv_compiler_emit_alu_instruction(struct spirv_compil
         condition_id = spirv_compiler_emit_int_to_bool(compiler,
                 VKD3D_SHADER_CONDITIONAL_OP_NZ, src[1].reg.data_type, component_count, src_ids[1]);
 
-        if (dst[0].reg.data_type == VKD3D_DATA_UINT64)
+        if (dst[0].reg.data_type == VSIR_DATA_U64)
             uint_max_id = spirv_compiler_get_constant_uint64_vector(compiler, UINT64_MAX, component_count);
         else
             uint_max_id = spirv_compiler_get_constant_uint_vector(compiler, UINT_MAX, component_count);
@@ -7816,7 +7815,7 @@ static void spirv_compiler_emit_ext_glsl_instruction(struct spirv_compiler *comp
     unsigned int i, component_count;
     enum GLSLstd450 glsl_inst;
 
-    if (src[0].reg.data_type == VKD3D_DATA_UINT64 && (instruction->opcode == VSIR_OP_FIRSTBIT_HI
+    if (src[0].reg.data_type == VSIR_DATA_U64 && (instruction->opcode == VSIR_OP_FIRSTBIT_HI
             || instruction->opcode == VSIR_OP_FIRSTBIT_LO || instruction->opcode == VSIR_OP_FIRSTBIT_SHI))
     {
         /* At least some drivers support this anyway, but if validation is enabled it will fail. */
@@ -8226,7 +8225,7 @@ static void spirv_compiler_emit_bitfield_instruction(struct spirv_compiler *comp
 
     component_type = vkd3d_component_type_from_data_type(dst->reg.data_type);
     type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
-    size = (src[src_count - 1].reg.data_type == VKD3D_DATA_UINT64) ? 0x40 : 0x20;
+    size = (src[src_count - 1].reg.data_type == VSIR_DATA_U64) ? 0x40 : 0x20;
     mask_id = spirv_compiler_get_constant_uint(compiler, size - 1);
     size_id = spirv_compiler_get_constant_uint(compiler, size);
 
@@ -9424,7 +9423,7 @@ static void spirv_compiler_emit_store_uav_raw_structured(struct spirv_compiler *
                 &src[0], VKD3DSP_WRITEMASK_0, &src[1], VKD3DSP_WRITEMASK_0);
 
         data = &src[instruction->src_count - 1];
-        VKD3D_ASSERT(data->reg.data_type == VKD3D_DATA_UINT);
+        VKD3D_ASSERT(data->reg.data_type == VSIR_DATA_U32);
         val_id = spirv_compiler_emit_load_src(compiler, data, dst->write_mask);
 
         component_count = vsir_write_mask_component_count(dst->write_mask);
@@ -9452,7 +9451,7 @@ static void spirv_compiler_emit_store_uav_raw_structured(struct spirv_compiler *
                 type_id, image.structure_stride, &src[0], VKD3DSP_WRITEMASK_0, &src[1], VKD3DSP_WRITEMASK_0);
 
         data = &src[instruction->src_count - 1];
-        VKD3D_ASSERT(data->reg.data_type == VKD3D_DATA_UINT);
+        VKD3D_ASSERT(data->reg.data_type == VSIR_DATA_U32);
         val_id = spirv_compiler_emit_load_src(compiler, data, dst->write_mask);
 
         component_count = vsir_write_mask_component_count(dst->write_mask);
@@ -9495,7 +9494,7 @@ static void spirv_compiler_emit_store_tgsm(struct spirv_compiler *compiler,
             type_id, reg_info.structure_stride, &src[0], VKD3DSP_WRITEMASK_0, &src[1], VKD3DSP_WRITEMASK_0);
 
     data = src[instruction->src_count - 1];
-    data.reg.data_type = VKD3D_DATA_UINT;
+    data.reg.data_type = VSIR_DATA_U32;
     val_id = spirv_compiler_emit_load_src(compiler, &data, dst->write_mask);
 
     component_count = vsir_write_mask_component_count(dst->write_mask);
@@ -9997,7 +9996,7 @@ static uint32_t spirv_compiler_emit_query_sample_count(struct spirv_compiler *co
     if (src->reg.type == VKD3DSPR_RASTERIZER)
     {
         val_id = spirv_compiler_emit_shader_parameter(compiler,
-                VKD3D_SHADER_PARAMETER_NAME_RASTERIZER_SAMPLE_COUNT, VKD3D_DATA_UINT, 1);
+                VKD3D_SHADER_PARAMETER_NAME_RASTERIZER_SAMPLE_COUNT, VSIR_DATA_U32, 1);
     }
     else
     {
@@ -10317,7 +10316,7 @@ static void spirv_compiler_emit_quad_read_across(struct spirv_compiler *compiler
 
     type_id = vkd3d_spirv_get_type_id_for_data_type(builder, dst->reg.data_type,
             vsir_write_mask_component_count(dst->write_mask));
-    direction_type_id = vkd3d_spirv_get_type_id_for_data_type(builder, VKD3D_DATA_UINT, 1);
+    direction_type_id = vkd3d_spirv_get_type_id_for_data_type(builder, VSIR_DATA_U32, 1);
     val_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
     direction_id = map_quad_read_across_direction(instruction->opcode);
     direction_id = vkd3d_spirv_get_op_constant(builder, direction_type_id, direction_id);
@@ -11020,11 +11019,12 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     const struct vkd3d_shader_spirv_target_info *info = compiler->spirv_target_info;
     const struct vkd3d_shader_spirv_domain_shader_target_info *ds_info;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    const struct vsir_program *program = compiler->program;
-    struct vkd3d_shader_instruction_array instructions;
+    struct vsir_program *program = compiler->program;
     enum vkd3d_shader_spirv_environment environment;
+    struct vkd3d_shader_instruction *ins;
     enum vkd3d_result result = VKD3D_OK;
     unsigned int i, max_element_count;
+    struct vsir_program_iterator it;
 
     max_element_count = max(program->output_signature.element_count, program->patch_constant_signature.element_count);
     if (!(compiler->output_info = vkd3d_calloc(max_element_count, sizeof(*compiler->output_info))))
@@ -11072,8 +11072,6 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     if (program->block_count && !spirv_compiler_init_blocks(compiler, program->block_count))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    instructions = program->instructions;
-
     compiler->use_vocp = program->use_vocp;
     compiler->block_names = program->block_names;
     compiler->block_name_count = program->block_name_count;
@@ -11088,9 +11086,10 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     if (compiler->shader_type != VKD3D_SHADER_TYPE_HULL)
         spirv_compiler_emit_shader_signature_outputs(compiler);
 
-    for (i = 0; i < instructions.count && result >= 0; ++i)
+    it = vsir_program_iterator(&program->instructions);
+    for (ins = vsir_program_iterator_head(&it); ins && result >= 0; ins = vsir_program_iterator_next(&it))
     {
-        result = spirv_compiler_handle_instruction(compiler, &instructions.elements[i]);
+        result = spirv_compiler_handle_instruction(compiler, ins);
     }
 
     if (result < 0)
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index 26c41a902d2..8acd7bc0db5 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -753,8 +753,8 @@ static const enum vsir_data_type data_type_table[] =
     /* 0 */                         VSIR_DATA_F32,
     /* VKD3D_SM4_DATA_UNORM */      VKD3D_DATA_UNORM,
     /* VKD3D_SM4_DATA_SNORM */      VKD3D_DATA_SNORM,
-    /* VKD3D_SM4_DATA_INT */        VKD3D_DATA_INT,
-    /* VKD3D_SM4_DATA_UINT */       VKD3D_DATA_UINT,
+    /* VKD3D_SM4_DATA_INT */        VSIR_DATA_I32,
+    /* VKD3D_SM4_DATA_UINT */       VSIR_DATA_U32,
     /* VKD3D_SM4_DATA_FLOAT */      VSIR_DATA_F32,
     /* VKD3D_SM4_DATA_MIXED */      VKD3D_DATA_MIXED,
     /* VKD3D_SM4_DATA_DOUBLE */     VSIR_DATA_F64,
@@ -795,7 +795,7 @@ static bool shader_sm4_read_register_space(struct vkd3d_shader_sm4_parser *priv,
 static void shader_sm4_read_conditional_op(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_UINT, &ins->src[0]);
+    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VSIR_DATA_U32, &ins->src[0]);
     ins->flags = (opcode_token & VKD3D_SM4_CONDITIONAL_NZ) ?
             VKD3D_SHADER_CONDITIONAL_OP_NZ : VKD3D_SHADER_CONDITIONAL_OP_Z;
 }
@@ -803,7 +803,7 @@ static void shader_sm4_read_conditional_op(struct vkd3d_shader_instruction *ins,
 static void shader_sm4_read_case_condition(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_UINT, &ins->src[0]);
+    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VSIR_DATA_U32, &ins->src[0]);
     if (ins->src[0].reg.type != VKD3DSPR_IMMCONST)
     {
         FIXME("Switch case value is not a 32-bit constant.\n");
@@ -1432,8 +1432,8 @@ static void init_sm4_lookup_tables(struct vkd3d_sm4_lookup_tables *lookup)
     /*
      * d -> VSIR_DATA_F64
      * f -> VSIR_DATA_F32
-     * i -> VKD3D_DATA_INT
-     * u -> VKD3D_DATA_UINT
+     * i -> VSIR_DATA_I32
+     * u -> VSIR_DATA_U32
      * O -> VKD3D_DATA_OPAQUE
      * R -> VKD3D_DATA_RESOURCE
      * S -> VKD3D_DATA_SAMPLER
@@ -1578,8 +1578,8 @@ static void init_sm4_lookup_tables(struct vkd3d_sm4_lookup_tables *lookup)
         {VKD3D_SM5_OP_HS_CONTROL_POINT_PHASE,           VSIR_OP_HS_CONTROL_POINT_PHASE,           "",     ""},
         {VKD3D_SM5_OP_HS_FORK_PHASE,                    VSIR_OP_HS_FORK_PHASE,                    "",     ""},
         {VKD3D_SM5_OP_HS_JOIN_PHASE,                    VSIR_OP_HS_JOIN_PHASE,                    "",     ""},
-        {VKD3D_SM5_OP_EMIT_STREAM,                      VSIR_OP_EMIT_STREAM,                      "",     "f"},
-        {VKD3D_SM5_OP_CUT_STREAM,                       VSIR_OP_CUT_STREAM,                       "",     "f"},
+        {VKD3D_SM5_OP_EMIT_STREAM,                      VSIR_OP_EMIT_STREAM,                      "",     "*"},
+        {VKD3D_SM5_OP_CUT_STREAM,                       VSIR_OP_CUT_STREAM,                       "",     "*"},
         {VKD3D_SM5_OP_FCALL,                            VSIR_OP_FCALL,                            "",     "O",
                 shader_sm5_read_fcall},
         {VKD3D_SM5_OP_BUFINFO,                          VSIR_OP_BUFINFO,                          "i",    "*"},
@@ -1602,7 +1602,7 @@ static void init_sm4_lookup_tables(struct vkd3d_sm4_lookup_tables *lookup)
         {VKD3D_SM5_OP_BFI,                              VSIR_OP_BFI,                              "u",    "iiuu"},
         {VKD3D_SM5_OP_BFREV,                            VSIR_OP_BFREV,                            "u",    "u"},
         {VKD3D_SM5_OP_SWAPC,                            VSIR_OP_SWAPC,                            "ff",   "uff"},
-        {VKD3D_SM5_OP_DCL_STREAM,                       VSIR_OP_DCL_STREAM,                       "",     "O"},
+        {VKD3D_SM5_OP_DCL_STREAM,                       VSIR_OP_DCL_STREAM,                       "",     "*"},
         {VKD3D_SM5_OP_DCL_FUNCTION_BODY,                VSIR_OP_DCL_FUNCTION_BODY,                "",     "",
                 shader_sm5_read_dcl_function_body},
         {VKD3D_SM5_OP_DCL_FUNCTION_TABLE,               VSIR_OP_DCL_FUNCTION_TABLE,               "",     "",
@@ -1994,9 +1994,9 @@ static enum vsir_data_type map_data_type(char t)
         case 'f':
             return VSIR_DATA_F32;
         case 'i':
-            return VKD3D_DATA_INT;
+            return VSIR_DATA_I32;
         case 'u':
-            return VKD3D_DATA_UINT;
+            return VSIR_DATA_U32;
         case 'O':
             return VKD3D_DATA_OPAQUE;
         case '*':
@@ -2024,7 +2024,7 @@ static bool shader_sm4_read_reg_idx(struct vkd3d_shader_sm4_parser *priv, const
             reg_idx->offset = *(*ptr)++;
         else
             reg_idx->offset = 0;
-        shader_sm4_read_src_param(priv, ptr, end, VKD3D_DATA_INT, rel_addr);
+        shader_sm4_read_src_param(priv, ptr, end, VSIR_DATA_I32, rel_addr);
     }
     else
     {
@@ -2896,7 +2896,6 @@ static void shader_sm4_validate_default_phase_index_ranges(struct vkd3d_shader_s
 int tpf_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t config_flags,
         struct vkd3d_shader_message_context *message_context, struct vsir_program *program)
 {
-    struct vkd3d_shader_instruction_array *instructions;
     struct vkd3d_shader_sm4_parser sm4 = {0};
     struct dxbc_shader_desc dxbc_desc = {0};
     struct vkd3d_shader_instruction *ins;
@@ -2956,17 +2955,14 @@ int tpf_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t con
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    instructions = &program->instructions;
     while (sm4.ptr != sm4.end)
     {
-        if (!shader_instruction_array_reserve(instructions, instructions->count + 1))
+        if (!(ins = vsir_program_append(program)))
         {
-            ERR("Failed to allocate instructions.\n");
             vkd3d_shader_parser_error(&sm4.p, VKD3D_SHADER_ERROR_TPF_OUT_OF_MEMORY, "Out of memory.");
             vsir_program_cleanup(program);
             return VKD3D_ERROR_OUT_OF_MEMORY;
         }
-        ins = &instructions->elements[instructions->count];
         shader_sm4_read_instruction(&sm4, ins);
 
         if (ins->opcode == VSIR_OP_INVALID)
@@ -2975,7 +2971,6 @@ int tpf_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t con
             vsir_program_cleanup(program);
             return VKD3D_ERROR_OUT_OF_MEMORY;
         }
-        ++instructions->count;
     }
     if (program->shader_version.type == VKD3D_SHADER_TYPE_HULL
             && !sm4.has_control_point_phase && !sm4.p.failed)
@@ -4339,20 +4334,23 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
     }
 }
 
-static void tpf_write_program(struct tpf_compiler *tpf, const struct vsir_program *program)
+static void tpf_write_program(struct tpf_compiler *tpf, struct vsir_program *program)
 {
-    unsigned int i;
+    struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
+    struct vkd3d_shader_instruction *ins;
 
     if (tpf->program->shader_version.type == VKD3D_SHADER_TYPE_COMPUTE)
         tpf_dcl_thread_group(tpf, &tpf->program->thread_group_size);
 
-    for (i = 0; i < program->instructions.count; ++i)
-        tpf_handle_instruction(tpf, &program->instructions.elements[i]);
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
+    {
+        tpf_handle_instruction(tpf, ins);
+    }
 }
 
 static void tpf_write_shdr(struct tpf_compiler *tpf)
 {
-    const struct vsir_program *program = tpf->program;
+    struct vsir_program *program = tpf->program;
     const struct vkd3d_shader_version *version;
     struct vkd3d_bytecode_buffer buffer = {0};
     size_t token_count_position;
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index c60feec4aa2..9c615c116e9 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -1120,7 +1120,7 @@ static void vkd3d_shader_scan_constant_buffer_declaration(struct vkd3d_shader_sc
     struct vkd3d_shader_descriptor_info1 *d;
 
     if (!(d = vkd3d_shader_scan_add_descriptor(context, VKD3D_SHADER_DESCRIPTOR_TYPE_CBV,
-            &cb->src.reg, &cb->range, VKD3D_SHADER_RESOURCE_BUFFER, VKD3D_DATA_UINT)))
+            &cb->src.reg, &cb->range, VKD3D_SHADER_RESOURCE_BUFFER, VSIR_DATA_U32)))
         return;
     d->buffer_size = cb->size;
 }
@@ -1305,12 +1305,12 @@ static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *conte
         case VSIR_OP_DCL_RESOURCE_RAW:
         case VSIR_OP_DCL_UAV_RAW:
             vkd3d_shader_scan_resource_declaration(context, &instruction->declaration.raw_resource.resource,
-                    VKD3D_SHADER_RESOURCE_BUFFER, VKD3D_DATA_UINT, 0, 0, true, instruction->flags);
+                    VKD3D_SHADER_RESOURCE_BUFFER, VSIR_DATA_U32, 0, 0, true, instruction->flags);
             break;
         case VSIR_OP_DCL_RESOURCE_STRUCTURED:
         case VSIR_OP_DCL_UAV_STRUCTURED:
             vkd3d_shader_scan_resource_declaration(context, &instruction->declaration.structured_resource.resource,
-                    VKD3D_SHADER_RESOURCE_BUFFER, VKD3D_DATA_UINT, 0,
+                    VKD3D_SHADER_RESOURCE_BUFFER, VSIR_DATA_U32, 0,
                     instruction->declaration.structured_resource.byte_stride, false, instruction->flags);
             break;
         case VSIR_OP_DCL_TESSELLATOR_OUTPUT_PRIMITIVE:
@@ -1530,10 +1530,6 @@ static enum vkd3d_shader_resource_data_type vkd3d_resource_data_type_from_data_t
             return VKD3D_SHADER_RESOURCE_DATA_UNORM;
         case VKD3D_DATA_SNORM:
             return VKD3D_SHADER_RESOURCE_DATA_SNORM;
-        case VKD3D_DATA_INT:
-            return VKD3D_SHADER_RESOURCE_DATA_INT;
-        case VKD3D_DATA_UINT:
-            return VKD3D_SHADER_RESOURCE_DATA_UINT;
         case VKD3D_DATA_MIXED:
             return VKD3D_SHADER_RESOURCE_DATA_MIXED;
         case VKD3D_DATA_CONTINUED:
@@ -1544,6 +1540,10 @@ static enum vkd3d_shader_resource_data_type vkd3d_resource_data_type_from_data_t
             return VKD3D_SHADER_RESOURCE_DATA_FLOAT;
         case VSIR_DATA_F64:
             return VKD3D_SHADER_RESOURCE_DATA_DOUBLE;
+        case VSIR_DATA_I32:
+            return VKD3D_SHADER_RESOURCE_DATA_INT;
+        case VSIR_DATA_U32:
+            return VKD3D_SHADER_RESOURCE_DATA_UINT;
         default:
             ERR("Invalid resource data type %#x.\n", data_type);
             return VKD3D_SHADER_RESOURCE_DATA_FLOAT;
@@ -1647,8 +1647,8 @@ static int vsir_program_scan(struct vsir_program *program, const struct vkd3d_sh
 
         if (size)
         {
-            if ((d = vkd3d_shader_scan_add_descriptor(&context, VKD3D_SHADER_DESCRIPTOR_TYPE_CBV, &reg,
-                    &range, VKD3D_SHADER_RESOURCE_BUFFER, VKD3D_DATA_UINT)))
+            if ((d = vkd3d_shader_scan_add_descriptor(&context, VKD3D_SHADER_DESCRIPTOR_TYPE_CBV,
+                    &reg, &range, VKD3D_SHADER_RESOURCE_BUFFER, VSIR_DATA_U32)))
                 d->buffer_size = size * 16;
         }
     }
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index f7bbadac3df..42f3c42033f 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -710,30 +710,32 @@ enum vkd3d_shader_register_precision
 
 enum vsir_data_type
 {
-    VKD3D_DATA_INT,
-    VKD3D_DATA_UINT,
     VKD3D_DATA_UNORM,
     VKD3D_DATA_SNORM,
     VKD3D_DATA_OPAQUE,
     VKD3D_DATA_MIXED,
     VKD3D_DATA_CONTINUED,
     VKD3D_DATA_UNUSED,
-    VKD3D_DATA_UINT8,
-    VKD3D_DATA_UINT64,
     VKD3D_DATA_BOOL,
-    VKD3D_DATA_UINT16,
 
     VSIR_DATA_F16,
     VSIR_DATA_F32,
     VSIR_DATA_F64,
 
+    VSIR_DATA_I32,
+
+    VSIR_DATA_U8,
+    VSIR_DATA_U16,
+    VSIR_DATA_U32,
+    VSIR_DATA_U64,
+
     VSIR_DATA_TYPE_COUNT,
 };
 
 static inline bool data_type_is_integer(enum vsir_data_type data_type)
 {
-    return data_type == VKD3D_DATA_INT || data_type == VKD3D_DATA_UINT8 || data_type == VKD3D_DATA_UINT16
-            || data_type == VKD3D_DATA_UINT || data_type == VKD3D_DATA_UINT64;
+    return data_type == VSIR_DATA_I32 || data_type == VSIR_DATA_U8 || data_type == VSIR_DATA_U16
+            || data_type == VSIR_DATA_U32 || data_type == VSIR_DATA_U64;
 }
 
 static inline bool data_type_is_bool(enum vsir_data_type data_type)
@@ -748,7 +750,7 @@ static inline bool data_type_is_floating_point(enum vsir_data_type data_type)
 
 static inline bool data_type_is_64_bit(enum vsir_data_type data_type)
 {
-    return data_type == VSIR_DATA_F64 || data_type == VKD3D_DATA_UINT64;
+    return data_type == VSIR_DATA_F64 || data_type == VSIR_DATA_U64;
 }
 
 enum vsir_dimension
@@ -1581,6 +1583,16 @@ bool vsir_instruction_init_with_params(struct vsir_program *program,
         struct vkd3d_shader_instruction *ins, const struct vkd3d_shader_location *location,
         enum vkd3d_shader_opcode opcode, unsigned int dst_count, unsigned int src_count);
 
+static inline struct vkd3d_shader_instruction *vsir_program_append(struct vsir_program *program)
+{
+    struct vkd3d_shader_instruction_array *array = &program->instructions;
+
+    if (!shader_instruction_array_insert_at(array, array->count, 1))
+        return NULL;
+
+    return &array->elements[array->count - 1];
+}
+
 static inline struct vkd3d_shader_dst_param *vsir_program_get_dst_params(
         struct vsir_program *program, unsigned int count)
 {
@@ -1608,7 +1620,7 @@ void vkd3d_shader_parser_init(struct vkd3d_shader_parser *parser, struct vsir_pr
 void vkd3d_shader_parser_warning(struct vkd3d_shader_parser *parser,
         enum vkd3d_shader_error error, const char *format, ...) VKD3D_PRINTF_FUNC(3, 4);
 
-void vsir_program_trace(const struct vsir_program *program);
+void vsir_program_trace(struct vsir_program *program);
 
 const char *shader_get_type_prefix(enum vkd3d_shader_type type);
 
@@ -1633,7 +1645,7 @@ enum vsir_asm_flags
     VSIR_ASM_FLAG_DUMP_DESCRIPTORS = 0x8,
 };
 
-enum vkd3d_result d3d_asm_compile(const struct vsir_program *program,
+enum vkd3d_result d3d_asm_compile(struct vsir_program *program,
         const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_code *out, enum vsir_asm_flags flags);
 void vkd3d_string_buffer_cleanup(struct vkd3d_string_buffer *buffer);
@@ -1799,12 +1811,12 @@ static inline enum vkd3d_shader_component_type vkd3d_component_type_from_data_ty
             return VKD3D_SHADER_COMPONENT_FLOAT;
         case VSIR_DATA_F64:
             return VKD3D_SHADER_COMPONENT_DOUBLE;
-        case VKD3D_DATA_UINT16: /* Minimum precision. TODO: native 16-bit */
-        case VKD3D_DATA_UINT:
-            return VKD3D_SHADER_COMPONENT_UINT;
-        case VKD3D_DATA_INT:
+        case VSIR_DATA_I32:
             return VKD3D_SHADER_COMPONENT_INT;
-        case VKD3D_DATA_UINT64:
+        case VSIR_DATA_U16: /* Minimum precision. TODO: native 16-bit */
+        case VSIR_DATA_U32:
+            return VKD3D_SHADER_COMPONENT_UINT;
+        case VSIR_DATA_U64:
             return VKD3D_SHADER_COMPONENT_UINT64;
         case VKD3D_DATA_BOOL:
             return VKD3D_SHADER_COMPONENT_BOOL;
@@ -1823,9 +1835,9 @@ static inline enum vsir_data_type vsir_data_type_from_component_type(enum vkd3d_
         case VKD3D_SHADER_COMPONENT_FLOAT:
             return VSIR_DATA_F32;
         case VKD3D_SHADER_COMPONENT_UINT:
-            return VKD3D_DATA_UINT;
+            return VSIR_DATA_U32;
         case VKD3D_SHADER_COMPONENT_INT:
-            return VKD3D_DATA_INT;
+            return VSIR_DATA_I32;
         case VKD3D_SHADER_COMPONENT_DOUBLE:
             return VSIR_DATA_F64;
         default:
-- 
2.47.2

