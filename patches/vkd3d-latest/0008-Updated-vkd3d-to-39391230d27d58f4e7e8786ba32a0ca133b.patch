From 94dda6de862380f5d527ebd1690a3be3aac2fba8 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 30 Oct 2025 06:55:15 +1100
Subject: [PATCH] Updated vkd3d to 39391230d27d58f4e7e8786ba32a0ca133b28fc0.

---
 libs/vkd3d/libs/vkd3d-shader/dxil.c  | 264 ++++++++++++++-------------
 libs/vkd3d/libs/vkd3d-shader/ir.c    |  25 +++
 libs/vkd3d/libs/vkd3d-shader/msl.c   |  61 +++----
 libs/vkd3d/libs/vkd3d-shader/spirv.c |  65 +++----
 4 files changed, 221 insertions(+), 194 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index 7861efc16d2..8d803b91f7a 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -647,13 +647,13 @@ enum sm6_value_type
 {
     VALUE_TYPE_INVALID,
     VALUE_TYPE_FUNCTION,
-    VALUE_TYPE_DATA,
     VALUE_TYPE_HANDLE,
     VALUE_TYPE_SSA,
     VALUE_TYPE_ICB,
     VALUE_TYPE_IDXTEMP,
     VALUE_TYPE_GROUPSHAREDMEM,
     VALUE_TYPE_CONSTANT,
+    VALUE_TYPE_CONSTANT_ARRAY,
     VALUE_TYPE_UNDEFINED,
 };
 
@@ -706,6 +706,12 @@ struct sm6_constant_data
     union vsir_immediate_constant immconst;
 };
 
+struct sm6_constant_array_data
+{
+    const struct vkd3d_shader_immediate_constant_buffer *icb;
+    const uint64_t *elements;
+};
+
 struct sm6_value
 {
     const struct sm6_type *type;
@@ -716,13 +722,13 @@ struct sm6_value
     union
     {
         struct sm6_function_data function;
-        const struct vkd3d_shader_immediate_constant_buffer *data;
         struct sm6_handle_data handle;
         struct sm6_ssa_data ssa;
         struct sm6_icb_data icb;
         struct sm6_idxtemp_data idxtemp;
         struct sm6_groupsharedmem_data groupsharedmem;
         struct sm6_constant_data constant;
+        struct sm6_constant_array_data constant_array;
     } u;
 };
 
@@ -2280,6 +2286,11 @@ static inline bool sm6_value_is_constant(const struct sm6_value *value)
     return value->value_type == VALUE_TYPE_CONSTANT;
 }
 
+static bool sm6_value_is_constant_array(const struct sm6_value *value)
+{
+    return value->value_type == VALUE_TYPE_CONSTANT_ARRAY;
+}
+
 static bool sm6_value_is_constant_zero(const struct sm6_value *value)
 {
     if (value->value_type != VALUE_TYPE_CONSTANT)
@@ -2323,11 +2334,6 @@ static bool sm6_value_vector_is_constant_or_undef(const struct sm6_value **value
     return true;
 }
 
-static bool sm6_value_is_data(const struct sm6_value *value)
-{
-    return value->value_type == VALUE_TYPE_DATA;
-}
-
 static bool sm6_value_is_ssa(const struct sm6_value *value)
 {
     return value->value_type == VALUE_TYPE_SSA;
@@ -2662,7 +2668,7 @@ static void vsir_register_from_dxil_value(struct vkd3d_shader_register *reg,
 
         case VALUE_TYPE_FUNCTION:
         case VALUE_TYPE_HANDLE:
-        case VALUE_TYPE_DATA:
+        case VALUE_TYPE_CONSTANT_ARRAY:
             vkd3d_unreachable();
     }
 
@@ -3067,7 +3073,7 @@ static bool sm6_value_validate_is_i32(const struct sm6_value *value, struct sm6_
     return true;
 }
 
-static const struct sm6_value *sm6_parser_get_value_safe(struct sm6_parser *sm6, unsigned int idx)
+static struct sm6_value *sm6_parser_get_value_safe(struct sm6_parser *sm6, unsigned int idx)
 {
     if (idx < sm6->value_count)
         return &sm6->values[idx];
@@ -3211,107 +3217,6 @@ static inline uint64_t decode_rotated_signed_value(uint64_t value)
     return value << 63;
 }
 
-static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, const struct sm6_type *type,
-        const uint64_t *operands, struct sm6_parser *sm6)
-{
-    struct vkd3d_shader_immediate_constant_buffer *icb;
-    const struct sm6_type *elem_type;
-    unsigned int i, size, count;
-    uint64_t *data64;
-
-    elem_type = type->u.array.elem_type;
-    /* Multidimensional arrays are emitted in flattened form. */
-    if (elem_type->class != TYPE_CLASS_INTEGER && elem_type->class != TYPE_CLASS_FLOAT)
-    {
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_NOT_IMPLEMENTED,
-                "The element data type for an immediate constant buffer is not scalar integer or floating point.");
-        return VKD3D_ERROR_INVALID_SHADER;
-    }
-
-    /* Arrays of bool are not used in DXIL. dxc will emit an array of int32 instead if necessary. */
-    if (!(size = elem_type->u.width / CHAR_BIT))
-    {
-        WARN("Invalid data type width %u.\n", elem_type->u.width);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                "An immediate constant buffer is declared with boolean elements.");
-        return VKD3D_ERROR_INVALID_SHADER;
-    }
-    size = max(size, sizeof(icb->data[0]));
-    count = operands ? type->u.array.count * size / sizeof(icb->data[0]) : 0;
-
-    if (!(icb = vkd3d_malloc(offsetof(struct vkd3d_shader_immediate_constant_buffer, data[count]))))
-    {
-        ERR("Failed to allocate buffer, count %u.\n", count);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
-                "Out of memory allocating an immediate constant buffer of count %u.", count);
-        return VKD3D_ERROR_OUT_OF_MEMORY;
-    }
-    if (!vsir_program_add_icb(sm6->program, icb))
-    {
-        ERR("Failed to store icb object.\n");
-        vkd3d_free(icb);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
-                "Out of memory storing an immediate constant buffer object.");
-        return VKD3D_ERROR_OUT_OF_MEMORY;
-    }
-
-    dst->value_type = VALUE_TYPE_DATA;
-    dst->u.data = icb;
-
-    icb->register_idx = sm6->icb_count++;
-    icb->data_type = vsir_data_type_from_dxil(elem_type, 0, sm6);
-    icb->element_count = type->u.array.count;
-    icb->component_count = 1;
-    icb->is_null = !operands;
-
-    if (!operands)
-        return VKD3D_OK;
-
-    count = type->u.array.count;
-    switch (icb->data_type)
-    {
-        case VSIR_DATA_F16:
-            for (i = 0; i < count; ++i)
-                icb->data[i] = half_to_float(operands[i]);
-            icb->data_type = VSIR_DATA_F32;
-            break;
-
-        case VSIR_DATA_I16:
-            for (i = 0; i < count; ++i)
-                icb->data[i] = (int16_t)operands[i];
-            icb->data_type = VSIR_DATA_I32;
-            break;
-
-        case VSIR_DATA_U16:
-            for (i = 0; i < count; ++i)
-                icb->data[i] = (int16_t)operands[i];
-            icb->data_type = VSIR_DATA_U32;
-            break;
-
-        case VSIR_DATA_F32:
-        case VSIR_DATA_I32:
-        case VSIR_DATA_U32:
-            for (i = 0; i < count; ++i)
-                icb->data[i] = operands[i];
-            break;
-
-        case VSIR_DATA_F64:
-        case VSIR_DATA_I64:
-        case VSIR_DATA_U64:
-            data64 = (uint64_t *)icb->data;
-            for (i = 0; i < count; ++i)
-                data64[i] = operands[i];
-            break;
-
-        default:
-            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                    "Invalid array of type %u.", icb->data_type);
-            return VKD3D_ERROR_INVALID_SHADER;
-    }
-
-    return VKD3D_OK;
-}
-
 static struct sm6_index *sm6_get_value_index(struct sm6_parser *sm6, struct sm6_value *value)
 {
     switch (value->value_type)
@@ -3498,8 +3403,8 @@ static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const
             case CST_CODE_NULL:
                 if (sm6_type_is_array(type))
                 {
-                    if ((ret = value_allocate_constant_array(dst, type, NULL, sm6)) < 0)
-                        return ret;
+                    dst->value_type = VALUE_TYPE_CONSTANT_ARRAY;
+                    dst->u.constant_array.elements = NULL;
                 }
                 else
                 {
@@ -3559,8 +3464,8 @@ static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const
                 if (!dxil_record_validate_operand_count(record, type->u.array.count, type->u.array.count, sm6))
                     return VKD3D_ERROR_INVALID_SHADER;
 
-                if ((ret = value_allocate_constant_array(dst, type, record->operands, sm6)) < 0)
-                    return ret;
+                dst->value_type = VALUE_TYPE_CONSTANT_ARRAY;
+                dst->u.constant_array.elements = record->operands;
 
                 break;
 
@@ -3943,20 +3848,129 @@ static bool sm6_parser_declare_global(struct sm6_parser *sm6, const struct dxil_
 static const struct vkd3d_shader_immediate_constant_buffer *resolve_forward_initialiser(
         size_t index, struct sm6_parser *sm6)
 {
-    const struct sm6_value *value;
+    struct sm6_value *value;
 
     VKD3D_ASSERT(index);
     --index;
-    if (!(value = sm6_parser_get_value_safe(sm6, index)) || (!sm6_value_is_data(value) && !sm6_value_is_undef(value)))
+    if (!(value = sm6_parser_get_value_safe(sm6, index))
+            || (!sm6_value_is_constant_array(value) && !sm6_value_is_undef(value)))
     {
         WARN("Invalid initialiser index %zu.\n", index);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Global variable initialiser value index %zu is invalid.", index);
         return NULL;
     }
-    else if (sm6_value_is_data(value))
+    else if (sm6_value_is_constant_array(value))
     {
-        return value->u.data;
+        const uint64_t *elements = value->u.constant_array.elements;
+        struct vkd3d_shader_immediate_constant_buffer *icb;
+        const struct sm6_array_info *array;
+        const struct sm6_type *elem_type;
+        unsigned int i, size, count;
+        uint64_t *data64;
+
+        if (value->u.constant_array.icb)
+            return value->u.constant_array.icb;
+
+        array = &value->type->u.array;
+        elem_type = array->elem_type;
+        /* Multidimensional arrays are emitted in flattened form. */
+        if (elem_type->class != TYPE_CLASS_INTEGER && elem_type->class != TYPE_CLASS_FLOAT)
+        {
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_NOT_IMPLEMENTED,
+                    "The element data type for an immediate constant buffer is not scalar integer or floating point.");
+            return NULL;
+        }
+
+        /* Arrays of bool are not used in DXIL. dxc will emit an array of int32 instead if necessary. */
+        if (!(size = elem_type->u.width / CHAR_BIT))
+        {
+            WARN("Invalid data type width %u.\n", elem_type->u.width);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "An immediate constant buffer is declared with boolean elements.");
+            return NULL;
+        }
+        size = max(size, sizeof(icb->data[0]));
+        count = elements ? array->count * size / sizeof(icb->data[0]) : 0;
+
+        if (!(icb = vkd3d_malloc(offsetof(struct vkd3d_shader_immediate_constant_buffer, data[count]))))
+        {
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                    "Out of memory allocating an immediate constant buffer of count %u.", count);
+            return NULL;
+        }
+
+        if (!vsir_program_add_icb(sm6->program, icb))
+        {
+            vkd3d_free(icb);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                    "Out of memory storing an immediate constant buffer object.");
+            return NULL;
+        }
+
+        count = array->count;
+        icb->register_idx = sm6->icb_count++;
+        icb->data_type = vsir_data_type_from_dxil(elem_type, 0, sm6);
+        icb->element_count = count;
+        icb->component_count = 1;
+        icb->is_null = !elements;
+        value->u.constant_array.icb = icb;
+
+        if (!elements)
+            return icb;
+
+        switch (icb->data_type)
+        {
+            case VSIR_DATA_F16:
+                icb->data_type = VSIR_DATA_F32;
+                for (i = 0; i < count; ++i)
+                {
+                    icb->data[i] = half_to_float(elements[i]);
+                }
+                break;
+
+            case VSIR_DATA_I16:
+                icb->data_type = VSIR_DATA_I32;
+                for (i = 0; i < count; ++i)
+                {
+                    icb->data[i] = (int16_t)elements[i];
+                }
+                break;
+
+            case VSIR_DATA_U16:
+                icb->data_type = VSIR_DATA_U32;
+                for (i = 0; i < count; ++i)
+                {
+                    icb->data[i] = (int16_t)elements[i];
+                }
+                break;
+
+            case VSIR_DATA_F32:
+            case VSIR_DATA_I32:
+            case VSIR_DATA_U32:
+                for (i = 0; i < count; ++i)
+                {
+                    icb->data[i] = elements[i];
+                }
+                break;
+
+            case VSIR_DATA_F64:
+            case VSIR_DATA_I64:
+            case VSIR_DATA_U64:
+                data64 = (uint64_t *)icb->data;
+                for (i = 0; i < count; ++i)
+                {
+                    data64[i] = elements[i];
+                }
+                break;
+
+            default:
+                vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                        "Invalid array of type %u.", icb->data_type);
+                return NULL;
+        }
+
+        return icb;
     }
     /* In VSIR, initialisation with undefined values of objects is implied, not explicit. */
     return NULL;
@@ -3970,15 +3984,16 @@ static bool resolve_forward_zero_initialiser(size_t index, struct sm6_parser *sm
         return false;
 
     --index;
-    if (!(value = sm6_parser_get_value_safe(sm6, index))
-            || (!sm6_value_is_data(value) && !sm6_value_is_constant(value) && !sm6_value_is_undef(value)))
+    if (!(value = sm6_parser_get_value_safe(sm6, index)) || (!sm6_value_is_constant_array(value)
+            && !sm6_value_is_constant(value) && !sm6_value_is_undef(value)))
     {
         WARN("Invalid initialiser index %zu.\n", index);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "TGSM initialiser value index %zu is invalid.", index);
         return false;
     }
-    else if ((sm6_value_is_data(value) && value->u.data->is_null) || sm6_value_is_constant_zero(value))
+    else if ((sm6_value_is_constant_array(value) && !value->u.constant_array.elements)
+            || sm6_value_is_constant_zero(value))
     {
         return true;
     }
@@ -6299,8 +6314,7 @@ static void sm6_parser_emit_dx_store_output(struct sm6_parser *sm6, enum dx_intr
         return;
     }
     e = &signature->elements[row_index];
-    if (!e->sysval_semantic)
-        column_index += vsir_write_mask_get_component_idx(e->mask);
+    column_index += vsir_write_mask_get_component_idx(e->mask);
 
     if (column_index >= VKD3D_VEC4_SIZE)
     {
@@ -8911,8 +8925,8 @@ static enum vkd3d_result sm6_parser_metadata_init(struct sm6_parser *sm6, const
                 if (!(value = sm6_parser_get_value_safe(sm6, value_idx)))
                     return VKD3D_ERROR_INVALID_SHADER;
 
-                if (!sm6_value_is_constant(value) && !sm6_value_is_undef(value) && !sm6_value_is_data(value)
-                        && !sm6_value_is_function_dcl(value))
+                if (!sm6_value_is_constant(value) && !sm6_value_is_undef(value)
+                        && !sm6_value_is_constant_array(value) && !sm6_value_is_function_dcl(value))
                 {
                     WARN("Value at index %u is not a constant or a function declaration.\n", value_idx);
                     vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index a566d65d8cd..5b1d0449a64 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -2477,6 +2477,7 @@ static enum vkd3d_result vsir_program_lower_instructions(struct vsir_program *pr
             case VSIR_OP_DCL:
             case VSIR_OP_DCL_CONSTANT_BUFFER:
             case VSIR_OP_DCL_GLOBAL_FLAGS:
+            case VSIR_OP_DCL_IMMEDIATE_CONSTANT_BUFFER:
             case VSIR_OP_DCL_INPUT_PRIMITIVE:
             case VSIR_OP_DCL_OUTPUT_TOPOLOGY:
             case VSIR_OP_DCL_SAMPLER:
@@ -11011,10 +11012,34 @@ static void vsir_validate_io_dst_param(struct validation_context *ctx,
         const struct vkd3d_shader_dst_param *dst)
 {
     struct vsir_io_register_data io_reg_data;
+    const struct signature_element *e;
+    unsigned int idx;
 
     if (!vsir_get_io_register_data(ctx, dst->reg.type, &io_reg_data) || !(io_reg_data.flags & OUTPUT_BIT))
+    {
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
                 "Invalid register type %#x used as destination parameter.", dst->reg.type);
+        return;
+    }
+
+    if (ctx->program->normalisation_level >= VSIR_NORMALISED_SM6)
+    {
+        if (!dst->reg.idx_count)
+        {
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid index count %u for a register of type %#x.",
+                    dst->reg.idx_count, dst->reg.type);
+            return;
+        }
+
+        idx = dst->reg.idx[dst->reg.idx_count - 1].offset;
+        e = &io_reg_data.signature->elements[idx];
+
+        if (dst->write_mask & ~e->mask)
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid destination write mask %#x for signature element with mask %#x.",
+                    dst->write_mask, e->mask);
+    }
 }
 
 static void vsir_validate_dst_param(struct validation_context *ctx,
diff --git a/libs/vkd3d/libs/vkd3d-shader/msl.c b/libs/vkd3d/libs/vkd3d-shader/msl.c
index 7b4804e8036..c974c9e532b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/msl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/msl.c
@@ -209,8 +209,8 @@ static bool msl_check_shader_visibility(const struct msl_generator *gen,
     }
 }
 
-static bool msl_get_binding(const struct msl_generator *gen, unsigned int register_space, unsigned int register_idx,
-        enum vkd3d_shader_descriptor_type type, enum vkd3d_shader_binding_flag flags, unsigned int *idx)
+static bool msl_get_binding(const struct msl_generator *gen, const struct vkd3d_shader_descriptor_info1 *descriptor,
+        unsigned int register_idx, enum vkd3d_shader_binding_flag flags, unsigned int *idx)
 {
     const struct vkd3d_shader_interface_info *interface_info = gen->interface_info;
     unsigned int i;
@@ -222,9 +222,9 @@ static bool msl_get_binding(const struct msl_generator *gen, unsigned int regist
     {
         const struct vkd3d_shader_resource_binding *binding = &interface_info->bindings[i];
 
-        if (binding->type != type)
+        if (binding->type != descriptor->type)
             continue;
-        if (binding->register_space != register_space)
+        if (binding->register_space != descriptor->register_space)
             continue;
         if (binding->register_index != register_idx)
             continue;
@@ -241,31 +241,30 @@ static bool msl_get_binding(const struct msl_generator *gen, unsigned int regist
 }
 
 static bool msl_get_cbv_binding(const struct msl_generator *gen,
-        unsigned int register_space, unsigned int register_idx, unsigned int *idx)
+        const struct vkd3d_shader_descriptor_info1 *descriptor, unsigned int register_idx, unsigned int *idx)
 {
-    return msl_get_binding(gen, register_space, register_idx,
-            VKD3D_SHADER_DESCRIPTOR_TYPE_CBV, VKD3D_SHADER_BINDING_FLAG_BUFFER, idx);
+    return msl_get_binding(gen, descriptor, register_idx, VKD3D_SHADER_BINDING_FLAG_BUFFER, idx);
 }
 
 static bool msl_get_sampler_binding(const struct msl_generator *gen,
-        unsigned int register_space, unsigned int register_idx, unsigned int *idx)
+        const struct vkd3d_shader_descriptor_info1 *descriptor, unsigned int register_idx, unsigned int *idx)
 {
-    return msl_get_binding(gen, register_space, register_idx, VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER, 0, idx);
+    return msl_get_binding(gen, descriptor, register_idx, 0, idx);
 }
 
-static bool msl_get_srv_binding(const struct msl_generator *gen, unsigned int register_space,
-        unsigned int register_idx, enum vkd3d_shader_resource_type resource_type, unsigned int *idx)
+static bool msl_get_srv_binding(const struct msl_generator *gen,
+        const struct vkd3d_shader_descriptor_info1 *descriptor, unsigned int register_idx, unsigned int *idx)
 {
-    return msl_get_binding(gen, register_space, register_idx,
-            VKD3D_SHADER_DESCRIPTOR_TYPE_SRV, resource_type == VKD3D_SHADER_RESOURCE_BUFFER
+    return msl_get_binding(gen, descriptor, register_idx,
+            descriptor->resource_type == VKD3D_SHADER_RESOURCE_BUFFER
             ? VKD3D_SHADER_BINDING_FLAG_BUFFER : VKD3D_SHADER_BINDING_FLAG_IMAGE, idx);
 }
 
-static bool msl_get_uav_binding(const struct msl_generator *gen, unsigned int register_space,
-        unsigned int register_idx, enum vkd3d_shader_resource_type resource_type, unsigned int *idx)
+static bool msl_get_uav_binding(const struct msl_generator *gen,
+        const struct vkd3d_shader_descriptor_info1 *descriptor, unsigned int register_idx, unsigned int *idx)
 {
-    return msl_get_binding(gen, register_space, register_idx,
-            VKD3D_SHADER_DESCRIPTOR_TYPE_UAV, resource_type == VKD3D_SHADER_RESOURCE_BUFFER
+    return msl_get_binding(gen, descriptor, register_idx,
+            descriptor->resource_type == VKD3D_SHADER_RESOURCE_BUFFER
             ? VKD3D_SHADER_BINDING_FLAG_BUFFER : VKD3D_SHADER_BINDING_FLAG_IMAGE, idx);
 }
 
@@ -405,7 +404,7 @@ static enum msl_data_type msl_print_register_name(struct vkd3d_string_buffer *bu
                 return MSL_DATA_UNION;
             }
 
-            if (!msl_get_cbv_binding(gen, descriptor->register_space, cbv_idx, &binding))
+            if (!msl_get_cbv_binding(gen, descriptor, cbv_idx, &binding))
             {
                 msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_BINDING_NOT_FOUND,
                         "No descriptor binding specified for CBV %u.", cbv_id);
@@ -871,7 +870,7 @@ static void msl_ld(struct msl_generator *gen, const struct vkd3d_shader_instruct
     uint32_t coord_mask, write_mask_size;
     struct vkd3d_string_buffer *read;
     enum vsir_data_type data_type;
-    unsigned int srv_binding;
+    unsigned int srv_binding = 0;
     struct msl_dst dst;
 
     if (vkd3d_shader_instruction_has_texel_offset(ins))
@@ -928,13 +927,10 @@ static void msl_ld(struct msl_generator *gen, const struct vkd3d_shader_instruct
     }
     coord_mask = vkd3d_write_mask_from_component_count(resource_type_info->coord_size);
 
-    if (!msl_get_srv_binding(gen, resource_space, resource_idx, resource_type, &srv_binding))
-    {
+    if (descriptor && !msl_get_srv_binding(gen, descriptor, resource_idx, &srv_binding))
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_BINDING_NOT_FOUND,
                 "No descriptor binding specified for SRV %u (index %u, space %u).",
                 resource_id, resource_idx, resource_space);
-        srv_binding = 0;
-    }
 
     msl_dst_init(&dst, gen, ins, &ins->dst[0]);
     read = vkd3d_string_buffer_get(&gen->string_buffers);
@@ -982,9 +978,9 @@ static void msl_sample(struct msl_generator *gen, const struct vkd3d_shader_inst
     const struct vkd3d_shader_src_param *resource, *sampler;
     unsigned int resource_id, resource_idx, resource_space;
     unsigned int sampler_id, sampler_idx, sampler_space;
+    unsigned int srv_binding = 0, sampler_binding = 0;
     const struct vkd3d_shader_descriptor_info1 *d;
     enum vkd3d_shader_resource_type resource_type;
-    unsigned int srv_binding, sampler_binding;
     uint32_t coord_mask, write_mask_size;
     struct vkd3d_string_buffer *sample;
     enum vsir_data_type data_type;
@@ -1052,13 +1048,10 @@ static void msl_sample(struct msl_generator *gen, const struct vkd3d_shader_inst
     }
     coord_mask = vkd3d_write_mask_from_component_count(resource_type_info->coord_size);
 
-    if (!msl_get_srv_binding(gen, resource_space, resource_idx, resource_type, &srv_binding))
-    {
+    if (d && !msl_get_srv_binding(gen, d, resource_idx, &srv_binding))
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_BINDING_NOT_FOUND,
                 "No descriptor binding specified for SRV %u (index %u, space %u).",
                 resource_id, resource_idx, resource_space);
-        srv_binding = 0;
-    }
 
     sampler_id = sampler->reg.idx[0].offset;
     sampler_idx = sampler->reg.idx[1].offset;
@@ -1088,13 +1081,10 @@ static void msl_sample(struct msl_generator *gen, const struct vkd3d_shader_inst
         sampler_space = 0;
     }
 
-    if (!msl_get_sampler_binding(gen, sampler_space, sampler_idx, &sampler_binding))
-    {
+    if (d && !msl_get_sampler_binding(gen, d, sampler_idx, &sampler_binding))
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_BINDING_NOT_FOUND,
                 "No descriptor binding specified for sampler %u (index %u, space %u).",
                 sampler_id, sampler_idx, sampler_space);
-        sampler_binding = 0;
-    }
 
     msl_dst_init(&dst, gen, ins, &ins->dst[0]);
     sample = vkd3d_string_buffer_get(&gen->string_buffers);
@@ -1191,7 +1181,7 @@ static void msl_store_uav_typed(struct msl_generator *gen, const struct vkd3d_sh
     unsigned int uav_id, uav_idx, uav_space;
     struct vkd3d_string_buffer *image_data;
     enum vsir_data_type data_type;
-    unsigned int uav_binding;
+    unsigned int uav_binding = 0;
     uint32_t coord_mask;
 
     if (ins->dst[0].reg.idx[0].rel_addr || ins->dst[0].reg.idx[1].rel_addr)
@@ -1229,13 +1219,10 @@ static void msl_store_uav_typed(struct msl_generator *gen, const struct vkd3d_sh
     }
     coord_mask = vkd3d_write_mask_from_component_count(resource_type_info->coord_size);
 
-    if (!msl_get_uav_binding(gen, uav_space, uav_idx, resource_type, &uav_binding))
-    {
+    if (d && !msl_get_uav_binding(gen, d, uav_idx, &uav_binding))
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_BINDING_NOT_FOUND,
                 "No descriptor binding specified for UAV %u (index %u, space %u).",
                 uav_id, uav_idx, uav_space);
-        uav_binding = 0;
-    }
 
     image_data = vkd3d_string_buffer_get(&gen->string_buffers);
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index aae5f6b5534..3950021a2ef 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -5813,7 +5813,7 @@ static void calculate_clip_or_cull_distance_mask(const struct signature_element
         return;
     }
 
-    write_mask = e->mask >> vsir_write_mask_get_component_idx(e->mask);
+    write_mask = e->mask;
     *mask |= (write_mask & VKD3DSP_WRITEMASK_ALL) << (VKD3D_VEC4_SIZE * e->semantic_index);
 }
 
@@ -6060,7 +6060,7 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler,
     if (use_private_variable)
     {
         compiler->private_output_variable[element_idx] = var_id;
-        compiler->private_output_variable_write_mask[element_idx] |= write_mask >> component_idx;
+        compiler->private_output_variable_write_mask[element_idx] |= write_mask;
         if (!compiler->epilogue_function_id)
             compiler->epilogue_function_id = vkd3d_spirv_alloc_id(builder);
     }
@@ -6112,9 +6112,6 @@ static void spirv_compiler_emit_store_shader_output(struct spirv_compiler *compi
             use_mask |= element->used_mask;
         }
     }
-    index = vsir_write_mask_get_component_idx(output->mask);
-    dst_write_mask >>= index;
-    use_mask >>= index;
     write_mask &= dst_write_mask;
 
     if (!write_mask)
@@ -6701,30 +6698,6 @@ static void spirv_compiler_emit_cbv_declaration(struct spirv_compiler *compiler,
     spirv_compiler_put_symbol(compiler, &reg_symbol);
 }
 
-static void spirv_compiler_emit_dcl_immediate_constant_buffer(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_instruction *instruction)
-{
-    const struct vkd3d_shader_immediate_constant_buffer *icb = instruction->declaration.icb;
-    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    uint32_t type_id, const_id, ptr_type_id, icb_id;
-    struct vkd3d_shader_register reg;
-    struct vkd3d_symbol reg_symbol;
-
-    const_id = spirv_compiler_emit_constant_array(compiler, icb, &type_id);
-    ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassPrivate, type_id);
-    icb_id = vkd3d_spirv_build_op_variable(builder, &builder->global_stream,
-            ptr_type_id, SpvStorageClassPrivate, const_id);
-    vkd3d_spirv_build_op_name(builder, icb_id, "icb");
-
-    /* Set an index count of 2 so vkd3d_symbol_make_register() uses idx[0] as a buffer id. */
-    vsir_register_init(&reg, VKD3DSPR_IMMCONSTBUFFER, VSIR_DATA_F32, 2);
-    reg.idx[0].offset = icb->register_idx;
-    vkd3d_symbol_make_register(&reg_symbol, &reg);
-    vkd3d_symbol_set_register_info(&reg_symbol, icb_id, SpvStorageClassPrivate,
-            icb->data_type, vkd3d_write_mask_from_component_count(icb->component_count));
-    spirv_compiler_put_symbol(compiler, &reg_symbol);
-}
-
 static void spirv_compiler_emit_sampler_declaration(struct spirv_compiler *compiler,
         const struct vkd3d_shader_register_range *range, const struct vkd3d_shader_descriptor_info1 *descriptor)
 {
@@ -10436,9 +10409,6 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VSIR_OP_DCL_INDEXABLE_TEMP:
             spirv_compiler_emit_dcl_indexable_temp(compiler, instruction);
             break;
-        case VSIR_OP_DCL_IMMEDIATE_CONSTANT_BUFFER:
-            spirv_compiler_emit_dcl_immediate_constant_buffer(compiler, instruction);
-            break;
         case VSIR_OP_DCL_TGSM_RAW:
             spirv_compiler_emit_dcl_tgsm_raw(compiler, instruction);
             break;
@@ -10885,6 +10855,36 @@ static void spirv_compiler_emit_descriptor_declarations(struct spirv_compiler *c
     }
 }
 
+static void spirv_compiler_emit_immediate_constant_buffers(struct spirv_compiler *compiler)
+{
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    const struct vkd3d_shader_immediate_constant_buffer *icb;
+    const struct vsir_program *program = compiler->program;
+    uint32_t type_id, const_id, ptr_type_id, icb_id;
+    struct vkd3d_shader_register reg;
+    struct vkd3d_symbol reg_symbol;
+    size_t i;
+
+    for (i = 0; i < program->icb_count; ++i)
+    {
+        icb = program->icbs[i];
+
+        const_id = spirv_compiler_emit_constant_array(compiler, icb, &type_id);
+        ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassPrivate, type_id);
+        icb_id = vkd3d_spirv_build_op_variable(builder, &builder->global_stream,
+                ptr_type_id, SpvStorageClassPrivate, const_id);
+        vkd3d_spirv_build_op_name(builder, icb_id, "icb%zu", icb->register_idx);
+
+        /* Set an index count of 2 so vkd3d_symbol_make_register() uses idx[0] as a buffer id. */
+        vsir_register_init(&reg, VKD3DSPR_IMMCONSTBUFFER, VSIR_DATA_F32, 2);
+        reg.idx[0].offset = icb->register_idx;
+        vkd3d_symbol_make_register(&reg_symbol, &reg);
+        vkd3d_symbol_set_register_info(&reg_symbol, icb_id, SpvStorageClassPrivate,
+                icb->data_type, vkd3d_write_mask_from_component_count(icb->component_count));
+        spirv_compiler_put_symbol(compiler, &reg_symbol);
+    }
+}
+
 static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
         const struct vkd3d_shader_compile_info *compile_info, struct vkd3d_shader_code *spirv)
 {
@@ -10918,6 +10918,7 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     spirv_compiler_emit_global_flags(compiler, program->global_flags);
 
     spirv_compiler_emit_descriptor_declarations(compiler);
+    spirv_compiler_emit_immediate_constant_buffers(compiler);
 
     compiler->spirv_parameter_info = vkd3d_calloc(program->parameter_count, sizeof(*compiler->spirv_parameter_info));
     for (i = 0; i < program->parameter_count; ++i)
-- 
2.51.0

