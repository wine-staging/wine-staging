From f6ccbf9518ca22514548ca078947750430f8ada7 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Sat, 18 Oct 2025 15:15:36 +1100
Subject: [PATCH] Updated vkd3d to 86b8f2de3546603c67e1f2828a68b1cd0aa049df.

---
 libs/vkd3d/libs/vkd3d-shader/glsl.c  | 31 ++------------------
 libs/vkd3d/libs/vkd3d-shader/ir.c    | 44 ++++++++++++++++++++++++----
 libs/vkd3d/libs/vkd3d-shader/msl.c   | 34 ++-------------------
 libs/vkd3d/libs/vkd3d-shader/spirv.c | 27 +++--------------
 4 files changed, 49 insertions(+), 87 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/glsl.c b/libs/vkd3d/libs/vkd3d-shader/glsl.c
index ab45c4d1e73..073282db129 100644
--- a/libs/vkd3d/libs/vkd3d-shader/glsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/glsl.c
@@ -392,7 +392,7 @@ static void shader_glsl_print_src(struct vkd3d_string_buffer *buffer, struct vkd
         const struct vkd3d_shader_src_param *vsir_src, uint32_t mask, enum vsir_data_type data_type)
 {
     const struct vkd3d_shader_register *reg = &vsir_src->reg;
-    struct vkd3d_string_buffer *register_name, *str;
+    struct vkd3d_string_buffer *register_name;
     enum vsir_data_type src_data_type;
     unsigned int size;
 
@@ -409,25 +409,11 @@ static void shader_glsl_print_src(struct vkd3d_string_buffer *buffer, struct vkd
 
     shader_glsl_print_register_name(register_name, gen, reg);
 
-    if (!vsir_src->modifiers)
-        str = buffer;
-    else
-        str = vkd3d_string_buffer_get(&gen->string_buffers);
-
     size = reg->dimension == VSIR_DIMENSION_VEC4 ? 4 : 1;
-    shader_glsl_print_bitcast(str, gen, register_name->buffer, data_type, src_data_type, size);
+    shader_glsl_print_bitcast(buffer, gen, register_name->buffer, data_type, src_data_type, size);
     if (reg->dimension == VSIR_DIMENSION_VEC4)
-        shader_glsl_print_swizzle(str, vsir_src->swizzle, mask);
+        shader_glsl_print_swizzle(buffer, vsir_src->swizzle, mask);
 
-    if (vsir_src->modifiers)
-    {
-        vkd3d_string_buffer_printf(buffer, "<unhandled modifier %#x>(%s)", vsir_src->modifiers, str->buffer);
-        vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
-                "Internal compiler error: Unhandled source modifier(s) %#x.", vsir_src->modifiers);
-    }
-
-    if (str != buffer)
-        vkd3d_string_buffer_release(&gen->string_buffers, str);
     vkd3d_string_buffer_release(&gen->string_buffers, register_name);
 }
 
@@ -489,23 +475,14 @@ static void VKD3D_PRINTF_FUNC(4, 0) shader_glsl_vprint_assignment(struct vkd3d_g
         struct glsl_dst *dst, enum vsir_data_type data_type, const char *format, va_list args)
 {
     struct vkd3d_string_buffer *buffer = gen->buffer;
-    uint32_t modifiers = dst->vsir->modifiers;
     bool close = true;
 
-    /* It is always legitimate to ignore _pp. */
-    modifiers &= ~VKD3DSPDM_PARTIALPRECISION;
-
     if (dst->vsir->shift)
         vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
                 "Internal compiler error: Unhandled destination shift %#x.", dst->vsir->shift);
-    if (modifiers & ~VKD3DSPDM_SATURATE)
-        vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
-                "Internal compiler error: Unhandled destination modifier(s) %#x.", modifiers);
 
     shader_glsl_print_indent(buffer, gen->indent);
     vkd3d_string_buffer_printf(buffer, "%s%s = ", dst->register_name->buffer, dst->mask->buffer);
-    if (modifiers & VKD3DSPDM_SATURATE)
-        vkd3d_string_buffer_printf(buffer, "clamp(");
 
     switch (data_type)
     {
@@ -530,8 +507,6 @@ static void VKD3D_PRINTF_FUNC(4, 0) shader_glsl_vprint_assignment(struct vkd3d_g
 
     if (close)
         vkd3d_string_buffer_printf(buffer, ")");
-    if (modifiers & VKD3DSPDM_SATURATE)
-        vkd3d_string_buffer_printf(buffer, ", 0.0, 1.0)");
     vkd3d_string_buffer_printf(buffer, ";\n");
 }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index 82901c6fb34..000c78aeed3 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -2173,6 +2173,7 @@ static enum vkd3d_result vsir_program_lower_modifiers(struct vsir_program *progr
 {
     struct vsir_program_iterator it = vsir_program_iterator(&program->instructions), new_it;
     struct vkd3d_shader_instruction *ins, *new_ins;
+    enum vkd3d_result ret = VKD3D_OK;
     unsigned int i, j;
 
     for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
@@ -2182,9 +2183,11 @@ static enum vkd3d_result vsir_program_lower_modifiers(struct vsir_program *progr
             enum vkd3d_shader_opcode new_opcodes[2] = {VSIR_OP_NOP, VSIR_OP_NOP};
             struct vkd3d_shader_src_param *src = &ins->src[i];
 
-            /* TODO: support other modifiers, including destination modifiers. */
             switch (src->modifiers)
             {
+                case VKD3DSPSM_NONE:
+                    continue;
+
                 case VKD3DSPSM_ABS:
                     new_opcodes[0] = VSIR_OP_ABS;
                     break;
@@ -2199,6 +2202,9 @@ static enum vkd3d_result vsir_program_lower_modifiers(struct vsir_program *progr
                     break;
 
                 default:
+                    vkd3d_shader_error(ctx->message_context, &ins->location, VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED,
+                            "Aborting due to unimplemented feature: Source modifier %#x.", src->modifiers);
+                    ret = VKD3D_ERROR_NOT_IMPLEMENTED;
                     continue;
             }
 
@@ -2234,12 +2240,23 @@ static enum vkd3d_result vsir_program_lower_modifiers(struct vsir_program *progr
         {
             struct vkd3d_shader_dst_param *dst = &ins->dst[i];
 
+            /* It is always legitimate to ignore _pp. */
+            dst->modifiers &= ~VKD3DSPDM_PARTIALPRECISION;
+
+            if (dst->modifiers & ~VKD3DSPDM_SATURATE)
+            {
+                vkd3d_shader_error(ctx->message_context, &ins->location, VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED,
+                        "Aborting due to unimplemented feature: Destination modifier %#x.", dst->modifiers);
+                ret = VKD3D_ERROR_NOT_IMPLEMENTED;
+                continue;
+            }
+
             if (dst->modifiers & VKD3DSPDM_SATURATE)
             {
                 if (!vsir_program_iterator_insert_after(&it, 1))
                     return VKD3D_ERROR_OUT_OF_MEMORY;
-                ins = vsir_program_iterator_current(&it);
                 new_ins = vsir_program_iterator_next(&it);
+                ins = vsir_program_iterator_prev(&it);
 
                 if (!vsir_instruction_init_with_params(program, new_ins, &ins->location, VSIR_OP_SATURATE, 1, 1))
                 {
@@ -2248,7 +2265,7 @@ static enum vkd3d_result vsir_program_lower_modifiers(struct vsir_program *progr
                 }
 
                 new_ins->dst[0] = *dst;
-                new_ins->dst[0].modifiers &= ~VKD3DSPDM_NONE;
+                new_ins->dst[0].modifiers &= ~VKD3DSPDM_SATURATE;
 
                 dst_param_init_ssa(dst, program->ssa_count, dst->reg.data_type, dst->reg.dimension);
                 src_param_init_ssa(&new_ins->src[0], program->ssa_count, dst->reg.data_type, dst->reg.dimension);
@@ -2264,7 +2281,7 @@ static enum vkd3d_result vsir_program_lower_modifiers(struct vsir_program *progr
         }
     }
 
-    return VKD3D_OK;
+    return ret;
 }
 
 static enum vkd3d_result vsir_program_lower_instructions(struct vsir_program *program,
@@ -5064,6 +5081,7 @@ static enum vkd3d_result vsir_program_materialise_phi_ssas_to_temps_in_function(
     for (ins = vsir_program_iterator_current(it); ins; ins = vsir_program_iterator_next(it))
     {
         struct vkd3d_shader_instruction *mov_ins;
+        struct vkd3d_shader_location loc;
         bool finish = false;
         size_t j;
 
@@ -5083,6 +5101,7 @@ static enum vkd3d_result vsir_program_materialise_phi_ssas_to_temps_in_function(
             case VSIR_OP_SWITCH_MONOLITHIC:
                 info = &block_info[current_label - 1];
 
+                loc = ins->location;
                 if (!(mov_ins = vsir_program_iterator_insert_before_and_move(it, info->incoming_count)))
                     goto fail;
                 VKD3D_ASSERT(mov_ins);
@@ -5091,7 +5110,7 @@ static enum vkd3d_result vsir_program_materialise_phi_ssas_to_temps_in_function(
                 {
                     struct phi_incoming_to_temp *incoming = &info->incomings[j];
 
-                    if (!vsir_instruction_init_with_params(program, mov_ins, &ins->location, VSIR_OP_MOV, 1, 0))
+                    if (!vsir_instruction_init_with_params(program, mov_ins, &loc, VSIR_OP_MOV, 1, 0))
                     {
                         vkd3d_shader_instruction_make_nop(mov_ins);
                         goto fail;
@@ -9311,6 +9330,7 @@ struct temp_allocator
         enum vkd3d_shader_register_type type;
         unsigned int idx;
         bool force_first;
+        bool fixed_mask;
     } *ssa_regs, *temp_regs;
     size_t ssa_count, temp_count;
     unsigned int new_temp_count;
@@ -9339,6 +9359,9 @@ static void temp_allocator_set_src(struct temp_allocator *allocator, struct vkd3
     src->reg.type = VKD3DSPR_TEMP;
     src->reg.dimension = VSIR_DIMENSION_VEC4;
     src->reg.idx[0].offset = reg->temp_id;
+
+    if (reg->fixed_mask)
+        return;
     src->swizzle = vsir_combine_swizzles(vsir_swizzle_from_writemask(reg->allocated_mask), src->swizzle);
 }
 
@@ -9430,7 +9453,16 @@ static void temp_allocator_set_dst(struct temp_allocator *allocator,
     dst->reg.type = VKD3DSPR_TEMP;
     dst->reg.dimension = VSIR_DIMENSION_VEC4;
     dst->reg.idx[0].offset = reg->temp_id;
+
+    if (reg->fixed_mask)
+    {
+        VKD3D_ASSERT((reg->allocated_mask & dst->write_mask) == dst->write_mask);
+        return;
+    }
+
     remapped_mask = vsir_combine_write_masks(reg->allocated_mask, dst->write_mask);
+    VKD3D_ASSERT(vkd3d_popcount(remapped_mask) == vkd3d_popcount(dst->write_mask));
+
     if (dst->write_mask != remapped_mask)
     {
         dst->write_mask = remapped_mask;
@@ -9508,6 +9540,7 @@ static void temp_allocator_open_register(struct temp_allocator *allocator, struc
             {
                 reg->temp_id = i;
                 reg->allocated_mask = liveness_reg->mask;
+                reg->fixed_mask = true;
                 current_allocation[i] |= reg->allocated_mask;
                 allocator->new_temp_count = max(allocator->new_temp_count, i + 1);
                 TRACE("Allocated r%u%s for %s (liveness %u-%u).\n",
@@ -9534,6 +9567,7 @@ static void temp_allocator_open_register(struct temp_allocator *allocator, struc
 
                 reg->temp_id = i;
                 reg->allocated_mask = vsir_combine_write_masks(available_mask, mask);
+                reg->fixed_mask = false;
                 current_allocation[i] |= reg->allocated_mask;
                 allocator->new_temp_count = max(allocator->new_temp_count, i + 1);
                 TRACE("Allocated r%u%s for %s (liveness %u-%u).\n",
diff --git a/libs/vkd3d/libs/vkd3d-shader/msl.c b/libs/vkd3d/libs/vkd3d-shader/msl.c
index f2d28acbe38..3e7bf831e48 100644
--- a/libs/vkd3d/libs/vkd3d-shader/msl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/msl.c
@@ -583,7 +583,7 @@ static void msl_print_src_with_type(struct vkd3d_string_buffer *buffer, struct m
     const struct vkd3d_shader_src_param *vsir_src, uint32_t mask, enum vsir_data_type data_type)
 {
     const struct vkd3d_shader_register *reg = &vsir_src->reg;
-    struct vkd3d_string_buffer *register_name, *str;
+    struct vkd3d_string_buffer *register_name;
     enum msl_data_type src_data_type;
 
     register_name = vkd3d_string_buffer_get(&gen->string_buffers);
@@ -592,25 +592,10 @@ static void msl_print_src_with_type(struct vkd3d_string_buffer *buffer, struct m
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
                 "Internal compiler error: Unhandled 'non-uniform' modifier.");
 
-    if (!vsir_src->modifiers)
-        str = buffer;
-    else
-        str = vkd3d_string_buffer_get(&gen->string_buffers);
-
     src_data_type = msl_print_register_name(register_name, gen, reg);
-    msl_print_bitcast(str, gen, register_name->buffer, data_type, src_data_type, reg->dimension);
+    msl_print_bitcast(buffer, gen, register_name->buffer, data_type, src_data_type, reg->dimension);
     if (reg->dimension == VSIR_DIMENSION_VEC4)
-        msl_print_swizzle(str, vsir_src->swizzle, mask);
-
-    if (vsir_src->modifiers)
-    {
-        vkd3d_string_buffer_printf(buffer, "<unhandled modifier %#x>(%s)", vsir_src->modifiers, str->buffer);
-        msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
-                "Internal compiler error: Unhandled source modifier(s) %#x.", vsir_src->modifiers);
-    }
-
-    if (str != buffer)
-        vkd3d_string_buffer_release(&gen->string_buffers, str);
+        msl_print_swizzle(buffer, vsir_src->swizzle, mask);
 }
 
 static void msl_src_init(struct msl_src *msl_src, struct msl_generator *gen,
@@ -674,32 +659,19 @@ static void msl_print_subscript(struct vkd3d_string_buffer *buffer, struct msl_g
 static void VKD3D_PRINTF_FUNC(3, 4) msl_print_assignment(
         struct msl_generator *gen, struct msl_dst *dst, const char *format, ...)
 {
-    uint32_t modifiers = dst->vsir->modifiers;
     va_list args;
 
-    /* It is always legitimate to ignore _pp. */
-    modifiers &= ~VKD3DSPDM_PARTIALPRECISION;
-
     if (dst->vsir->shift)
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
                 "Internal compiler error: Unhandled destination shift %#x.", dst->vsir->shift);
-    if (modifiers & ~VKD3DSPDM_SATURATE)
-        msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
-                "Internal compiler error: Unhandled destination modifier(s) %#x.", modifiers);
 
     msl_print_indent(gen->buffer, gen->indent);
     vkd3d_string_buffer_printf(gen->buffer, "%s%s = ", dst->register_name->buffer, dst->mask->buffer);
 
-    if (modifiers & VKD3DSPDM_SATURATE)
-        vkd3d_string_buffer_printf(gen->buffer, "saturate(");
-
     va_start(args, format);
     vkd3d_string_buffer_vprintf(gen->buffer, format, args);
     va_end(args);
 
-    if (modifiers & VKD3DSPDM_SATURATE)
-        vkd3d_string_buffer_printf(gen->buffer, ")");
-
     vkd3d_string_buffer_printf(gen->buffer, ";\n");
 }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index a1572f69438..0f5df228121 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -4823,10 +4823,6 @@ static void spirv_compiler_emit_execution_mode1(struct spirv_compiler *compiler,
 static uint32_t spirv_compiler_emit_load_src(struct spirv_compiler *compiler,
         const struct vkd3d_shader_src_param *src, uint32_t write_mask)
 {
-    if (src->modifiers)
-        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
-                "Unhandled source modifier(s) %#x.", src->modifiers);
-
     return spirv_compiler_emit_load_reg(compiler, &src->reg, src->swizzle, write_mask);
 }
 
@@ -4981,25 +4977,6 @@ static uint32_t spirv_compiler_emit_sat(struct spirv_compiler *compiler,
 static void spirv_compiler_emit_store_dst(struct spirv_compiler *compiler,
         const struct vkd3d_shader_dst_param *dst, uint32_t val_id)
 {
-    uint32_t modifiers = dst->modifiers;
-
-    /* It is always legitimate to ignore _pp. */
-    modifiers &= ~VKD3DSPDM_PARTIALPRECISION;
-
-    if (modifiers & VKD3DSPDM_SATURATE)
-    {
-        val_id = spirv_compiler_emit_sat(compiler, &dst->reg, dst->write_mask, val_id);
-        modifiers &= ~VKD3DSPDM_SATURATE;
-    }
-
-    if (dst->modifiers & VKD3DSPDM_MSAMPCENTROID)
-    {
-        FIXME("Ignoring _centroid modifier.\n");
-        modifiers &= ~VKD3DSPDM_MSAMPCENTROID;
-    }
-
-    VKD3D_ASSERT(!modifiers);
-
     spirv_compiler_emit_store_reg(compiler, &dst->reg, dst->write_mask, val_id);
 }
 
@@ -11052,7 +11029,11 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     }
 
     if (compiler->failed)
+    {
+        vkd3d_shader_free_shader_code(spirv);
+
         return VKD3D_ERROR_INVALID_SHADER;
+    }
 
     if (compile_info->target_type == VKD3D_SHADER_TARGET_SPIRV_TEXT)
     {
-- 
2.51.0

