From b81eed1086ba3660ec00639862986ca4544f462f Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 30 Jul 2025 08:46:04 +1000
Subject: [PATCH] Updated vkd3d to bb2979aa4c3432bfd5b30ae23de8aaaa57e04c6a.

---
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c        | 19 +++--
 libs/vkd3d/libs/vkd3d-shader/hlsl.c           | 64 +++++++++------
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c   | 79 ++++++++-----------
 libs/vkd3d/libs/vkd3d-shader/ir.c             | 30 ++++---
 libs/vkd3d/libs/vkd3d-shader/spirv.c          | 16 ++--
 libs/vkd3d/libs/vkd3d-shader/tpf.c            |  1 -
 .../libs/vkd3d-shader/vkd3d_shader_main.c     | 17 ++--
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |  9 +++
 8 files changed, 136 insertions(+), 99 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index c213007f2b4..2ec9a74249b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -156,6 +156,8 @@ static void shader_dump_atomic_op_flags(struct vkd3d_d3d_asm_compiler *compiler,
         atomic_flags &= ~VKD3DARF_VOLATILE;
     }
 
+    atomic_flags &= ~VKD3DSI_PRECISE_XYZW;
+
     if (atomic_flags)
         vkd3d_string_buffer_printf(&compiler->buffer, "_unknown_flags(%#x)", atomic_flags);
 }
@@ -183,6 +185,8 @@ static void shader_dump_sync_flags(struct vkd3d_d3d_asm_compiler *compiler, uint
         sync_flags &= ~VKD3DSSF_THREAD_GROUP;
     }
 
+    sync_flags &= ~VKD3DSI_PRECISE_XYZW;
+
     if (sync_flags)
         vkd3d_string_buffer_printf(&compiler->buffer, "_unknown_flags(%#x)", sync_flags);
 }
@@ -1332,7 +1336,7 @@ static void shader_dump_instruction_flags(struct vkd3d_d3d_asm_compiler *compile
             break;
 
         case VSIR_OP_RESINFO:
-            switch (ins->flags)
+            switch (ins->flags & ~VKD3DSI_PRECISE_XYZW)
             {
                 case VKD3DSI_NONE:
                     break;
@@ -1349,7 +1353,7 @@ static void shader_dump_instruction_flags(struct vkd3d_d3d_asm_compiler *compile
             break;
 
         case VSIR_OP_SAMPLE_INFO:
-            switch (ins->flags)
+            switch (ins->flags & ~VKD3DSI_PRECISE_XYZW)
             {
                 case VKD3DSI_NONE:
                     break;
@@ -1405,9 +1409,9 @@ static void shader_dump_instruction_flags(struct vkd3d_d3d_asm_compiler *compile
         case VSIR_OP_USHR:
             if (ins->flags & VKD3DSI_SHIFT_UNMASKED)
                 vkd3d_string_buffer_printf(buffer, "_unmasked");
-            /* fall through */
+            break;
+
         default:
-            shader_dump_precise_flags(compiler, ins->flags);
             break;
     }
 }
@@ -1664,9 +1668,14 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
         default:
             shader_dump_instruction_flags(compiler, ins);
 
+            if (ins->resource_type != VKD3D_SHADER_RESOURCE_NONE)
+                vkd3d_string_buffer_printf(buffer, "_indexable");
+
+            shader_dump_precise_flags(compiler, ins->flags);
+
             if (ins->resource_type != VKD3D_SHADER_RESOURCE_NONE)
             {
-                vkd3d_string_buffer_printf(buffer, "_indexable(");
+                vkd3d_string_buffer_printf(buffer, "(");
                 if (ins->raw)
                     vkd3d_string_buffer_printf(buffer, "raw_");
                 if (ins->structured)
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index a089651eaf7..113ac760731 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -5011,19 +5011,12 @@ static void hlsl_ctx_cleanup(struct hlsl_ctx *ctx)
     vkd3d_free(ctx->constant_defs.regs);
 }
 
-int hlsl_compile_shader(const struct vkd3d_shader_compile_info *compile_info,
-        struct vkd3d_shader_message_context *message_context, struct vkd3d_shader_code *out)
+static int hlsl_ctx_parse(struct hlsl_ctx *ctx, const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_message_context *message_context)
 {
     enum vkd3d_shader_target_type target_type = compile_info->target_type;
     const struct vkd3d_shader_hlsl_source_info *hlsl_source_info;
-    uint64_t config_flags = vkd3d_shader_init_config_flags();
-    struct hlsl_ir_function_decl *decl, *entry_func = NULL;
-    struct vkd3d_shader_code reflection_data = {0};
     const struct hlsl_profile_info *profile;
-    struct hlsl_ir_function *func;
-    struct vsir_program program;
-    const char *entry_point;
-    struct hlsl_ctx ctx;
     int ret;
 
     if (!(hlsl_source_info = vkd3d_find_struct(compile_info->next, HLSL_SOURCE_INFO)))
@@ -5031,7 +5024,6 @@ int hlsl_compile_shader(const struct vkd3d_shader_compile_info *compile_info,
         ERR("No HLSL source info given.\n");
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
-    entry_point = hlsl_source_info->entry_point ? hlsl_source_info->entry_point : "main";
 
     if (!(profile = hlsl_get_target_info(hlsl_source_info->profile)))
     {
@@ -5064,37 +5056,65 @@ int hlsl_compile_shader(const struct vkd3d_shader_compile_info *compile_info,
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
-    if (!hlsl_ctx_init(&ctx, compile_info, profile, message_context))
+    if (!hlsl_ctx_init(ctx, compile_info, profile, message_context))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    if ((ret = hlsl_lexer_compile(&ctx, &compile_info->source)) == 2)
+    if ((ret = hlsl_lexer_compile(ctx, &compile_info->source)) == 2)
     {
-        hlsl_ctx_cleanup(&ctx);
+        hlsl_ctx_cleanup(ctx);
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
 
-    if (ctx.result)
+    if (ctx->result)
     {
-        hlsl_ctx_cleanup(&ctx);
-        return ctx.result;
+        hlsl_ctx_cleanup(ctx);
+        return ctx->result;
     }
 
     /* If parsing failed without an error condition being recorded, we
      * plausibly hit some unimplemented feature. */
     if (ret)
     {
-        hlsl_ctx_cleanup(&ctx);
+        hlsl_ctx_cleanup(ctx);
         return VKD3D_ERROR_NOT_IMPLEMENTED;
     }
 
-    if (ctx.profile->type == VKD3D_SHADER_TYPE_EFFECT)
-    {
-        ret = hlsl_emit_effect_binary(&ctx, out);
+    return VKD3D_OK;
+}
 
-        hlsl_ctx_cleanup(&ctx);
+int hlsl_compile_effect(const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_message_context *message_context, struct vkd3d_shader_code *out)
+{
+    struct hlsl_ctx ctx;
+    int ret;
+
+    if ((ret = hlsl_ctx_parse(&ctx, compile_info, message_context)) < 0)
         return ret;
-    }
 
+    ret = hlsl_emit_effect_binary(&ctx, out);
+    hlsl_ctx_cleanup(&ctx);
+
+    return ret;
+}
+
+int hlsl_compile_shader(const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_message_context *message_context, struct vkd3d_shader_code *out)
+{
+    const struct vkd3d_shader_hlsl_source_info *hlsl_source_info;
+    uint64_t config_flags = vkd3d_shader_init_config_flags();
+    struct hlsl_ir_function_decl *decl, *entry_func = NULL;
+    struct vkd3d_shader_code reflection_data = {0};
+    struct hlsl_ir_function *func;
+    struct vsir_program program;
+    const char *entry_point;
+    struct hlsl_ctx ctx;
+    int ret;
+
+    if ((ret = hlsl_ctx_parse(&ctx, compile_info, message_context)) < 0)
+        return ret;
+
+    hlsl_source_info = vkd3d_find_struct(compile_info->next, HLSL_SOURCE_INFO);
+    entry_point = hlsl_source_info->entry_point ? hlsl_source_info->entry_point : "main";
     if ((func = hlsl_get_function(&ctx, entry_point)))
     {
         LIST_FOR_EACH_ENTRY(decl, &func->overloads, struct hlsl_ir_function_decl, entry)
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index e3ca1b25eb9..0b28aa6fe80 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -7549,6 +7549,8 @@ static void parse_entry_function_attributes(struct hlsl_ctx *ctx, struct hlsl_ir
             entry_func->early_depth_test = true;
         else if (!strcmp(attr->name, "maxvertexcount") && profile->type == VKD3D_SHADER_TYPE_GEOMETRY)
             parse_maxvertexcount_attribute(ctx, attr);
+        else if (!strcmp(attr->name, "instance") && profile->type == VKD3D_SHADER_TYPE_GEOMETRY)
+            hlsl_fixme(ctx, &entry_func->attrs[i]->loc, "Geometry shader instance count");
         else
             hlsl_warning(ctx, &entry_func->attrs[i]->loc, VKD3D_SHADER_WARNING_HLSL_UNKNOWN_ATTRIBUTE,
                     "Ignoring unknown attribute \"%s\".", entry_func->attrs[i]->name);
@@ -9610,25 +9612,13 @@ static void sm1_generate_vsir(struct hlsl_ctx *ctx, const struct vkd3d_shader_co
         struct hlsl_ir_function_decl *func, struct list *semantic_vars,
         struct hlsl_block *body, uint64_t config_flags, struct vsir_program *program)
 {
-    struct vkd3d_shader_version version = {0};
     struct hlsl_block block;
 
-    version.major = ctx->profile->major_version;
-    version.minor = ctx->profile->minor_version;
-    version.type = ctx->profile->type;
-    if (!vsir_program_init(program, compile_info, &version, 0, VSIR_CF_STRUCTURED, VSIR_NORMALISED_SM4))
-    {
-        ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
-        return;
-    }
-
     program->ssa_count = 0;
     program->temp_count = allocate_temp_registers(ctx, body, semantic_vars);
     if (ctx->result)
         return;
 
-    generate_vsir_signature(ctx, program, func, semantic_vars);
-
     hlsl_block_init(&block);
     sm1_generate_vsir_constant_defs(ctx, program, &block);
     sm1_generate_vsir_sampler_dcls(ctx, program, &block);
@@ -12345,32 +12335,18 @@ static void sm4_generate_vsir(struct hlsl_ctx *ctx,
         struct list *semantic_vars, struct hlsl_block *body, struct list *patch_semantic_vars,
         struct hlsl_block *patch_body, uint64_t config_flags, struct vsir_program *program)
 {
-    struct vkd3d_shader_version version = {0};
+    const struct vkd3d_shader_version *version = &program->shader_version;
     struct extern_resource *extern_resources;
     unsigned int extern_resources_count;
     const struct hlsl_buffer *cbuffer;
 
-    version.major = ctx->profile->major_version;
-    version.minor = ctx->profile->minor_version;
-    version.type = ctx->profile->type;
-
-    if (!vsir_program_init(program, compile_info, &version, 0, VSIR_CF_STRUCTURED, VSIR_NORMALISED_SM4))
-    {
-        ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
-        return;
-    }
-
-    generate_vsir_signature(ctx, program, func, semantic_vars);
-    if (version.type == VKD3D_SHADER_TYPE_HULL)
-        generate_vsir_signature(ctx, program, ctx->patch_constant_func, patch_semantic_vars);
-
-    if (version.type == VKD3D_SHADER_TYPE_COMPUTE)
+    if (version->type == VKD3D_SHADER_TYPE_COMPUTE)
     {
         program->thread_group_size.x = ctx->thread_count[0];
         program->thread_group_size.y = ctx->thread_count[1];
         program->thread_group_size.z = ctx->thread_count[2];
     }
-    else if (version.type == VKD3D_SHADER_TYPE_HULL)
+    else if (version->type == VKD3D_SHADER_TYPE_HULL)
     {
         program->input_control_point_count = ctx->input_control_point_count == UINT_MAX
                 ? 1 : ctx->input_control_point_count;
@@ -12379,13 +12355,13 @@ static void sm4_generate_vsir(struct hlsl_ctx *ctx,
         program->tess_partitioning = ctx->partitioning;
         program->tess_output_primitive = ctx->output_primitive;
     }
-    else if (version.type == VKD3D_SHADER_TYPE_DOMAIN)
+    else if (version->type == VKD3D_SHADER_TYPE_DOMAIN)
     {
         program->input_control_point_count = ctx->input_control_point_count == UINT_MAX
                 ? 0 : ctx->input_control_point_count;
         program->tess_domain = ctx->domain;
     }
-    else if (version.type == VKD3D_SHADER_TYPE_GEOMETRY)
+    else if (version->type == VKD3D_SHADER_TYPE_GEOMETRY)
     {
         program->input_control_point_count = ctx->input_control_point_count;
         program->input_primitive = ctx->input_primitive_type;
@@ -12413,7 +12389,7 @@ static void sm4_generate_vsir(struct hlsl_ctx *ctx,
     }
     sm4_free_extern_resources(extern_resources, extern_resources_count);
 
-    if (version.type == VKD3D_SHADER_TYPE_GEOMETRY && version.major >= 5)
+    if (version->type == VKD3D_SHADER_TYPE_GEOMETRY && version->major >= 5)
     {
         const struct hlsl_ir_var *var;
 
@@ -12426,11 +12402,11 @@ static void sm4_generate_vsir(struct hlsl_ctx *ctx,
 
     program->ssa_count = 0;
 
-    if (version.type == VKD3D_SHADER_TYPE_HULL)
+    if (version->type == VKD3D_SHADER_TYPE_HULL)
         generate_vsir_add_program_instruction(ctx, program,
                 &ctx->patch_constant_func->loc, VSIR_OP_HS_CONTROL_POINT_PHASE, 0, 0);
     sm4_generate_vsir_add_function(ctx, semantic_vars, func, body, config_flags, program);
-    if (version.type == VKD3D_SHADER_TYPE_HULL)
+    if (version->type == VKD3D_SHADER_TYPE_HULL)
     {
         generate_vsir_add_program_instruction(ctx, program,
                 &ctx->patch_constant_func->loc, VSIR_OP_HS_FORK_PHASE, 0, 0);
@@ -13912,6 +13888,7 @@ int hlsl_emit_vsir(struct hlsl_ctx *ctx, const struct vkd3d_shader_compile_info
     uint32_t config_flags = vkd3d_shader_init_config_flags();
     const struct hlsl_profile_info *profile = ctx->profile;
     struct list semantic_vars, patch_semantic_vars;
+    struct vkd3d_shader_version version = {0};
     struct hlsl_ir_var *var;
 
     parse_entry_function_attributes(ctx, entry_func);
@@ -13980,28 +13957,38 @@ int hlsl_emit_vsir(struct hlsl_ctx *ctx, const struct vkd3d_shader_compile_info
     if (ctx->result)
         return ctx->result;
 
-    if (ctx->profile->major_version < 4)
+    version.major = ctx->profile->major_version;
+    version.minor = ctx->profile->minor_version;
+    version.type = ctx->profile->type;
+    if (!vsir_program_init(program, compile_info, &version, 0, VSIR_CF_STRUCTURED, VSIR_NORMALISED_SM4))
     {
-        sm1_generate_ctab(ctx, reflection_data);
-        if (ctx->result)
-            return ctx->result;
-
-        sm1_generate_vsir(ctx, compile_info, entry_func, &semantic_vars, &body, config_flags, program);
+        ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
+        return ctx->result;
     }
+
+    generate_vsir_signature(ctx, program, entry_func, &semantic_vars);
+    if (version.type == VKD3D_SHADER_TYPE_HULL)
+        generate_vsir_signature(ctx, program, ctx->patch_constant_func, &patch_semantic_vars);
+
+    if (version.major < 4)
+        sm1_generate_ctab(ctx, reflection_data);
     else
-    {
         sm4_generate_rdef(ctx, reflection_data);
-        if (ctx->result)
-            return ctx->result;
+    if (ctx->result)
+    {
+        vsir_program_cleanup(program);
+        return ctx->result;
+    }
 
+    if (version.major < 4)
+        sm1_generate_vsir(ctx, compile_info, entry_func, &semantic_vars, &body, config_flags, program);
+    else
         sm4_generate_vsir(ctx, compile_info, entry_func, &semantic_vars, &body,
                 &patch_semantic_vars, &patch_body, config_flags, program);
-    }
-
     if (ctx->result)
     {
-        vsir_program_cleanup(program);
         vkd3d_shader_free_shader_code(reflection_data);
+        vsir_program_cleanup(program);
     }
 
     return ctx->result;
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index c3bcf9058e1..1098e4d3950 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -903,14 +903,13 @@ static bool get_opcode_from_rel_op(enum vkd3d_shader_rel_op rel_op,
 static enum vkd3d_result vsir_program_normalize_addr(struct vsir_program *program,
         struct vsir_transformation_context *ctx)
 {
+    struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
     struct vkd3d_shader_instruction *ins, *ins2;
     unsigned int tmp_idx = ~0u;
-    unsigned int i, k, r;
+    unsigned int k, r;
 
-    for (i = 0; i < program->instructions.count; ++i)
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
     {
-        ins = &program->instructions.elements[i];
-
         if (ins->opcode == VSIR_OP_MOV && ins->dst[0].reg.type == VKD3DSPR_ADDR)
         {
             if (tmp_idx == ~0u)
@@ -926,16 +925,16 @@ static enum vkd3d_result vsir_program_normalize_addr(struct vsir_program *progra
             if (tmp_idx == ~0u)
                 tmp_idx = program->temp_count++;
 
-            if (!shader_instruction_array_insert_at(&program->instructions, i + 1, 1))
+            if (!vsir_program_iterator_insert_after(&it, 1))
                 return VKD3D_ERROR_OUT_OF_MEMORY;
-            ins = &program->instructions.elements[i];
-            ins2 = &program->instructions.elements[i + 1];
+            ins = vsir_program_iterator_current(&it);
 
             ins->opcode = VSIR_OP_ROUND_NE;
             vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VSIR_DATA_F32, 1);
             ins->dst[0].reg.idx[0].offset = tmp_idx;
             ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
 
+            ins2 = vsir_program_iterator_next(&it);
             if (!vsir_instruction_init_with_params(program, ins2, &ins->location, VSIR_OP_FTOU, 1, 1))
                 return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1741,14 +1740,21 @@ static enum vkd3d_result vsir_program_lower_instructions(struct vsir_program *pr
 static enum vkd3d_result vsir_program_ensure_ret(struct vsir_program *program,
         struct vsir_transformation_context *ctx)
 {
+    struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
     static const struct vkd3d_shader_location no_loc;
-    if (program->instructions.count
-            && program->instructions.elements[program->instructions.count - 1].opcode == VSIR_OP_RET)
+    struct vkd3d_shader_instruction *ins;
+
+    ins = vsir_program_iterator_tail(&it);
+
+    if (ins && ins->opcode == VSIR_OP_RET)
         return VKD3D_OK;
 
-    if (!shader_instruction_array_insert_at(&program->instructions, program->instructions.count, 1))
+    if (!vsir_program_iterator_insert_after(&it, 1))
         return VKD3D_ERROR_OUT_OF_MEMORY;
-    vsir_instruction_init(&program->instructions.elements[program->instructions.count - 1], &no_loc, VSIR_OP_RET);
+
+    ins = vsir_program_iterator_next(&it);
+    vsir_instruction_init(ins, &no_loc, VSIR_OP_RET);
+
     return VKD3D_OK;
 }
 
@@ -9592,7 +9598,7 @@ static void vsir_validate_register(struct validation_context *ctx,
         [VKD3DSPR_LOCALTHREADINDEX] = {true, 0, VSIR_DIMENSION_VEC4},
         [VKD3DSPR_COVERAGE]         = {true, 0, VSIR_DIMENSION_VEC4},
         [VKD3DSPR_SAMPLEMASK]       = {true, 0, VSIR_DIMENSION_SCALAR},
-        [VKD3DSPR_GSINSTID]         = {true, 0, VSIR_DIMENSION_SCALAR},
+        [VKD3DSPR_GSINSTID]         = {true, 0, VSIR_DIMENSION_VEC4},
         [VKD3DSPR_DEPTHOUTGE]       = {true, 0, VSIR_DIMENSION_SCALAR},
         [VKD3DSPR_DEPTHOUTLE]       = {true, 0, VSIR_DIMENSION_SCALAR},
         [VKD3DSPR_OUTSTENCILREF]    = {true, 0, VSIR_DIMENSION_SCALAR},
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index 8400db85084..4f50eadf714 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -9938,9 +9938,9 @@ static void spirv_compiler_emit_resinfo(struct spirv_compiler *compiler,
     struct vkd3d_shader_image image;
     bool supports_mipmaps;
 
-    if (instruction->flags & ~VKD3DSI_RESINFO_UINT)
-        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
-                "Unhandled resinfo flags %#x.\n", instruction->flags & ~VKD3DSI_RESINFO_UINT);
+    if (instruction->flags & ~(VKD3DSI_RESINFO_UINT | VKD3DSI_PRECISE_XYZW))
+        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED, "Unhandled resinfo flags %#x.\n",
+                instruction->flags & ~(VKD3DSI_RESINFO_UINT | VKD3DSI_PRECISE_XYZW));
 
     vkd3d_spirv_enable_capability(builder, SpvCapabilityImageQuery);
 
@@ -9978,6 +9978,8 @@ static void spirv_compiler_emit_resinfo(struct spirv_compiler *compiler,
         component_type = VKD3D_SHADER_COMPONENT_FLOAT;
         type_id = vkd3d_spirv_get_type_id(builder, component_type, VKD3D_VEC4_SIZE);
         val_id = vkd3d_spirv_build_op_convert_utof(builder, type_id, val_id);
+        if (instruction->flags & VKD3DSI_PRECISE_XYZW)
+            vkd3d_spirv_build_op_decorate(builder, val_id, SpvDecorationNoContraction, NULL, 0);
     }
     val_id = spirv_compiler_emit_swizzle(compiler, val_id, VKD3DSP_WRITEMASK_ALL,
             component_type, src[1].swizzle, dst->write_mask);
@@ -10020,9 +10022,9 @@ static void spirv_compiler_emit_sample_info(struct spirv_compiler *compiler,
     uint32_t type_id, val_id;
     unsigned int i;
 
-    if (instruction->flags & ~VKD3DSI_SAMPLE_INFO_UINT)
-        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
-                "Unhandled sample info flags %#x.\n", instruction->flags & ~VKD3DSI_SAMPLE_INFO_UINT);
+    if (instruction->flags & ~(VKD3DSI_SAMPLE_INFO_UINT | VKD3DSI_PRECISE_XYZW))
+        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED, "Unhandled sample info flags %#x.\n",
+                instruction->flags & ~(VKD3DSI_SAMPLE_INFO_UINT | VKD3DSI_PRECISE_XYZW));
 
     val_id = spirv_compiler_emit_query_sample_count(compiler, src);
 
@@ -10037,6 +10039,8 @@ static void spirv_compiler_emit_sample_info(struct spirv_compiler *compiler,
         component_type = VKD3D_SHADER_COMPONENT_FLOAT;
         type_id = vkd3d_spirv_get_type_id(builder, component_type, VKD3D_VEC4_SIZE);
         val_id = vkd3d_spirv_build_op_convert_utof(builder, type_id, val_id);
+        if (instruction->flags & VKD3DSI_PRECISE_XYZW)
+            vkd3d_spirv_build_op_decorate(builder, val_id, SpvDecorationNoContraction, NULL, 0);
     }
     val_id = spirv_compiler_emit_swizzle(compiler, val_id, VKD3DSP_WRITEMASK_ALL,
             component_type, src->swizzle, dst->write_mask);
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index bdb2083e09a..ed19faf945b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -2237,7 +2237,6 @@ bool shader_sm4_is_scalar_register(const struct vkd3d_shader_register *reg)
         case VKD3DSPR_DEPTHOUT:
         case VKD3DSPR_DEPTHOUTGE:
         case VKD3DSPR_DEPTHOUTLE:
-        case VKD3DSPR_GSINSTID:
         case VKD3DSPR_OUTPOINTID:
         case VKD3DSPR_PRIMID:
         case VKD3DSPR_SAMPLEMASK:
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index a91846a46b9..2b73771d0a6 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -1598,12 +1598,13 @@ void vkd3d_shader_free_scan_descriptor_info1(struct vkd3d_shader_scan_descriptor
 static int vsir_program_scan(struct vsir_program *program, const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_message_context *message_context, bool add_descriptor_info)
 {
+    struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
     struct vkd3d_shader_scan_combined_resource_sampler_info *combined_sampler_info;
     struct vkd3d_shader_scan_hull_shader_tessellation_info *tessellation_info;
     struct vkd3d_shader_scan_descriptor_info *descriptor_info;
     struct vkd3d_shader_scan_signature_info *signature_info;
-    struct vkd3d_shader_instruction *instruction;
     struct vkd3d_shader_scan_context context;
+    struct vkd3d_shader_instruction *ins;
     int ret = VKD3D_OK;
     unsigned int i;
 
@@ -1631,10 +1632,9 @@ static int vsir_program_scan(struct vsir_program *program, const struct vkd3d_sh
     if (TRACE_ON())
         vsir_program_trace(program);
 
-    for (i = 0; i < program->instructions.count; ++i)
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
     {
-        instruction = &program->instructions.elements[i];
-        if ((ret = vkd3d_shader_scan_instruction(&context, instruction)) < 0)
+        if ((ret = vkd3d_shader_scan_instruction(&context, ins)) < 0)
             break;
     }
 
@@ -1810,7 +1810,10 @@ static int compile_hlsl(const struct vkd3d_shader_compile_info *compile_info,
 
     preprocessed_info = *compile_info;
     preprocessed_info.source = preprocessed;
-    ret = hlsl_compile_shader(&preprocessed_info, message_context, out);
+    if (compile_info->target_type == VKD3D_SHADER_TARGET_FX)
+        ret = hlsl_compile_effect(&preprocessed_info, message_context, out);
+    else
+        ret = hlsl_compile_shader(&preprocessed_info, message_context, out);
 
     vkd3d_shader_free_shader_code(&preprocessed);
     return ret;
@@ -2257,8 +2260,8 @@ bool shader_instruction_array_init(struct vkd3d_shader_instruction_array *instru
     /* Size the parameter initial allocations so they are large enough for most shaders. The
      * code path for chained allocations will be tested if a few shaders need to use it. */
     shader_param_allocator_init(&instructions->dst_params, reserve - reserve / 8u,
-            sizeof(*instructions->elements->dst));
-    shader_param_allocator_init(&instructions->src_params, reserve * 2u, sizeof(*instructions->elements->src));
+            sizeof(struct vkd3d_shader_dst_param));
+    shader_param_allocator_init(&instructions->src_params, reserve * 2u, sizeof(struct vkd3d_shader_src_param));
     return shader_instruction_array_reserve(instructions, reserve);
 }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index d1c2057b38e..5bf3728a325 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -1453,6 +1453,13 @@ static inline struct vkd3d_shader_instruction *vsir_program_iterator_head(
     return vsir_program_iterator_current(iterator);
 }
 
+static inline struct vkd3d_shader_instruction *vsir_program_iterator_tail(struct vsir_program_iterator *iterator)
+{
+    iterator->idx = iterator->array->count - 1;
+
+    return vsir_program_iterator_current(iterator);
+}
+
 static inline struct vkd3d_shader_instruction *vsir_program_iterator_next(
         struct vsir_program_iterator *iterator)
 {
@@ -1799,6 +1806,8 @@ void vkd3d_compute_md5(const void *dxbc, size_t size, uint32_t checksum[4], enum
 int preproc_lexer_parse(const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context);
 
+int hlsl_compile_effect(const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_message_context *message_context, struct vkd3d_shader_code *out);
 int hlsl_compile_shader(const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_message_context *message_context, struct vkd3d_shader_code *out);
 
-- 
2.47.2

