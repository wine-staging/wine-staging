From c055ff0fe9ec639b923dfaa8a9572f8a7040f2a1 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 15 Jan 2026 10:01:38 +1100
Subject: [PATCH] Updated vkd3d to a8640ee531a1a6742f8adbfa3f8f198bbb990fc3.

---
 libs/vkd3d/libs/vkd3d-shader/dxil.c | 479 ++++++++++++++++++----------
 1 file changed, 319 insertions(+), 160 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index 15c428f1fd8..97dc6dd2488 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -614,10 +614,16 @@ enum dxil_well_known_structs
     WELL_KNOWN_DIMENSIONS,
     WELL_KNOWN_SPLITDOUBLE,
     WELL_KNOWN_FOURI32,
+    WELL_KNOWN_RESRET_F16,
     WELL_KNOWN_RESRET_F32,
+    WELL_KNOWN_RESRET_I16,
     WELL_KNOWN_RESRET_I32,
+    WELL_KNOWN_CBUFRET_F16,
     WELL_KNOWN_CBUFRET_F32,
+    WELL_KNOWN_CBUFRET_F64,
+    WELL_KNOWN_CBUFRET_I16,
     WELL_KNOWN_CBUFRET_I32,
+    WELL_KNOWN_CBUFRET_I64,
 };
 
 struct sm6_struct_info
@@ -861,7 +867,6 @@ struct sm6_descriptor_info
     enum vkd3d_shader_descriptor_type type;
     unsigned int id;
     struct vkd3d_shader_register_range range;
-    enum vkd3d_shader_resource_type resource_type;
     enum dxil_resource_kind kind;
     enum vsir_data_type resource_data_type;
 };
@@ -2010,11 +2015,26 @@ static inline bool sm6_type_is_i8(const struct sm6_type *type)
     return type->class == TYPE_CLASS_INTEGER && type->u.width == 8;
 }
 
+static inline bool sm6_type_is_i16(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_INTEGER && type->u.width == 16;
+}
+
 static inline bool sm6_type_is_i32(const struct sm6_type *type)
 {
     return type->class == TYPE_CLASS_INTEGER && type->u.width == 32;
 }
 
+static inline bool sm6_type_is_i64(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_INTEGER && type->u.width == 64;
+}
+
+static bool sm6_type_is_f16(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_FLOAT && type->u.width == 16;
+}
+
 static bool sm6_type_is_float(const struct sm6_type *type)
 {
     return type->class == TYPE_CLASS_FLOAT && type->u.width == 32;
@@ -2199,11 +2219,21 @@ static void dxil_recognise_well_known_struct(struct sm6_parser *dxil, struct sm6
         const char *suffix;
 
         suffix = &info->name[ARRAY_SIZE(resret_prefix) - 1];
-        if (!strcmp(suffix, "f32"))
+        if (!strcmp(suffix, "f16"))
+        {
+            target_well_known = WELL_KNOWN_RESRET_F16;
+            field_checker = sm6_type_is_f16;
+        }
+        else if (!strcmp(suffix, "f32"))
         {
             target_well_known = WELL_KNOWN_RESRET_F32;
             field_checker = sm6_type_is_float;
         }
+        else if (!strcmp(suffix, "i16"))
+        {
+            target_well_known = WELL_KNOWN_RESRET_I16;
+            field_checker = sm6_type_is_i16;
+        }
         else if (!strcmp(suffix, "i32"))
         {
             target_well_known = WELL_KNOWN_RESRET_I32;
@@ -2231,25 +2261,52 @@ static void dxil_recognise_well_known_struct(struct sm6_parser *dxil, struct sm6
     {
         enum dxil_well_known_structs target_well_known = WELL_KNOWN_NONE;
         bool (*field_checker)(const struct sm6_type *) = NULL;
+        unsigned int field_count = 0;
         const char *suffix;
 
         suffix = &info->name[ARRAY_SIZE(cbufret_prefix) - 1];
-        if (!strcmp(suffix, "f32"))
+        if (!strcmp(suffix, "f16"))
+        {
+            target_well_known = WELL_KNOWN_CBUFRET_F16;
+            field_checker = sm6_type_is_f16;
+            field_count = 4;
+        }
+        else if (!strcmp(suffix, "f32"))
         {
             target_well_known = WELL_KNOWN_CBUFRET_F32;
             field_checker = sm6_type_is_float;
+            field_count = 4;
+        }
+        else if (!strcmp(suffix, "f64"))
+        {
+            target_well_known = WELL_KNOWN_CBUFRET_F64;
+            field_checker = sm6_type_is_double;
+            field_count = 2;
+        }
+        else if (!strcmp(suffix, "i16"))
+        {
+            target_well_known = WELL_KNOWN_CBUFRET_I16;
+            field_checker = sm6_type_is_i16;
+            field_count = 4;
         }
         else if (!strcmp(suffix, "i32"))
         {
             target_well_known = WELL_KNOWN_CBUFRET_I32;
             field_checker = sm6_type_is_i32;
+            field_count = 4;
+        }
+        else if (!strcmp(suffix, "i64"))
+        {
+            target_well_known = WELL_KNOWN_CBUFRET_I64;
+            field_checker = sm6_type_is_i64;
+            field_count = 2;
         }
 
         if (target_well_known != WELL_KNOWN_NONE)
         {
-            if (info->elem_count != 4)
+            if (info->elem_count != field_count)
                 goto error;
-            for (i = 0; i < 4; ++i)
+            for (i = 0; i < field_count; ++i)
             {
                 if (!field_checker(info->elem_types[i]))
                     goto error;
@@ -2365,6 +2422,17 @@ static bool resource_kind_is_multisampled(enum dxil_resource_kind kind)
     return kind == RESOURCE_KIND_TEXTURE2DMS || kind == RESOURCE_KIND_TEXTURE2DMSARRAY;
 }
 
+static enum vkd3d_shader_resource_type shader_resource_type_from_dxil_resource_kind(enum dxil_resource_kind kind)
+{
+    if (resource_kind_is_texture(kind))
+        return kind + 1;
+
+    if (resource_kind_is_buffer(kind))
+        return VKD3D_SHADER_RESOURCE_BUFFER;
+
+    return VKD3D_SHADER_RESOURCE_NONE;
+}
+
 static int global_symbol_compare(const void *a, const void *b)
 {
     return vkd3d_u32_compare(((const struct sm6_symbol *)a)->id, ((const struct sm6_symbol *)b)->id);
@@ -2657,10 +2725,12 @@ static unsigned int sm6_parser_alloc_ssa_id(struct sm6_parser *sm6)
 static void instruction_init_with_resource(struct vkd3d_shader_instruction *ins,
         enum vkd3d_shader_opcode opcode, const struct sm6_value *resource, struct sm6_parser *dxil)
 {
+    enum dxil_resource_kind kind = resource->u.handle.d->kind;
+
     vsir_instruction_init(ins, &dxil->p.location, opcode);
-    ins->resource_type = resource->u.handle.d->resource_type;
-    ins->raw = resource->u.handle.d->kind == RESOURCE_KIND_RAWBUFFER;
-    ins->structured = resource->u.handle.d->kind == RESOURCE_KIND_STRUCTUREDBUFFER;
+    ins->resource_type = shader_resource_type_from_dxil_resource_kind(kind);
+    ins->raw = kind == RESOURCE_KIND_RAWBUFFER;
+    ins->structured = kind == RESOURCE_KIND_STRUCTUREDBUFFER;
 }
 
 static struct vsir_src_operand *instruction_src_params_alloc(struct vkd3d_shader_instruction *ins,
@@ -5527,7 +5597,6 @@ static void sm6_parser_emit_dx_atomic_binop(struct sm6_parser *sm6, enum dx_intr
         const struct sm6_value **operands, struct function_emission_state *state)
 {
     struct sm6_value *dst = sm6_parser_get_current_value(sm6);
-    enum vkd3d_shader_resource_type resource_type;
     bool is_cmp_xchg = op == DX_ATOMIC_CMP_XCHG;
     unsigned int i, coord_idx, coord_count = 1;
     struct vkd3d_shader_instruction *ins;
@@ -5536,6 +5605,7 @@ static void sm6_parser_emit_dx_atomic_binop(struct sm6_parser *sm6, enum dx_intr
     const struct sm6_value *resource;
     struct vkd3d_shader_register reg;
     enum vkd3d_shader_opcode opcode;
+    enum dxil_resource_kind kind;
 
     resource = operands[0];
     if (!sm6_value_validate_is_handle(resource, sm6))
@@ -5547,10 +5617,10 @@ static void sm6_parser_emit_dx_atomic_binop(struct sm6_parser *sm6, enum dx_intr
         return;
 
     coord_idx = 2 - is_cmp_xchg;
-    resource_type = resource->u.handle.d->resource_type;
-    if (resource_type != VKD3D_SHADER_RESOURCE_BUFFER || resource->u.handle.d->kind == RESOURCE_KIND_STRUCTUREDBUFFER)
+    kind = resource->u.handle.d->kind;
+    if (resource_kind_is_texture(kind) || kind == RESOURCE_KIND_STRUCTUREDBUFFER)
     {
-        coord_count = 2 + (resource_type != VKD3D_SHADER_RESOURCE_BUFFER);
+        coord_count = 2 + resource_kind_is_texture(kind);
         if (!sm6_parser_emit_coordinate_construct(sm6, &operands[coord_idx], coord_count, NULL, state, &reg))
             return;
     }
@@ -6825,7 +6895,7 @@ static void instruction_set_texel_offset(struct vkd3d_shader_instruction *ins,
         ins->texel_offset.w = 0;
 }
 
-static void sm6_parser_emit_dx_sample(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+static void sm6_parser_emit_dx_sample(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
     unsigned int clamp_idx = 0, component_count = VKD3D_VEC4_SIZE;
@@ -6836,156 +6906,213 @@ static void sm6_parser_emit_dx_sample(struct sm6_parser *sm6, enum dx_intrinsic_
 
     resource = operands[0];
     sampler = operands[1];
-    if (!sm6_value_validate_is_texture_handle(resource, op, sm6)
-            || !sm6_value_validate_is_sampler_handle(sampler, op, sm6))
+    if (!sm6_value_validate_is_texture_handle(resource, op, dxil)
+            || !sm6_value_validate_is_sampler_handle(sampler, op, dxil))
     {
         return;
     }
 
-    if (!sm6_parser_emit_coordinate_construct(sm6, &operands[2], VKD3D_VEC4_SIZE, NULL, state, &coord))
+    if (!sm6_parser_emit_coordinate_construct(dxil, &operands[2], VKD3D_VEC4_SIZE, NULL, state, &coord))
         return;
 
     if (op == DX_SAMPLE_GRAD)
     {
-        if (!sm6_parser_emit_coordinate_construct(sm6, &operands[9], 3, NULL, state, &ddx))
+        if (!sm6_parser_emit_coordinate_construct(dxil, &operands[9], 3, NULL, state, &ddx))
             return;
-        if (!sm6_parser_emit_coordinate_construct(sm6, &operands[12], 3, NULL, state, &ddy))
+        if (!sm6_parser_emit_coordinate_construct(dxil, &operands[12], 3, NULL, state, &ddy))
             return;
     }
 
-    ins = state->ins;
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
+
+    state->pushed_instruction = true;
+
     switch (op)
     {
         case DX_SAMPLE:
-            instruction_init_with_resource(ins, VSIR_OP_SAMPLE, resource, sm6);
-            src_params = instruction_src_params_alloc(ins, 3, sm6);
+            instruction_init_with_resource(ins, VSIR_OP_SAMPLE, resource, dxil);
+
+            if (!(src_params = instruction_src_params_alloc(ins, 3, dxil)))
+            {
+                vkd3d_shader_instruction_make_nop(ins);
+                return;
+            }
+
             clamp_idx = 9;
             break;
+
         case DX_SAMPLE_B:
             clamp_idx = 10;
             /* fall through */
         case DX_SAMPLE_LOD:
             instruction_init_with_resource(ins, (op == DX_SAMPLE_B) ? VSIR_OP_SAMPLE_B : VSIR_OP_SAMPLE_LOD,
-                    resource, sm6);
-            src_params = instruction_src_params_alloc(ins, 4, sm6);
-            src_param_init_from_value(&src_params[3], operands[9], 0, sm6);
+                    resource, dxil);
+
+            if (!(src_params = instruction_src_params_alloc(ins, 4, dxil)))
+            {
+                vkd3d_shader_instruction_make_nop(ins);
+                return;
+            }
+
+            src_param_init_from_value(&src_params[3], operands[9], 0, dxil);
             break;
+
         case DX_SAMPLE_C:
             clamp_idx = 10;
             /* fall through */
         case DX_SAMPLE_C_LZ:
             instruction_init_with_resource(ins, (op == DX_SAMPLE_C_LZ) ? VSIR_OP_SAMPLE_C_LZ : VSIR_OP_SAMPLE_C,
-                    resource, sm6);
-            src_params = instruction_src_params_alloc(ins, 4, sm6);
-            src_param_init_from_value(&src_params[3], operands[9], 0, sm6);
+                    resource, dxil);
+
+            if (!(src_params = instruction_src_params_alloc(ins, 4, dxil)))
+            {
+                vkd3d_shader_instruction_make_nop(ins);
+                return;
+            }
+
+            src_param_init_from_value(&src_params[3], operands[9], 0, dxil);
             component_count = 1;
             break;
+
         case DX_SAMPLE_GRAD:
-            instruction_init_with_resource(ins, VSIR_OP_SAMPLE_GRAD, resource, sm6);
-            src_params = instruction_src_params_alloc(ins, 5, sm6);
+            instruction_init_with_resource(ins, VSIR_OP_SAMPLE_GRAD, resource, dxil);
+
+            if (!(src_params = instruction_src_params_alloc(ins, 5, dxil)))
+            {
+                vkd3d_shader_instruction_make_nop(ins);
+                return;
+            }
+
             src_param_init_vector_from_reg(&src_params[3], &ddx);
             src_param_init_vector_from_reg(&src_params[4], &ddy);
             clamp_idx = 15;
             break;
+
         default:
             vkd3d_unreachable();
     }
 
-    if (!src_params)
-        return;
-
     if (clamp_idx && !sm6_value_is_undef(operands[clamp_idx]))
-    {
-        FIXME("Ignoring LOD clamp value.\n");
-        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+        vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
                 "Ignoring LOD clamp value for a sample operation.");
-    }
 
     src_param_init_vector_from_reg(&src_params[0], &coord);
-    src_param_init_vector_from_handle(sm6, &src_params[1], &resource->u.handle);
-    src_param_init_vector_from_handle(sm6, &src_params[2], &sampler->u.handle);
-    instruction_set_texel_offset(ins, &operands[6], 3, sm6);
+    src_param_init_vector_from_handle(dxil, &src_params[1], &resource->u.handle);
+    src_param_init_vector_from_handle(dxil, &src_params[2], &sampler->u.handle);
+    instruction_set_texel_offset(ins, &operands[6], 3, dxil);
 
-    instruction_dst_param_init_ssa_vector(ins, component_count, sm6);
+    if (!instruction_dst_param_init_ssa_vector(ins, component_count, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
-static void sm6_parser_emit_dx_sample_index(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+static void sm6_parser_emit_dx_sample_index(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    const struct shader_signature *signature = &sm6->program->input_signature;
-    struct vkd3d_shader_instruction *ins = state->ins;
+    const struct shader_signature *signature = &dxil->program->input_signature;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_param;
     unsigned int element_idx;
 
-    vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_MOV);
-
     /* SV_SampleIndex is identified in VSIR by its signature element index,
      * but the index is not supplied as a parameter to the DXIL intrinsic. */
     if (!vsir_signature_find_sysval(signature, VKD3D_SHADER_SV_SAMPLE_INDEX, 0, &element_idx))
     {
-        WARN("Sample index is not in the signature.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
                 "Sample index signature element for a sample index operation is missing.");
         return;
     }
 
-    if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
-    src_param->reg = sm6->input_params[element_idx].reg;
+
+    state->pushed_instruction = true;
+
+    vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
+
+    if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
+        return;
+    }
+
+    src_param->reg = dxil->input_params[element_idx].reg;
     src_param_init(src_param);
 
-    instruction_dst_param_init_ssa_scalar(ins, 0, sm6);
+    if (!instruction_dst_param_init_ssa_scalar(ins, 0, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
-static void sm6_parser_emit_dx_saturate(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+static void sm6_parser_emit_dx_saturate(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_param;
 
-    vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_SATURATE);
-    if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
-    src_param_init_from_value(src_param, operands[0], 0, sm6);
 
-    instruction_dst_param_init_ssa_scalar(ins, 0, sm6);
+    state->pushed_instruction = true;
+
+    vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_SATURATE);
+
+    if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
+        return;
+    }
+
+    src_param_init_from_value(src_param, operands[0], 0, dxil);
+
+    if (!instruction_dst_param_init_ssa_scalar(ins, 0, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
-static void sm6_parser_emit_dx_split_double(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+static void sm6_parser_emit_dx_split_double(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_param;
 
-    vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_MOV);
-    if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
-    src_param_init_from_value(src_param, operands[0], 0, sm6);
 
-    instruction_dst_param_init_ssa_vector(ins, 2, sm6);
+    state->pushed_instruction = true;
+
+    vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
+
+    if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
+        return;
+    }
+
+    src_param_init_from_value(src_param, operands[0], 0, dxil);
+
+    if (!instruction_dst_param_init_ssa_vector(ins, 2, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
-static void sm6_parser_emit_dx_store_output(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+static void sm6_parser_emit_dx_store_output(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
     bool is_patch_constant = op == DX_STORE_PATCH_CONSTANT;
-    struct vkd3d_shader_instruction *ins = state->ins;
-    struct vsir_program *program = sm6->program;
+    struct vsir_program *program = dxil->program;
     const struct shader_signature *signature;
+    struct vkd3d_shader_instruction *ins;
     unsigned int row_index, column_index;
     struct vsir_src_operand *src_param;
     struct vsir_dst_operand *dst_param;
     const struct signature_element *e;
     const struct sm6_value *value;
 
-    row_index = sm6_value_get_constant_uint(operands[0], sm6);
-    column_index = sm6_value_get_constant_uint(operands[2], sm6);
+    row_index = sm6_value_get_constant_uint(operands[0], dxil);
+    column_index = sm6_value_get_constant_uint(operands[2], dxil);
 
     signature = is_patch_constant ? &program->patch_constant_signature : &program->output_signature;
     if (row_index >= signature->element_count)
     {
-        WARN("Invalid row index %u.\n", row_index);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Invalid output row index %u.", row_index);
         return;
     }
@@ -6994,8 +7121,7 @@ static void sm6_parser_emit_dx_store_output(struct sm6_parser *sm6, enum dx_intr
 
     if (column_index >= VKD3D_VEC4_SIZE)
     {
-        WARN("Invalid column index %u.\n", column_index);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Invalid output column index %u.", column_index);
         return;
     }
@@ -7003,32 +7129,44 @@ static void sm6_parser_emit_dx_store_output(struct sm6_parser *sm6, enum dx_intr
     value = operands[3];
     if (!sm6_value_is_register(value))
     {
-        WARN("Source value is not a register.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Expected store operation source to be a register.");
         return;
     }
 
-    vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_MOV);
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
 
-    if (!(dst_param = instruction_dst_params_alloc(ins, 1, sm6)))
+    state->pushed_instruction = true;
+
+    vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
+
+    if (!(dst_param = instruction_dst_params_alloc(ins, 1, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
         return;
+    }
+
     dst_param_init_scalar(dst_param, column_index);
-    dst_param->reg = is_patch_constant ? sm6->patch_constant_params[row_index].reg : sm6->output_params[row_index].reg;
+    dst_param->reg = is_patch_constant ? dxil->patch_constant_params[row_index].reg
+            : dxil->output_params[row_index].reg;
     if (e->register_count > 1)
-        register_index_address_init(&dst_param->reg.idx[0], operands[1], sm6);
+        register_index_address_init(&dst_param->reg.idx[0], operands[1], dxil);
 
     if (e->register_index == UINT_MAX)
-    {
-        sm6_parser_dcl_register_builtin(sm6, VSIR_OP_DCL_OUTPUT, dst_param->reg.type,
+        sm6_parser_dcl_register_builtin(dxil, VSIR_OP_DCL_OUTPUT, dst_param->reg.type,
                 dst_param->reg.data_type, vsir_write_mask_component_count(e->mask));
+
+    if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
+        return;
     }
 
-    if ((src_param = instruction_src_params_alloc(ins, 1, sm6)))
-        src_param_init_from_value(src_param, value, 0, sm6);
+    src_param_init_from_value(src_param, value, 0, dxil);
 }
 
-static void sm6_parser_emit_dx_texture_gather(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+static void sm6_parser_emit_dx_texture_gather(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
     struct vkd3d_shader_register coord, offset;
@@ -7040,106 +7178,119 @@ static void sm6_parser_emit_dx_texture_gather(struct sm6_parser *sm6, enum dx_in
 
     resource = operands[0];
     sampler = operands[1];
-    if (!sm6_value_validate_is_texture_handle(resource, op, sm6)
-            || !sm6_value_validate_is_sampler_handle(sampler, op, sm6))
-    {
+    if (!sm6_value_validate_is_texture_handle(resource, op, dxil)
+            || !sm6_value_validate_is_sampler_handle(sampler, op, dxil))
         return;
-    }
 
-    if (!sm6_parser_emit_coordinate_construct(sm6, &operands[2], VKD3D_VEC4_SIZE, NULL, state, &coord))
+    if (!sm6_parser_emit_coordinate_construct(dxil, &operands[2], VKD3D_VEC4_SIZE, NULL, state, &coord))
         return;
 
     if ((extended_offset = !sm6_value_vector_is_constant_or_undef(&operands[6], 2))
-            && !sm6_parser_emit_coordinate_construct(sm6, &operands[6], 2, NULL, state, &offset))
-    {
+            && !sm6_parser_emit_coordinate_construct(dxil, &operands[6], 2, NULL, state, &offset))
         return;
-    }
 
     /* DXIL doesn't know about signedness, but vsir expects the offset to be signed. */
     if (extended_offset)
         offset.data_type = VSIR_DATA_I32;
 
-    ins = state->ins;
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
+
+    state->pushed_instruction = true;
+
     if (op == DX_TEXTURE_GATHER)
     {
-        instruction_init_with_resource(ins, extended_offset ? VSIR_OP_GATHER4_PO : VSIR_OP_GATHER4, resource, sm6);
-        if (!(src_params = instruction_src_params_alloc(ins, 3 + extended_offset, sm6)))
+        instruction_init_with_resource(ins, extended_offset ? VSIR_OP_GATHER4_PO : VSIR_OP_GATHER4, resource, dxil);
+
+        if (!(src_params = instruction_src_params_alloc(ins, 3 + extended_offset, dxil)))
+        {
+            vkd3d_shader_instruction_make_nop(ins);
             return;
+        }
     }
     else
     {
-        instruction_init_with_resource(ins, extended_offset ? VSIR_OP_GATHER4_PO_C : VSIR_OP_GATHER4_C, resource, sm6);
-        if (!(src_params = instruction_src_params_alloc(ins, 4 + extended_offset, sm6)))
+        instruction_init_with_resource(ins, extended_offset ? VSIR_OP_GATHER4_PO_C : VSIR_OP_GATHER4_C, resource, dxil);
+
+        if (!(src_params = instruction_src_params_alloc(ins, 4 + extended_offset, dxil)))
+        {
+            vkd3d_shader_instruction_make_nop(ins);
             return;
-        src_param_init_from_value(&src_params[3 + extended_offset], operands[9], 0, sm6);
+        }
+
+        src_param_init_from_value(&src_params[3 + extended_offset], operands[9], 0, dxil);
     }
 
     src_param_init_vector_from_reg(&src_params[0], &coord);
     if (extended_offset)
         src_param_init_vector_from_reg(&src_params[1], &offset);
     else
-        instruction_set_texel_offset(ins, &operands[6], 2, sm6);
-    src_param_init_vector_from_handle(sm6, &src_params[1 + extended_offset], &resource->u.handle);
-    src_param_init_vector_from_handle(sm6, &src_params[2 + extended_offset], &sampler->u.handle);
+        instruction_set_texel_offset(ins, &operands[6], 2, dxil);
+    src_param_init_vector_from_handle(dxil, &src_params[1 + extended_offset], &resource->u.handle);
+    src_param_init_vector_from_handle(dxil, &src_params[2 + extended_offset], &sampler->u.handle);
     /* Swizzle stored in the sampler parameter is the scalar component index to be gathered. */
-    swizzle = sm6_value_get_constant_uint(operands[8], sm6);
+    swizzle = sm6_value_get_constant_uint(operands[8], dxil);
     if (swizzle >= VKD3D_VEC4_SIZE)
-    {
-        WARN("Invalid swizzle %#x.\n", swizzle);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Swizzle %#x for a texture gather operation is invalid.", swizzle);
-    }
     src_params[2 + extended_offset].swizzle = swizzle;
 
-    instruction_dst_param_init_ssa_vector(ins, VKD3D_VEC4_SIZE, sm6);
+    if (!instruction_dst_param_init_ssa_vector(ins, VKD3D_VEC4_SIZE, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
-static void sm6_parser_emit_dx_texture_load(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+static void sm6_parser_emit_dx_texture_load(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
     const struct sm6_value *resource, *mip_level_or_sample_count;
-    enum vkd3d_shader_resource_type resource_type;
     struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_params;
     struct vkd3d_shader_register coord;
+    enum dxil_resource_kind kind;
     bool is_multisample, is_uav;
     unsigned int i;
 
     resource = operands[0];
-    if (!sm6_value_validate_is_texture_handle(resource, op, sm6))
+    if (!sm6_value_validate_is_texture_handle(resource, op, dxil))
         return;
 
-    resource_type = resource->u.handle.d->resource_type;
-    is_multisample = resource_type == VKD3D_SHADER_RESOURCE_TEXTURE_2DMS
-            || resource_type == VKD3D_SHADER_RESOURCE_TEXTURE_2DMSARRAY;
+    kind = resource->u.handle.d->kind;
+    is_multisample = resource_kind_is_multisampled(kind);
     is_uav = resource->u.handle.d->type == VKD3D_SHADER_DESCRIPTOR_TYPE_UAV;
 
-    mip_level_or_sample_count = (resource_type != VKD3D_SHADER_RESOURCE_BUFFER) ? operands[1] : NULL;
-    if (!sm6_parser_emit_coordinate_construct(sm6, &operands[2], 3,
+    mip_level_or_sample_count = resource_kind_is_texture(kind) ? operands[1] : NULL;
+    if (!sm6_parser_emit_coordinate_construct(dxil, &operands[2], 3,
             is_multisample ? NULL : mip_level_or_sample_count, state, &coord))
-    {
         return;
-    }
 
-    ins = state->ins;
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
+
+    state->pushed_instruction = true;
+
     instruction_init_with_resource(ins, is_uav ? VSIR_OP_LD_UAV_TYPED
-            : is_multisample ? VSIR_OP_LD2DMS : VSIR_OP_LD, resource, sm6);
-    instruction_set_texel_offset(ins, &operands[5], 3, sm6);
+            : is_multisample ? VSIR_OP_LD2DMS : VSIR_OP_LD, resource, dxil);
+    instruction_set_texel_offset(ins, &operands[5], 3, dxil);
 
     for (i = 0; i < VKD3D_VEC4_SIZE; ++i)
         ins->resource_data_type[i] = resource->u.handle.d->resource_data_type;
 
-    if (!(src_params = instruction_src_params_alloc(ins, 2 + is_multisample, sm6)))
+    if (!(src_params = instruction_src_params_alloc(ins, 2 + is_multisample, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
         return;
+    }
+
     src_param_init_vector_from_reg(&src_params[0], &coord);
-    src_param_init_vector_from_handle(sm6, &src_params[1], &resource->u.handle);
+    src_param_init_vector_from_handle(dxil, &src_params[1], &resource->u.handle);
     if (is_multisample)
-        src_param_init_from_value(&src_params[2], mip_level_or_sample_count, 0, sm6);
+        src_param_init_from_value(&src_params[2], mip_level_or_sample_count, 0, dxil);
 
-    instruction_dst_param_init_ssa_vector(ins, VKD3D_VEC4_SIZE, sm6);
+    if (!instruction_dst_param_init_ssa_vector(ins, VKD3D_VEC4_SIZE, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
-static void sm6_parser_emit_dx_texture_store(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+static void sm6_parser_emit_dx_texture_store(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
     struct vkd3d_shader_register coord, texel;
@@ -7150,57 +7301,79 @@ static void sm6_parser_emit_dx_texture_store(struct sm6_parser *sm6, enum dx_int
     const struct sm6_value *resource;
 
     resource = operands[0];
-    if (!sm6_value_validate_is_texture_handle(resource, op, sm6))
+    if (!sm6_value_validate_is_texture_handle(resource, op, dxil))
         return;
 
-    if (!sm6_parser_emit_coordinate_construct(sm6, &operands[1], 3, NULL, state, &coord))
+    if (!sm6_parser_emit_coordinate_construct(dxil, &operands[1], 3, NULL, state, &coord))
         return;
 
-    write_mask = sm6_value_get_constant_uint(operands[8], sm6);
+    write_mask = sm6_value_get_constant_uint(operands[8], dxil);
     if (!write_mask || write_mask > VKD3DSP_WRITEMASK_ALL)
     {
-        WARN("Invalid write mask %#x.\n", write_mask);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Write mask %#x for a texture store operation is invalid.", write_mask);
         return;
     }
-    else if (write_mask & (write_mask + 1))
-    {
-        /* In this case, it is unclear which source operands will be defined unless we encounter it in a shader. */
-        FIXME("Unhandled write mask %#x.\n", write_mask);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+
+    /* In this case, it is unclear which source operands will be defined
+     * unless we encounter it in a shader. */
+    if (write_mask & (write_mask + 1))
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Write mask %#x for a texture store operation is unhandled.", write_mask);
-    }
     component_count = vsir_write_mask_component_count(write_mask);
 
-    if (!sm6_parser_emit_composite_construct(sm6, &operands[4], component_count, state, &texel))
+    if (!sm6_parser_emit_composite_construct(dxil, &operands[4], component_count, state, &texel))
         return;
 
-    ins = state->ins;
-    vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_STORE_UAV_TYPED);
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
 
-    if (!(src_params = instruction_src_params_alloc(ins, 2, sm6)))
+    state->pushed_instruction = true;
+
+    vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_STORE_UAV_TYPED);
+
+    if (!(src_params = instruction_src_params_alloc(ins, 2, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
         return;
+    }
+
     src_param_init_vector_from_reg(&src_params[0], &coord);
     src_param_init_vector_from_reg(&src_params[1], &texel);
 
-    dst_param = instruction_dst_params_alloc(ins, 1, sm6);
-    sm6_register_from_handle(sm6, &resource->u.handle, &dst_param->reg);
+    if (!(dst_param = instruction_dst_params_alloc(ins, 1, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
+        return;
+    }
+
+    sm6_register_from_handle(dxil, &resource->u.handle, &dst_param->reg);
     dst_param_init_with_mask(dst_param, write_mask);
 }
 
-static void sm6_parser_emit_dx_wave_active_ballot(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+static void sm6_parser_emit_dx_wave_active_ballot(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_param;
 
-    vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_WAVE_ACTIVE_BALLOT);
-    if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
-    src_param_init_from_value(src_param, operands[0], 0, sm6);
 
-    instruction_dst_param_init_ssa_vector(ins, VKD3D_VEC4_SIZE, sm6);
+    state->pushed_instruction = true;
+
+    vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_WAVE_ACTIVE_BALLOT);
+
+    if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
+        return;
+    }
+
+    src_param_init_from_value(src_param, operands[0], 0, dxil);
+
+    if (!instruction_dst_param_init_ssa_vector(ins, VKD3D_VEC4_SIZE, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
 static enum vkd3d_shader_opcode sm6_dx_map_wave_bit_op(enum dxil_wave_bit_op_kind op,
@@ -9765,17 +9938,6 @@ static bool sm6_parser_resources_load_register_range(struct sm6_parser *sm6,
     return true;
 }
 
-static enum vkd3d_shader_resource_type shader_resource_type_from_dxil_resource_kind(enum dxil_resource_kind kind)
-{
-    if (resource_kind_is_texture(kind))
-        return kind + 1;
-
-    if (resource_kind_is_buffer(kind))
-        return VKD3D_SHADER_RESOURCE_BUFFER;
-
-    return VKD3D_SHADER_RESOURCE_NONE;
-}
-
 static const enum vsir_data_type data_type_table[] =
 {
     [COMPONENT_TYPE_INVALID]     = VSIR_DATA_UNUSED,
@@ -10035,7 +10197,6 @@ static enum vkd3d_result sm6_parser_resources_load_srv(struct sm6_parser *sm6,
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    d->resource_type = ins->resource_type;
     d->kind = kind;
     d->resource_data_type = (ins->opcode == VSIR_OP_DCL)
             ? ins->declaration.semantic.resource_data_type[0] : VSIR_DATA_UNUSED;
@@ -10107,7 +10268,6 @@ static enum vkd3d_result sm6_parser_resources_load_uav(struct sm6_parser *sm6,
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    d->resource_type = ins->resource_type;
     d->kind = values[0];
     d->resource_data_type = (ins->opcode == VSIR_OP_DCL_UAV_TYPED)
             ? ins->declaration.semantic.resource_data_type[0] : VSIR_DATA_UNUSED;
@@ -10219,7 +10379,6 @@ static enum vkd3d_result sm6_parser_resources_load_sampler(struct sm6_parser *sm
 
     ins->declaration.sampler.range = d->range;
 
-    d->resource_type = ins->resource_type;
     d->kind = RESOURCE_KIND_SAMPLER;
     d->resource_data_type = VSIR_DATA_UNUSED;
 
-- 
2.51.0

