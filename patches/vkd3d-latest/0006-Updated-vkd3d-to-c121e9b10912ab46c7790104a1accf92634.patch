From 5fd3d22b5e3bcd88bb69d4ddef63536d6cc37245 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Sun, 8 Feb 2026 16:53:38 +1100
Subject: [PATCH] Updated vkd3d to c121e9b10912ab46c7790104a1accf9263472b12.

---
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c        |   2 +-
 libs/vkd3d/libs/vkd3d-shader/d3dbc.c          |  35 +-
 libs/vkd3d/libs/vkd3d-shader/dxbc.c           |   7 +-
 libs/vkd3d/libs/vkd3d-shader/dxil.c           | 539 ++++++++----------
 libs/vkd3d/libs/vkd3d-shader/fx.c             | 101 ++--
 libs/vkd3d/libs/vkd3d-shader/hlsl.c           |  37 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.h           |  20 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.l           |  10 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.y           | 230 ++++++--
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c   |  85 +--
 libs/vkd3d/libs/vkd3d-shader/ir.c             | 410 +++++++++++--
 libs/vkd3d/libs/vkd3d-shader/tpf.c            |   1 +
 .../libs/vkd3d-shader/vkd3d_shader_main.c     |  17 +-
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |   7 +
 14 files changed, 986 insertions(+), 515 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index 4fcdd0e4246..f06870718ec 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -489,7 +489,7 @@ static void shader_print_dcl_usage(struct vkd3d_d3d_asm_compiler *compiler,
         return;
     }
 
-    /* Pixel shaders 3.0 don't have usage semantics. */
+    /* Pixel shaders before 3.0 don't have usage semantics. */
     if (!vkd3d_shader_ver_ge(&compiler->shader_version, 3, 0)
             && compiler->shader_version.type == VKD3D_SHADER_TYPE_PIXEL)
         return;
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index 3d7c36d9319..8784ea69e97 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -582,6 +582,11 @@ static void d3dbc_parse_register(struct vkd3d_shader_sm1_parser *d3dbc,
         reg->dimension = VSIR_DIMENSION_SCALAR;
     else
         reg->dimension = VSIR_DIMENSION_VEC4;
+
+    if (reg->type == VKD3DSPR_CONSTINT)
+        reg->data_type = VSIR_DATA_U32;
+    else if (reg->type == VKD3DSPR_CONSTBOOL)
+        reg->data_type = VSIR_DATA_BOOL;
 }
 
 static void d3dbc_parse_src_operand(struct vkd3d_shader_sm1_parser *d3dbc,
@@ -757,6 +762,7 @@ static bool add_signature_element_from_register(struct vkd3d_shader_sm1_parser *
 {
     const struct vkd3d_shader_version *version = &sm1->program->shader_version;
     unsigned int register_index = reg->idx_count > 0 ? reg->idx[0].offset : 0;
+    struct signature_element *e;
 
     switch (reg->type)
     {
@@ -769,13 +775,23 @@ static bool add_signature_element_from_register(struct vkd3d_shader_sm1_parser *
         case VKD3DSPR_INPUT:
             /* For vertex shaders or sm3 pixel shaders, we should have already
              * had a DCL instruction. Otherwise, this is a colour input. */
-            if (version->type == VKD3D_SHADER_TYPE_VERTEX || version->major == 3)
+            if (version->type == VKD3D_SHADER_TYPE_PIXEL && version->major < 3)
+                return add_signature_element(sm1, false, "COLOR", register_index,
+                        VKD3D_SHADER_SV_NONE, SM1_COLOR_REGISTER_OFFSET + register_index, is_dcl, mask, dst_modifiers);
+
+            if (reg->idx_count > 0 && reg->idx[0].rel_addr)
             {
-                add_signature_mask(sm1, false, register_index, mask);
+                WARN("Indirect addressing detected, adding used_mask %#x to all input elements.\n", mask);
+                for (unsigned int i = 0; i < sm1->program->input_signature.element_count; ++i)
+                {
+                    e = &sm1->program->input_signature.elements[i];
+                    e->used_mask |= mask & e->mask;
+                }
                 return true;
             }
-            return add_signature_element(sm1, false, "COLOR", register_index,
-                    VKD3D_SHADER_SV_NONE, SM1_COLOR_REGISTER_OFFSET + register_index, is_dcl, mask, dst_modifiers);
+
+            add_signature_mask(sm1, false, register_index, mask);
+            return true;
 
         case VKD3DSPR_TEXTURE:
             return add_signature_element(sm1, false, "TEXCOORD", register_index,
@@ -2275,13 +2291,8 @@ int d3dbc_compile(struct vsir_program *program, uint64_t config_flags,
         result = VKD3D_ERROR_INVALID_SHADER;
 
     if (!result)
-    {
-        out->code = buffer->data;
-        out->size = buffer->size;
-    }
-    else
-    {
-        vkd3d_free(buffer->data);
-    }
+        vkd3d_shader_code_from_bytecode_buffer(out, buffer);
+    vkd3d_bytecode_buffer_cleanup(buffer);
+
     return result;
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxbc.c b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
index f1533fbcd54..52448e89e37 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
@@ -90,10 +90,9 @@ int vkd3d_shader_serialize_dxbc(size_t section_count, const struct vkd3d_shader_
         set_u32(&buffer, checksum_position + i * sizeof(uint32_t), checksum[i]);
 
     if (!buffer.status)
-    {
-        dxbc->code = buffer.data;
-        dxbc->size = buffer.size;
-    }
+        vkd3d_shader_code_from_bytecode_buffer(dxbc, &buffer);
+    vkd3d_bytecode_buffer_cleanup(&buffer);
+
     return buffer.status;
 }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index d3a83c59325..ea532001dc9 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -33,7 +33,6 @@ static const uint64_t ALLOCA_FLAG_IN_ALLOCA = 0x20;
 static const uint64_t ALLOCA_FLAG_EXPLICIT_TYPE = 0x40;
 static const uint64_t ALLOCA_ALIGNMENT_MASK = 0x1f;
 static const unsigned int SHADER_DESCRIPTOR_TYPE_COUNT = 4;
-static const size_t MAX_IR_INSTRUCTIONS_PER_DXIL_INSTRUCTION = 11;
 
 static const unsigned int dx_max_thread_group_size[3] = {1024, 1024, 64};
 
@@ -4778,13 +4777,7 @@ struct function_emission_state
 {
     struct sm6_function *function;
     const struct dxil_record *record;
-    struct vkd3d_shader_instruction *ins;
     unsigned int temp_idx;
-
-    /* Keep track of whether the helper below sm6_parser_function_init()
-     * already incremented the instruction count or not. Excepected to be
-     * removed once all helpers increment the count. */
-    bool pushed_instruction;
 };
 
 static struct vkd3d_shader_instruction *sm6_parser_add_function_instruction(struct sm6_parser *sm6,
@@ -4878,7 +4871,6 @@ static void sm6_parser_emit_alloca(struct sm6_parser *sm6, struct function_emiss
 
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
-    state->pushed_instruction = true;
 
     sm6_parser_declare_indexable_temp(sm6, elem_type, type[0]->u.array.count, alignment, true, 0, ins, dst);
 }
@@ -4980,7 +4972,6 @@ static void sm6_parser_emit_atomicrmw(struct sm6_parser *sm6, struct function_em
 
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
-    state->pushed_instruction = true;
 
     vsir_instruction_init(ins, &sm6->p.location, op);
     ins->flags = is_volatile ? VKD3DARF_VOLATILE : 0;
@@ -5164,8 +5155,6 @@ static void sm6_parser_emit_binop(struct sm6_parser *sm6, struct function_emissi
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &sm6->p.location, opcode);
 
     flags = (record->operand_count > i) ? record->operands[i] : 0;
@@ -5282,8 +5271,6 @@ static void sm6_parser_emit_br(struct sm6_parser *dxil, struct function_emission
         if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
             return;
 
-        state->pushed_instruction = true;
-
         vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_BRANCH);
         if (!(src_params = instruction_src_params_alloc(ins, 1, dxil)))
         {
@@ -5313,8 +5300,6 @@ static void sm6_parser_emit_br(struct sm6_parser *dxil, struct function_emission
         if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
             return;
 
-        state->pushed_instruction = true;
-
         vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_BRANCH);
         if (!(src_params = instruction_src_params_alloc(ins, 3, dxil)))
         {
@@ -5366,8 +5351,6 @@ static bool sm6_parser_emit_reg_composite_construct(struct sm6_parser *sm6,
         if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
             return false;
 
-        state->ins = ins + 1;
-
         vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_MOV);
 
         if (!(src_params = instruction_src_params_alloc(ins, 1, sm6)))
@@ -5443,8 +5426,6 @@ static void sm6_parser_emit_dx_void(struct sm6_parser *dxil, enum dx_intrinsic_o
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, sm6_dx_map_void_op(op));
 
     if (!instruction_dst_param_init_ssa_scalar(ins, 0, dxil))
@@ -5545,8 +5526,6 @@ static void sm6_parser_emit_dx_unary(struct sm6_parser *dxil, enum dx_intrinsic_
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, map_dx_unary_op(op));
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
     {
@@ -5599,8 +5578,6 @@ static void sm6_parser_emit_dx_binary(struct sm6_parser *dxil, enum dx_intrinsic
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, map_dx_binary_op(op, operands[0]->type, &type_flags));
 
     if (!(src_params = instruction_src_params_alloc(ins, 2, dxil)))
@@ -5698,8 +5675,6 @@ static void sm6_parser_emit_dx_atomic_binop(struct sm6_parser *sm6, enum dx_intr
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &sm6->p.location, opcode);
 
     if (!(src_params = instruction_src_params_alloc(ins, 2 + is_cmp_xchg, sm6)))
@@ -5736,8 +5711,6 @@ static void sm6_parser_emit_dx_barrier(struct sm6_parser *dxil, enum dx_intrinsi
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_SYNC);
     flags = sm6_value_get_constant_uint(operands[0], dxil);
     ins->flags = flags & (SYNC_THREAD_GROUP | SYNC_THREAD_GROUP_UAV);
@@ -5778,8 +5751,6 @@ static void sm6_parser_emit_dx_buffer_update_counter(struct sm6_parser *sm6, enu
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &sm6->p.location, (inc < 0) ? VSIR_OP_IMM_ATOMIC_CONSUME : VSIR_OP_IMM_ATOMIC_ALLOC);
 
     if (!(src_params = instruction_src_params_alloc(ins, 1, sm6)))
@@ -5817,8 +5788,6 @@ static void sm6_parser_emit_dx_calculate_lod(struct sm6_parser *sm6, enum dx_int
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_LOD);
 
     if (!(src_params = instruction_src_params_alloc(ins, 3, sm6)))
@@ -5852,8 +5821,6 @@ static void sm6_parser_emit_dx_cbuffer_load(struct sm6_parser *sm6, enum dx_intr
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_MOV);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
@@ -5906,8 +5873,6 @@ static void sm6_parser_emit_dx_input_register_mov(struct sm6_parser *dxil, struc
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -5979,11 +5944,6 @@ static void sm6_parser_emit_dx_create_handle(struct sm6_parser *sm6, enum dx_int
     dst->u.handle.d = d;
     dst->u.handle.index = operands[2];
     dst->u.handle.non_uniform = !!sm6_value_get_constant_uint(operands[3], sm6);
-
-    /* Well, not really, but the point here is that we pushed all the
-     * instructions we had to (i.e., none), and sm6_parser_function_init()
-     * doesn't have to do it for us. */
-    state->pushed_instruction = true;
 }
 
 static void sm6_parser_emit_dx_stream(struct sm6_parser *dxil, enum dx_intrinsic_opcode op,
@@ -5996,8 +5956,6 @@ static void sm6_parser_emit_dx_stream(struct sm6_parser *dxil, enum dx_intrinsic
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, (op == DX_CUT_STREAM) ? VSIR_OP_CUT_STREAM : VSIR_OP_EMIT_STREAM);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -6027,8 +5985,6 @@ static void sm6_parser_emit_dx_discard(struct sm6_parser *dxil, enum dx_intrinsi
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_DISCARD);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -6050,8 +6006,6 @@ static void sm6_parser_emit_dx_domain_location(struct sm6_parser *dxil, enum dx_
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
 
     if ((component_idx = sm6_value_get_constant_uint(operands[0], dxil)) >= 3)
@@ -6111,8 +6065,6 @@ static void sm6_parser_emit_dx_dot(struct sm6_parser *dxil, enum dx_intrinsic_op
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, opcode);
 
     if (!(src_params = instruction_src_params_alloc(ins, 2, dxil)))
@@ -6159,8 +6111,6 @@ static void sm6_parser_emit_dx_eval_attrib(struct sm6_parser *sm6, enum dx_intri
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &sm6->p.location, (op == DX_EVAL_CENTROID)
             ? VSIR_OP_EVAL_CENTROID : VSIR_OP_EVAL_SAMPLE_INDEX);
 
@@ -6191,8 +6141,6 @@ static void sm6_parser_emit_dx_fabs(struct sm6_parser *dxil, enum dx_intrinsic_o
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_ABS);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -6239,8 +6187,6 @@ static void sm6_parser_emit_dx_compute_builtin(struct sm6_parser *dxil, enum dx_
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -6285,8 +6231,6 @@ static void sm6_parser_emit_dx_ma(struct sm6_parser *dxil, enum dx_intrinsic_opc
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, sm6_dx_map_ma_op(op, operands[0]->type));
 
     if (!(src_params = instruction_src_params_alloc(ins, 3, dxil)))
@@ -6323,8 +6267,6 @@ static void sm6_parser_emit_dx_get_dimensions(struct sm6_parser *sm6, enum dx_in
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     instruction_init_with_resource(ins, is_texture ? VSIR_OP_RESINFO : VSIR_OP_BUFINFO, resource, sm6);
 
     if (!(src_params = instruction_src_params_alloc(ins, 1 + is_texture, sm6)))
@@ -6428,8 +6370,6 @@ static void sm6_parser_emit_dx_tertiary(struct sm6_parser *dxil, enum dx_intrins
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, sm6_dx_map_tertiary_op(op));
 
     if (!(src_params = instruction_src_params_alloc(ins, 3, dxil)))
@@ -6494,8 +6434,6 @@ static void sm6_parser_emit_dx_load_input(struct sm6_parser *sm6, enum dx_intrin
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_MOV);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
@@ -6534,8 +6472,6 @@ static void sm6_parser_emit_dx_make_double(struct sm6_parser *dxil, enum dx_intr
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
 
     if (!(src_params = instruction_src_params_alloc(ins, 1, dxil)))
@@ -6597,8 +6533,6 @@ static void sm6_parser_emit_dx_quad_op(struct sm6_parser *dxil, enum dx_intrinsi
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, opcode);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -6647,8 +6581,6 @@ static void sm6_parser_emit_dx_raw_buffer_load(struct sm6_parser *sm6, enum dx_i
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     instruction_init_with_resource(ins, raw ? VSIR_OP_LD_RAW : VSIR_OP_LD_STRUCTURED, resource, sm6);
     operand_count = 2 + !raw;
 
@@ -6714,8 +6646,6 @@ static void sm6_parser_emit_dx_raw_buffer_store(struct sm6_parser *sm6, enum dx_
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &sm6->p.location, raw ? VSIR_OP_STORE_RAW : VSIR_OP_STORE_STRUCTURED);
     operand_count = 2 + !raw;
 
@@ -6762,8 +6692,6 @@ static void sm6_parser_emit_dx_buffer_load(struct sm6_parser *sm6, enum dx_intri
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     instruction_init_with_resource(ins, (resource->u.handle.d->type == VKD3D_SHADER_DESCRIPTOR_TYPE_UAV)
             ? VSIR_OP_LD_UAV_TYPED : VSIR_OP_LD, resource, sm6);
 
@@ -6829,8 +6757,6 @@ static void sm6_parser_emit_dx_buffer_store(struct sm6_parser *sm6, enum dx_intr
     if (!(ins = sm6_parser_add_function_instruction(sm6, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_STORE_UAV_TYPED);
 
     if (!(src_params = instruction_src_params_alloc(ins, 2, sm6)))
@@ -6866,8 +6792,6 @@ static void sm6_parser_emit_dx_get_sample_count(struct sm6_parser *dxil, enum dx
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_SAMPLE_INFO);
     ins->flags = VKD3DSI_SAMPLE_INFO_UINT;
 
@@ -6907,8 +6831,6 @@ static void sm6_parser_emit_dx_get_sample_pos(struct sm6_parser *dxil, enum dx_i
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_SAMPLE_POS);
 
     if (!(src_params = instruction_src_params_alloc(ins, 2, dxil)))
@@ -6981,8 +6903,6 @@ static void sm6_parser_emit_dx_sample(struct sm6_parser *dxil, enum dx_intrinsic
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     switch (op)
     {
         case DX_SAMPLE:
@@ -7081,8 +7001,6 @@ static void sm6_parser_emit_dx_sample_index(struct sm6_parser *dxil, enum dx_int
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -7107,8 +7025,6 @@ static void sm6_parser_emit_dx_saturate(struct sm6_parser *dxil, enum dx_intrins
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_SATURATE);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -7132,8 +7048,6 @@ static void sm6_parser_emit_dx_split_double(struct sm6_parser *dxil, enum dx_int
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -7192,8 +7106,6 @@ static void sm6_parser_emit_dx_store_output(struct sm6_parser *dxil, enum dx_int
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
 
     if (!(dst_param = instruction_dst_params_alloc(ins, 1, dxil)))
@@ -7251,8 +7163,6 @@ static void sm6_parser_emit_dx_texture_gather(struct sm6_parser *dxil, enum dx_i
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     if (op == DX_TEXTURE_GATHER)
     {
         instruction_init_with_resource(ins, extended_offset ? VSIR_OP_GATHER4_PO : VSIR_OP_GATHER4, resource, dxil);
@@ -7321,8 +7231,6 @@ static void sm6_parser_emit_dx_texture_load(struct sm6_parser *dxil, enum dx_int
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     instruction_init_with_resource(ins, is_uav ? VSIR_OP_LD_UAV_TYPED
             : is_multisample ? VSIR_OP_LD2DMS : VSIR_OP_LD, resource, dxil);
     instruction_set_texel_offset(ins, &operands[5], 3, dxil);
@@ -7383,8 +7291,6 @@ static void sm6_parser_emit_dx_texture_store(struct sm6_parser *dxil, enum dx_in
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_STORE_UAV_TYPED);
 
     if (!(src_params = instruction_src_params_alloc(ins, 2, dxil)))
@@ -7415,8 +7321,6 @@ static void sm6_parser_emit_dx_wave_active_ballot(struct sm6_parser *dxil, enum
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_WAVE_ACTIVE_BALLOT);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -7466,8 +7370,6 @@ static void sm6_parser_emit_dx_wave_active_bit(struct sm6_parser *dxil, enum dx_
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, opcode);
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -7526,8 +7428,6 @@ static void sm6_parser_emit_dx_wave_op(struct sm6_parser *dxil, enum dx_intrinsi
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, opcode);
     ins->flags = (op == DX_WAVE_PREFIX_OP) ? VKD3DSI_WAVE_PREFIX : 0;
 
@@ -8049,8 +7949,6 @@ static void sm6_parser_emit_cast(struct sm6_parser *dxil, struct function_emissi
 
     dst->type = type;
 
-    state->pushed_instruction = true;
-
     if (sm6_type_is_pointer(type))
     {
         *dst = *value;
@@ -8172,8 +8070,6 @@ static void sm6_parser_emit_cmp2(struct sm6_parser *dxil, struct function_emissi
 
     code = record->operands[i++];
 
-    state->pushed_instruction = true;
-
     /* dxcompiler occasionally emits bool not-equal-to-false, which is a no-op. Bool comparisons
      * do not otherwise occur, so deleting these avoids the need for backend support. */
     if (sm6_type_is_bool(type_a) && code == ICMP_NE && sm6_value_is_constant_zero(b))
@@ -8304,8 +8200,6 @@ static void sm6_parser_emit_cmpxchg(struct sm6_parser *dxil, struct function_emi
     if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    state->pushed_instruction = true;
-
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_IMM_ATOMIC_CMP_EXCH);
     ins->flags = is_volatile ? VKD3DARF_VOLATILE : 0;
 
@@ -8333,25 +8227,26 @@ static void sm6_parser_emit_cmpxchg(struct sm6_parser *dxil, struct function_emi
     dst_param_init(&dst_params[1]);
 }
 
-static void sm6_parser_emit_extractval(struct sm6_parser *sm6, const struct dxil_record *record,
-        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+static void sm6_parser_emit_extractval(struct sm6_parser *dxil, struct function_emission_state *state)
 {
+    struct sm6_value *dst = sm6_parser_get_current_value(dxil);
+    const struct dxil_record *record = state->record;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_param;
     const struct sm6_type *type;
     const struct sm6_value *src;
     unsigned int i = 0;
     uint64_t elem_idx;
 
-    if (!(src = sm6_parser_get_value_by_ref(sm6, record, NULL, &i)))
+    if (!(src = sm6_parser_get_value_by_ref(dxil, record, NULL, &i)))
         return;
 
-    if (!dxil_record_validate_operand_min_count(record, i + 1, sm6))
+    if (!dxil_record_validate_operand_min_count(record, i + 1, dxil))
         return;
 
     if (record->operand_count > i + 1)
     {
-        FIXME("Unhandled multiple indices.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Multiple extractval indices are not supported.");
         return;
     }
@@ -8359,8 +8254,7 @@ static void sm6_parser_emit_extractval(struct sm6_parser *sm6, const struct dxil
     type = src->type;
     if (!sm6_type_is_aggregate(type))
     {
-        WARN("Invalid extraction from non-aggregate.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Source type of an extractval instruction is not an aggregate.");
         return;
     }
@@ -8368,33 +8262,40 @@ static void sm6_parser_emit_extractval(struct sm6_parser *sm6, const struct dxil
     elem_idx = record->operands[i];
     if (!(type = sm6_type_get_element_type_at_index(type, elem_idx)))
     {
-        WARN("Invalid element index %"PRIu64".\n", elem_idx);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Element index %"PRIu64" for an extractval instruction is out of bounds.", elem_idx);
         return;
     }
     if (!sm6_type_is_scalar(type))
     {
-        FIXME("Nested extraction is not supported.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Extraction from nested aggregates is not supported.");
         return;
     }
     dst->type = type;
 
-    vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_MOV);
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
 
-    if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
+    vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOV);
+
+    if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
         return;
-    vsir_register_from_dxil_value(&src_param->reg, src, 0, sm6);
+    }
+
+    vsir_register_from_dxil_value(&src_param->reg, src, 0, dxil);
     src_param_init_scalar(src_param, elem_idx);
 
-    instruction_dst_param_init_ssa_scalar(ins, 0, sm6);
+    if (!instruction_dst_param_init_ssa_scalar(ins, 0, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
-static void sm6_parser_emit_gep(struct sm6_parser *sm6, const struct dxil_record *record,
-        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+static void sm6_parser_emit_gep(struct sm6_parser *dxil, struct function_emission_state *state)
 {
+    struct sm6_value *dst = sm6_parser_get_current_value(dxil);
+    const struct dxil_record *record = state->record;
     const struct sm6_type *type, *pointee_type;
     unsigned int elem_idx, operand_idx = 2;
     enum bitcode_address_space addr_space;
@@ -8402,130 +8303,113 @@ static void sm6_parser_emit_gep(struct sm6_parser *sm6, const struct dxil_record
     const struct sm6_value *src;
     struct sm6_index *index;
 
-    if (!dxil_record_validate_operand_min_count(record, 5, sm6)
-            || !(type = sm6_parser_get_type(sm6, record->operands[1]))
-            || !(src = sm6_parser_get_value_by_ref(sm6, record, NULL, &operand_idx))
-            || !sm6_value_validate_is_register(src, sm6)
-            || !sm6_value_validate_is_pointer(src, sm6)
-            || !dxil_record_validate_operand_min_count(record, operand_idx + 2, sm6))
-    {
+    if (!dxil_record_validate_operand_min_count(record, 5, dxil)
+            || !(type = sm6_parser_get_type(dxil, record->operands[1]))
+            || !(src = sm6_parser_get_value_by_ref(dxil, record, NULL, &operand_idx))
+            || !sm6_value_validate_is_register(src, dxil)
+            || !sm6_value_validate_is_pointer(src, dxil)
+            || !dxil_record_validate_operand_min_count(record, operand_idx + 2, dxil))
         return;
-    }
 
     *dst = *src;
-    index = sm6_get_value_index(sm6, dst);
+    index = sm6_get_value_index(dxil, dst);
 
     if (!index)
         return;
 
     if (index->index)
     {
-        WARN("Unsupported stacked GEP.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "A GEP instruction on the result of a previous GEP is unsupported.");
         return;
     }
 
     if ((pointee_type = src->type->u.pointer.type) != type)
-    {
-        WARN("Type mismatch, type %u width %u vs type %u width %u.\n", type->class,
-                type->u.width, pointee_type->class, pointee_type->u.width);
-        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+        vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
                 "Type mismatch in GEP operation arguments.");
-    }
     addr_space = src->type->u.pointer.addr_space;
 
-    if (!(elem_value = sm6_parser_get_value_by_ref(sm6, record, NULL, &operand_idx)))
+    if (!(elem_value = sm6_parser_get_value_by_ref(dxil, record, NULL, &operand_idx)))
         return;
 
     /* The first index is always zero, to form a simple pointer dereference. */
-    if (sm6_value_get_constant_uint(elem_value, sm6))
+    if (sm6_value_get_constant_uint(elem_value, dxil))
     {
-        WARN("Expected constant zero.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "The pointer dereference index for a GEP instruction is not constant zero.");
         return;
     }
 
     if (!sm6_type_is_array(pointee_type))
     {
-        WARN("Invalid GEP on type class %u.\n", pointee_type->class);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Source type for index 1 of a GEP instruction is not an array.");
         return;
     }
 
-    if (!(elem_value = sm6_parser_get_value_by_ref(sm6, record, NULL, &operand_idx)))
+    if (!(elem_value = sm6_parser_get_value_by_ref(dxil, record, NULL, &operand_idx)))
         return;
 
     /* If indexing is dynamic, just get the type at offset zero. */
-    elem_idx = sm6_value_is_constant(elem_value) ? sm6_value_get_constant_uint(elem_value, sm6) : 0;
+    elem_idx = sm6_value_is_constant(elem_value) ? sm6_value_get_constant_uint(elem_value, dxil) : 0;
     type = sm6_type_get_element_type_at_index(pointee_type, elem_idx);
     if (!type)
     {
-        WARN("Invalid element index %u.\n", elem_idx);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Element index %u for a GEP instruction is out of bounds.", elem_idx);
         return;
     }
 
     if (operand_idx < record->operand_count)
     {
-        FIXME("Multiple element indices are not implemented.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Multi-dimensional addressing in GEP instructions is not supported.");
         return;
     }
 
-    if (!(dst->type = sm6_type_get_pointer_to_type(type, addr_space, sm6)))
+    if (!(dst->type = sm6_type_get_pointer_to_type(type, addr_space, dxil)))
     {
-        WARN("Failed to get pointer type for type %u.\n", type->class);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
+        vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
                 "Module does not define a pointer type for a GEP instruction.");
         return;
     }
 
     index->index = elem_value;
     index->is_in_bounds = record->operands[0];
-
-    ins->opcode = VSIR_OP_NOP;
 }
 
-static void sm6_parser_emit_load(struct sm6_parser *sm6, const struct dxil_record *record,
-        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+static void sm6_parser_emit_load(struct sm6_parser *dxil, struct function_emission_state *state)
 {
+    struct sm6_value *dst = sm6_parser_get_current_value(dxil);
     const struct sm6_type *elem_type = NULL, *pointee_type;
+    const struct dxil_record *record = state->record;
     unsigned int alignment, operand_count, i = 0;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_params;
     struct vkd3d_shader_register reg;
     const struct sm6_value *ptr;
     uint64_t alignment_code;
 
-    if (!(ptr = sm6_parser_get_value_by_ref(sm6, record, NULL, &i)))
+    if (!(ptr = sm6_parser_get_value_by_ref(dxil, record, NULL, &i)))
         return;
-    if (!sm6_value_validate_is_register(ptr, sm6)
-            || !sm6_value_validate_is_pointer(ptr, sm6)
-            || !sm6_value_validate_is_backward_ref(ptr, sm6)
-            || !dxil_record_validate_operand_count(record, i + 2, i + 3, sm6))
+    if (!sm6_value_validate_is_register(ptr, dxil)
+            || !sm6_value_validate_is_pointer(ptr, dxil)
+            || !sm6_value_validate_is_backward_ref(ptr, dxil)
+            || !dxil_record_validate_operand_count(record, i + 2, i + 3, dxil))
         return;
 
-    if (record->operand_count > i + 2 && !(elem_type = sm6_parser_get_type(sm6, record->operands[i++])))
+    if (record->operand_count > i + 2 && !(elem_type = sm6_parser_get_type(dxil, record->operands[i++])))
         return;
 
     if (!elem_type)
-    {
         elem_type = ptr->type->u.pointer.type;
-    }
     else if (elem_type != (pointee_type = ptr->type->u.pointer.type))
-    {
-        WARN("Type mismatch.\n");
-        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+        vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
                 "Type mismatch in pointer load arguments.");
-    }
 
     dst->type = elem_type;
 
-    if (!sm6_value_validate_is_numeric(dst, sm6))
+    if (!sm6_value_validate_is_numeric(dst, dxil))
         return;
 
     alignment_code = record->operands[i++];
@@ -8535,22 +8419,29 @@ static void sm6_parser_emit_load(struct sm6_parser *sm6, const struct dxil_recor
     if (record->operands[i])
         WARN("Ignoring volatile modifier.\n");
 
-    vsir_register_from_dxil_value(&reg, ptr, 0, sm6);
+    vsir_register_from_dxil_value(&reg, ptr, 0, dxil);
+
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
 
     if (ptr->structure_stride)
     {
         VKD3D_ASSERT(reg.type == VKD3DSPR_GROUPSHAREDMEM);
-        vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_LD_STRUCTURED);
+        vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_LD_STRUCTURED);
 
-        if (!(src_params = instruction_src_params_alloc(ins, 3, sm6)))
+        if (!(src_params = instruction_src_params_alloc(ins, 3, dxil)))
+        {
+            vkd3d_shader_instruction_make_nop(ins);
             return;
+        }
+
         if (reg.idx[1].rel_addr)
             src_params[0] = *reg.idx[1].rel_addr;
         else
             src_param_make_constant_uint(&src_params[0], reg.idx[1].offset);
         /* Struct offset is always zero as there is no struct, just an array. */
         src_param_make_constant_uint(&src_params[1], 0);
-        src_param_init_from_value(&src_params[2], ptr, 0, sm6);
+        src_param_init_from_value(&src_params[2], ptr, 0, dxil);
         src_params[2].reg.alignment = alignment;
         /* The offset is already in src_params[0]. */
         src_params[2].reg.idx_count = 1;
@@ -8558,17 +8449,22 @@ static void sm6_parser_emit_load(struct sm6_parser *sm6, const struct dxil_recor
     else
     {
         operand_count = 1 + (reg.type == VKD3DSPR_GROUPSHAREDMEM);
-        vsir_instruction_init(ins, &sm6->p.location, (operand_count > 1) ? VSIR_OP_LD_RAW : VSIR_OP_MOV);
+        vsir_instruction_init(ins, &dxil->p.location, (operand_count > 1) ? VSIR_OP_LD_RAW : VSIR_OP_MOV);
 
-        if (!(src_params = instruction_src_params_alloc(ins, operand_count, sm6)))
+        if (!(src_params = instruction_src_params_alloc(ins, operand_count, dxil)))
+        {
+            vkd3d_shader_instruction_make_nop(ins);
             return;
+        }
+
         if (operand_count > 1)
             src_param_make_constant_uint(&src_params[0], 0);
-        src_param_init_from_value(&src_params[operand_count - 1], ptr, 0, sm6);
+        src_param_init_from_value(&src_params[operand_count - 1], ptr, 0, dxil);
         src_params[operand_count - 1].reg.alignment = alignment;
     }
 
-    instruction_dst_param_init_ssa_scalar(ins, 0, sm6);
+    if (!instruction_dst_param_init_ssa_scalar(ins, 0, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
 static int phi_incoming_compare(const void *a, const void *b)
@@ -8578,9 +8474,12 @@ static int phi_incoming_compare(const void *a, const void *b)
     return vkd3d_u32_compare(incoming_a->block_idx, incoming_b->block_idx);
 }
 
-static void sm6_parser_emit_phi(struct sm6_parser *dxil, const struct dxil_record *record,
-        struct sm6_function *function, struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+static void sm6_parser_emit_phi(struct sm6_parser *dxil, struct function_emission_state *state)
 {
+    struct sm6_value *dst = sm6_parser_get_current_value(dxil);
+    const struct dxil_record *record = state->record;
+    struct sm6_function *function = state->function;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_params;
     unsigned int i, j, incoming_count;
     struct incoming_value *incoming;
@@ -8659,9 +8558,16 @@ static void sm6_parser_emit_phi(struct sm6_parser *dxil, const struct dxil_recor
     }
     incoming_count = j;
 
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
+
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_PHI);
+
     if (!(src_params = instruction_src_params_alloc(ins, incoming_count * 2u, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
         goto done;
+    }
 
     for (i = 0; i < incoming_count; ++i)
     {
@@ -8670,15 +8576,18 @@ static void sm6_parser_emit_phi(struct sm6_parser *dxil, const struct dxil_recor
         vsir_src_operand_init_label(&src_params[j + 1], incoming[i].block_idx + 1);
     }
 
-    instruction_dst_param_init_ssa_scalar(ins, 0, dxil);
+    if (!instruction_dst_param_init_ssa_scalar(ins, 0, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 
 done:
     vkd3d_free(incoming);
 }
 
-static void sm6_parser_emit_ret(struct sm6_parser *dxil,
-        const struct dxil_record *record, struct vkd3d_shader_instruction *ins)
+static void sm6_parser_emit_ret(struct sm6_parser *dxil, struct function_emission_state *state)
 {
+    const struct dxil_record *record = state->record;
+    struct vkd3d_shader_instruction *ins;
+
     if (!dxil_record_validate_operand_count(record, 0, 1, dxil))
         return;
 
@@ -8686,42 +8595,41 @@ static void sm6_parser_emit_ret(struct sm6_parser *dxil,
         vkd3d_shader_parser_error(&dxil->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
                 "Non-void return is not implemented.");
 
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
+
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_RET);
 }
 
-static void sm6_parser_emit_store(struct sm6_parser *sm6, const struct dxil_record *record,
-        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+static void sm6_parser_emit_store(struct sm6_parser *dxil, struct function_emission_state *state)
 {
+    const struct dxil_record *record = state->record;
     unsigned int i = 0, alignment, operand_count;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_params;
     struct vsir_dst_operand *dst_param;
     const struct sm6_value *ptr, *src;
     struct vkd3d_shader_register reg;
     uint64_t alignment_code;
 
-    if (!(ptr = sm6_parser_get_value_by_ref(sm6, record, NULL, &i))
-            || !sm6_value_validate_is_register(ptr, sm6)
-            || !sm6_value_validate_is_pointer(ptr, sm6)
-            || !sm6_value_validate_is_backward_ref(ptr, sm6))
-    {
+    if (!(ptr = sm6_parser_get_value_by_ref(dxil, record, NULL, &i))
+            || !sm6_value_validate_is_register(ptr, dxil)
+            || !sm6_value_validate_is_pointer(ptr, dxil)
+            || !sm6_value_validate_is_backward_ref(ptr, dxil))
         return;
-    }
 
     /* Forward-referenced sources are stored as value/type pairs, even
      * though in principle we could use the destination type. */
-    if (!(src = sm6_parser_get_value_by_ref(sm6, record, NULL, &i)))
+    if (!(src = sm6_parser_get_value_by_ref(dxil, record, NULL, &i)))
         return;
-    if (!sm6_value_validate_is_numeric(src, sm6))
+    if (!sm6_value_validate_is_numeric(src, dxil))
         return;
 
     if (ptr->type->u.pointer.type != src->type)
-    {
-        WARN("Type mismatch.\n");
-        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+        vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
                 "Type mismatch in pointer store arguments.");
-    }
 
-    if (!dxil_record_validate_operand_count(record, i + 2, i + 2, sm6))
+    if (!dxil_record_validate_operand_count(record, i + 2, i + 2, dxil))
         return;
 
     alignment_code = record->operands[i++];
@@ -8731,36 +8639,52 @@ static void sm6_parser_emit_store(struct sm6_parser *sm6, const struct dxil_reco
     if (record->operands[i])
         WARN("Ignoring volatile modifier.\n");
 
-    vsir_register_from_dxil_value(&reg, ptr, 0, sm6);
+    vsir_register_from_dxil_value(&reg, ptr, 0, dxil);
+
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
 
     if (ptr->structure_stride)
     {
         VKD3D_ASSERT(reg.type == VKD3DSPR_GROUPSHAREDMEM);
-        vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_STORE_STRUCTURED);
+        vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_STORE_STRUCTURED);
 
-        if (!(src_params = instruction_src_params_alloc(ins, 3, sm6)))
+        if (!(src_params = instruction_src_params_alloc(ins, 3, dxil)))
+        {
+            vkd3d_shader_instruction_make_nop(ins);
             return;
+        }
+
         if (reg.idx[1].rel_addr)
             src_params[0] = *reg.idx[1].rel_addr;
         else
             src_param_make_constant_uint(&src_params[0], reg.idx[1].offset);
         /* Struct offset is always zero as there is no struct, just an array. */
         src_param_make_constant_uint(&src_params[1], 0);
-        src_param_init_from_value(&src_params[2], src, 0, sm6);
+        src_param_init_from_value(&src_params[2], src, 0, dxil);
     }
     else
     {
         operand_count = 1 + (reg.type == VKD3DSPR_GROUPSHAREDMEM);
-        vsir_instruction_init(ins, &sm6->p.location, (operand_count > 1) ? VSIR_OP_STORE_RAW : VSIR_OP_MOV);
+        vsir_instruction_init(ins, &dxil->p.location, (operand_count > 1) ? VSIR_OP_STORE_RAW : VSIR_OP_MOV);
 
-        if (!(src_params = instruction_src_params_alloc(ins, operand_count, sm6)))
+        if (!(src_params = instruction_src_params_alloc(ins, operand_count, dxil)))
+        {
+            vkd3d_shader_instruction_make_nop(ins);
             return;
+        }
+
         if (operand_count > 1)
             src_param_make_constant_uint(&src_params[0], 0);
-        src_param_init_from_value(&src_params[operand_count - 1], src, 0, sm6);
+        src_param_init_from_value(&src_params[operand_count - 1], src, 0, dxil);
+    }
+
+    if (!(dst_param = instruction_dst_params_alloc(ins, 1, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
+        return;
     }
 
-    dst_param = instruction_dst_params_alloc(ins, 1, sm6);
     dst_param_init(dst_param);
     dst_param->reg = reg;
     dst_param->reg.alignment = alignment;
@@ -8769,9 +8693,11 @@ static void sm6_parser_emit_store(struct sm6_parser *sm6, const struct dxil_reco
         dst_param->reg.idx_count = 1;
 }
 
-static void sm6_parser_emit_switch(struct sm6_parser *dxil, const struct dxil_record *record,
-        struct sm6_function *function, struct vkd3d_shader_instruction *ins)
+static void sm6_parser_emit_switch(struct sm6_parser *dxil, struct function_emission_state *state)
 {
+    const struct dxil_record *record = state->record;
+    struct sm6_function *function = state->function;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_params;
     const struct sm6_type *type;
     const struct sm6_value *src;
@@ -8807,7 +8733,11 @@ static void sm6_parser_emit_switch(struct sm6_parser *dxil, const struct dxil_re
     if (!sm6_function_validate_block_index(function, record->operands[2], dxil))
         return;
 
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
+
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_SWITCH_MONOLITHIC);
+
     if (!(src_params = instruction_src_params_alloc(ins, record->operand_count, dxil)))
     {
         vkd3d_shader_instruction_make_nop(ins);
@@ -8863,42 +8793,51 @@ static void sm6_parser_emit_switch(struct sm6_parser *dxil, const struct dxil_re
     }
 }
 
-static void sm6_parser_emit_vselect(struct sm6_parser *sm6, const struct dxil_record *record,
-        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+static void sm6_parser_emit_vselect(struct sm6_parser *dxil, struct function_emission_state *state)
 {
+    struct sm6_value *dst = sm6_parser_get_current_value(dxil);
+    const struct dxil_record *record = state->record;
+    struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_params;
     const struct sm6_value *src[3];
     unsigned int i = 0;
 
-    if (!(src[1] = sm6_parser_get_value_by_ref(sm6, record, NULL, &i))
-            || !(src[2] = sm6_parser_get_value_by_ref(sm6, record, src[1]->type, &i))
-            || !(src[0] = sm6_parser_get_value_by_ref(sm6, record, NULL, &i)))
-    {
+    if (!(src[1] = sm6_parser_get_value_by_ref(dxil, record, NULL, &i))
+            || !(src[2] = sm6_parser_get_value_by_ref(dxil, record, src[1]->type, &i))
+            || !(src[0] = sm6_parser_get_value_by_ref(dxil, record, NULL, &i)))
         return;
-    }
-    dxil_record_validate_operand_max_count(record, i, sm6);
+
+    dxil_record_validate_operand_max_count(record, i, dxil);
 
     for (i = 0; i < 3; ++i)
     {
-        if (!sm6_value_validate_is_register(src[i], sm6))
+        if (!sm6_value_validate_is_register(src[i], dxil))
             return;
     }
 
     dst->type = src[1]->type;
 
-    if (!sm6_value_validate_is_bool(src[0], sm6))
+    if (!sm6_value_validate_is_bool(src[0], dxil))
+        return;
+
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
         return;
 
-    vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_MOVC);
+    vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_MOVC);
 
-    if (!(src_params = instruction_src_params_alloc(ins, 3, sm6)))
+    if (!(src_params = instruction_src_params_alloc(ins, 3, dxil)))
+    {
+        vkd3d_shader_instruction_make_nop(ins);
         return;
+    }
+
     for (i = 0; i < 3; ++i)
     {
-        src_param_init_from_value(&src_params[i], src[i], 0, sm6);
+        src_param_init_from_value(&src_params[i], src[i], 0, dxil);
     }
 
-    instruction_dst_param_init_ssa_scalar(ins, 0, sm6);
+    if (!instruction_dst_param_init_ssa_scalar(ins, 0, dxil))
+        vkd3d_shader_instruction_make_nop(ins);
 }
 
 static bool sm6_metadata_value_is_node(const struct sm6_metadata_value *m)
@@ -9090,7 +9029,7 @@ static bool metadata_node_get_unary_uint(const struct sm6_metadata_node *node, u
 }
 
 static void metadata_attachment_record_apply(const struct dxil_record *record, enum bitcode_function_code func_code,
-        struct vkd3d_shader_instruction *ins, struct sm6_value *dst, struct sm6_parser *sm6)
+        struct vsir_program_iterator *it, struct sm6_value *dst, struct sm6_parser *dxil)
 {
     static const char *ignored_names[] =
     {
@@ -9108,29 +9047,24 @@ static void metadata_attachment_record_apply(const struct dxil_record *record, e
     const char *name;
 
     if (record->attachment)
-    {
-        WARN("Ignoring nested metadata attachment.\n");
-        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+        vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
                 "Ignoring a nested metadata attachment.");
-    }
 
     VKD3D_ASSERT(record->operand_count & 1);
     for (i = 1; i < record->operand_count; i += 2)
     {
-        if (!(m = sm6_parser_find_metadata_kind(sm6, record->operands[i])))
+        if (!(m = sm6_parser_find_metadata_kind(dxil, record->operands[i])))
         {
-            WARN("Failed to find metadata kind %"PRIx64".\n", record->operands[i]);
-            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+            vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
                     "Failed to find metadata kind %"PRIx64" for an attachment.", record->operands[i]);
             continue;
         }
         name = m->u.kind.name;
 
-        m = sm6_parser_metadata_get_value(sm6, record->operands[i + 1]);
+        m = sm6_parser_metadata_get_value(dxil, record->operands[i + 1]);
         if (!m || !sm6_metadata_value_is_node(m))
         {
-            WARN("Failed to retrieve metadata attachment node.\n");
-            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+            vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
                     "Failed to retrieve a metadata attachment node.");
             continue;
         }
@@ -9140,39 +9074,39 @@ static void metadata_attachment_record_apply(const struct dxil_record *record, e
         {
             if (!sm6_value_is_register(dst))
             {
-                WARN("Precise value is not a register.\n");
-                vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
                         "A value marked as precise is not a register.");
             }
-            else if (metadata_node_get_unary_uint(node, &operand, sm6) && operand)
+            else if (metadata_node_get_unary_uint(node, &operand, dxil) && operand)
             {
-                ins->flags |= sm6_type_is_scalar(dst->type) ? VKD3DSI_PRECISE_X : VKD3DSI_PRECISE_XYZW;
+                /* The iterator is set to the last vsir instruction before those
+                 * that were inserted by the current DXIL instruction. */
+                struct vkd3d_shader_instruction *ins = vsir_program_iterator_next(it);
+
+                for (; ins; ins = vsir_program_iterator_next(it))
+                {
+                    ins->flags |= sm6_type_is_scalar(dst->type) ? VKD3DSI_PRECISE_X : VKD3DSI_PRECISE_XYZW;
+                }
             }
         }
         else if (!strcmp(name, "dx.nonuniform"))
         {
             if (!sm6_value_is_register(dst))
-            {
-                WARN("Non-uniform value is not a register.\n");
-                vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
                         "A value marked as non-uniform is not a register.");
-            }
-            else if (metadata_node_get_unary_uint(node, &operand, sm6))
-            {
+            else if (metadata_node_get_unary_uint(node, &operand, dxil))
                 dst->non_uniform = !!operand;
-            }
         }
         else
         {
             for (j = 0; j < ARRAY_SIZE(ignored_names); ++j)
+            {
                 if (!strcmp(name, ignored_names[j]))
                     break;
+            }
             if (j == ARRAY_SIZE(ignored_names))
-            {
-                WARN("Ignoring metadata attachment '%s'.\n", name);
-                vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                vkd3d_shader_parser_warning(&dxil->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
                         "Ignoring a metadata attachment named '%s'.", name);
-            }
             ignored = true;
         }
 
@@ -9181,12 +9115,14 @@ static void metadata_attachment_record_apply(const struct dxil_record *record, e
     }
 }
 
-static void sm6_function_emit_label(struct sm6_function *function, unsigned int label_id, struct sm6_parser *dxil)
+static void dxil_emit_function_label(struct sm6_parser *dxil,
+        struct function_emission_state *state, unsigned int label_id)
 {
     struct vkd3d_shader_instruction *ins;
     struct vsir_src_operand *src_param;
 
-    ins = &function->instructions.elements[function->instructions.count++];
+    if (!(ins = sm6_parser_add_function_instruction(dxil, state)))
+        return;
 
     vsir_instruction_init(ins, &dxil->p.location, VSIR_OP_LABEL);
     if (!(src_param = instruction_src_params_alloc(ins, 1, dxil)))
@@ -9201,14 +9137,16 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6,
         const struct dxil_block *block, struct sm6_function *function)
 {
     struct vsir_program *program = sm6->program;
-    struct vkd3d_shader_instruction *ins;
     size_t i, block_idx, block_count;
     const struct dxil_record *record;
+    struct vsir_program_iterator it;
     const struct sm6_type *fwd_type;
     bool ret_found, is_terminator;
     bool emitted_label = false;
     struct sm6_value *dst;
 
+    it = vsir_program_iterator(&function->instructions);
+
     if (!(function->declaration = sm6_parser_next_function_definition(sm6)))
     {
         WARN("Failed to find definition to match function body.\n");
@@ -9251,25 +9189,18 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6,
             return VKD3D_ERROR_INVALID_SHADER;
         }
 
-        /* Some instructions can emit >1 IR instruction, so extra may be used. */
-        if (!vkd3d_array_reserve((void **)&function->instructions.elements, &function->instructions.capacity,
-                function->instructions.count + !emitted_label + MAX_IR_INSTRUCTIONS_PER_DXIL_INSTRUCTION,
-                sizeof(*function->instructions.elements)))
-        {
-            ERR("Failed to allocate instructions.\n");
-            return VKD3D_ERROR_OUT_OF_MEMORY;
-        }
+        state.function = function;
+        state.record = block->records[i];
 
         if (!emitted_label)
         {
             /* Label id is 1-based. Do not emit a label until it is known that
              * instructions will follow. */
-            sm6_function_emit_label(function, block_idx + 1, sm6);
+            dxil_emit_function_label(sm6, &state, block_idx + 1);
             emitted_label = true;
         }
 
-        ins = &function->instructions.elements[function->instructions.count];
-        ins->opcode = VSIR_OP_INVALID;
+        vsir_program_iterator_tail(&it);
 
         dst = sm6_parser_get_current_value(sm6);
         fwd_type = dst->type;
@@ -9277,10 +9208,6 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6,
         dst->is_back_ref = true;
         is_terminator = false;
 
-        state.function = function;
-        state.record = block->records[i];
-        state.ins = ins;
-
         record = block->records[i];
         switch (record->code)
         {
@@ -9310,31 +9237,31 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6,
                 sm6_parser_emit_cmpxchg(sm6, &state);
                 break;
             case FUNC_CODE_INST_EXTRACTVAL:
-                sm6_parser_emit_extractval(sm6, record, ins, dst);
+                sm6_parser_emit_extractval(sm6, &state);
                 break;
             case FUNC_CODE_INST_GEP:
-                sm6_parser_emit_gep(sm6, record, ins, dst);
+                sm6_parser_emit_gep(sm6, &state);
                 break;
             case FUNC_CODE_INST_LOAD:
-                sm6_parser_emit_load(sm6, record, ins, dst);
+                sm6_parser_emit_load(sm6, &state);
                 break;
             case FUNC_CODE_INST_PHI:
-                sm6_parser_emit_phi(sm6, record, function, ins, dst);
+                sm6_parser_emit_phi(sm6, &state);
                 break;
             case FUNC_CODE_INST_RET:
-                sm6_parser_emit_ret(sm6, record, ins);
+                sm6_parser_emit_ret(sm6, &state);
                 is_terminator = true;
                 ret_found = true;
                 break;
             case FUNC_CODE_INST_STORE:
-                sm6_parser_emit_store(sm6, record, ins, dst);
+                sm6_parser_emit_store(sm6, &state);
                 break;
             case FUNC_CODE_INST_SWITCH:
-                sm6_parser_emit_switch(sm6, record, function, ins);
+                sm6_parser_emit_switch(sm6, &state);
                 is_terminator = true;
                 break;
             case FUNC_CODE_INST_VSELECT:
-                sm6_parser_emit_vselect(sm6, record, ins, dst);
+                sm6_parser_emit_vselect(sm6, &state);
                 break;
             default:
                 FIXME("Unhandled dxil instruction %u.\n", record->code);
@@ -9347,10 +9274,7 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6,
             return sm6->p.status;
 
         if (record->attachment)
-            metadata_attachment_record_apply(record->attachment, record->code, ins, dst, sm6);
-
-        if (!state.pushed_instruction)
-            function->instructions.count += ins->opcode != VSIR_OP_NOP;
+            metadata_attachment_record_apply(record->attachment, record->code, &it, dst, sm6);
 
         if (is_terminator)
         {
@@ -9422,6 +9346,34 @@ static void sm6_parser_init_parameter_attributes(struct sm6_parser *dxil, const
     }
 }
 
+static void dxil_attribute_group_cleanup(struct dxil_attribute_group *group)
+{
+    struct dxil_attribute *attribute;
+    size_t i;
+
+    for (i = 0; i < group->attribute_count; ++i)
+    {
+        attribute = &group->attributes[i];
+
+        switch (attribute->kind)
+        {
+            case ATTRIBUTE_WELL_KNOWN:
+            case ATTRIBUTE_WELL_KNOWN_WITH_INTEGER_VALUE:
+                break;
+
+            case ATTRIBUTE_STRING:
+                vkd3d_free((void *)attribute->key.string);
+                break;
+
+            case ATTRIBUTE_STRING_WITH_STRING_VALUE:
+                vkd3d_free((void *)attribute->key.string);
+                vkd3d_free((void *)attribute->value.string);
+                break;
+        }
+    }
+    vkd3d_free(group->attributes);
+}
+
 static void sm6_parser_init_attribute_groups(struct sm6_parser *dxil, const struct dxil_block *block)
 {
     size_t i, j;
@@ -10888,7 +10840,7 @@ static enum vkd3d_result sm6_parser_read_signature(struct sm6_parser *sm6, const
                 "Failed to allocate signature element semantic name.");
         for (j = 0; j < i; ++j)
         {
-            vkd3d_free((void *)elements[j].semantic_name);
+            vsir_signature_element_cleanup(&elements[j]);
         }
         vkd3d_free(elements);
         return VKD3D_ERROR_OUT_OF_MEMORY;
@@ -11597,32 +11549,11 @@ static void sm6_parser_cleanup_parameter_attributes(struct sm6_parser *sm6)
 
 static void sm6_parser_cleanup_attribute_groups(struct sm6_parser *dxil)
 {
-    struct dxil_attribute_group *group;
-    struct dxil_attribute *attribute;
-    size_t i, j;
+    size_t i;
 
     for (i = 0; i < dxil->attribute_group_count; ++i)
     {
-        group = &dxil->attribute_groups[i];
-        for (j = 0; j < group->attribute_count; ++j)
-        {
-            attribute = &group->attributes[j];
-            switch (attribute->kind)
-            {
-                case ATTRIBUTE_WELL_KNOWN:
-                case ATTRIBUTE_WELL_KNOWN_WITH_INTEGER_VALUE:
-                    break;
-
-                case ATTRIBUTE_STRING:
-                    vkd3d_free((void *)attribute->key.string);
-                    break;
-
-                case ATTRIBUTE_STRING_WITH_STRING_VALUE:
-                    vkd3d_free((void *)attribute->key.string);
-                    vkd3d_free((void *)attribute->value.string);
-                    break;
-            }
-        }
+        dxil_attribute_group_cleanup(&dxil->attribute_groups[i]);
     }
 
     vkd3d_free(dxil->attribute_groups);
diff --git a/libs/vkd3d/libs/vkd3d-shader/fx.c b/libs/vkd3d/libs/vkd3d-shader/fx.c
index 67706bba902..13d75269969 100644
--- a/libs/vkd3d/libs/vkd3d-shader/fx.c
+++ b/libs/vkd3d/libs/vkd3d-shader/fx.c
@@ -379,6 +379,7 @@ static void write_fx_4_annotation(struct hlsl_ir_var *var, struct fx_write_conte
 static uint32_t write_type(const struct type_entry *type, struct fx_write_context *fx)
 {
     struct type_entry *type_entry;
+    uint32_t offset;
 
     /* We don't try to reuse nameless types; they will get the same
      * "<unnamed>" name, but are not available for the type cache. */
@@ -402,16 +403,19 @@ static uint32_t write_type(const struct type_entry *type, struct fx_write_contex
         }
     }
 
+    offset = write_fx_4_type(type, fx);
+
+    if (!type->name)
+        return offset;
+
     if (!(type_entry = hlsl_alloc(fx->ctx, sizeof(*type_entry))))
-        return 0;
+        return offset;
 
     *type_entry = *type;
-    type_entry->offset = write_fx_4_type(type, fx);
-
-    if (type_entry->name)
-        list_add_tail(&fx->types, &type_entry->entry);
+    type_entry->offset = offset;
+    list_add_tail(&fx->types, &type_entry->entry);
 
-    return type_entry->offset;
+    return offset;
 }
 
 static void type_entry_from_type(struct type_entry *e, const struct hlsl_type *type, const struct fx_write_context *fx)
@@ -1147,6 +1151,7 @@ enum fx_4_type_constants
     FX_4_OBJECT_TYPE_RTV = 0x13,
     FX_4_OBJECT_TYPE_DSV = 0x14,
     FX_4_OBJECT_TYPE_SAMPLER_STATE = 0x15,
+    FX_4_OBJECT_TYPE_BUFFER = 0x16,
     FX_4_OBJECT_TYPE_TEXTURE_CUBEARRAY = 0x17,
 
     FX_5_OBJECT_TYPE_GEOMETRY_SHADER = 0x1b,
@@ -1241,16 +1246,19 @@ static const char * get_fx_4_type_name(const struct hlsl_type *type)
 {
     static const char * const texture_type_names[] =
     {
-        [HLSL_SAMPLER_DIM_GENERIC]   = "texture",
-        [HLSL_SAMPLER_DIM_1D]        = "Texture1D",
-        [HLSL_SAMPLER_DIM_1DARRAY]   = "Texture1DArray",
-        [HLSL_SAMPLER_DIM_2D]        = "Texture2D",
-        [HLSL_SAMPLER_DIM_2DARRAY]   = "Texture2DArray",
-        [HLSL_SAMPLER_DIM_2DMS]      = "Texture2DMS",
-        [HLSL_SAMPLER_DIM_2DMSARRAY] = "Texture2DMSArray",
-        [HLSL_SAMPLER_DIM_3D]        = "Texture3D",
-        [HLSL_SAMPLER_DIM_CUBE]      = "TextureCube",
-        [HLSL_SAMPLER_DIM_CUBEARRAY] = "TextureCubeArray",
+        [HLSL_SAMPLER_DIM_GENERIC]           = "texture",
+        [HLSL_SAMPLER_DIM_1D]                = "Texture1D",
+        [HLSL_SAMPLER_DIM_1DARRAY]           = "Texture1DArray",
+        [HLSL_SAMPLER_DIM_2D]                = "Texture2D",
+        [HLSL_SAMPLER_DIM_2DARRAY]           = "Texture2DArray",
+        [HLSL_SAMPLER_DIM_2DMS]              = "Texture2DMS",
+        [HLSL_SAMPLER_DIM_2DMSARRAY]         = "Texture2DMSArray",
+        [HLSL_SAMPLER_DIM_3D]                = "Texture3D",
+        [HLSL_SAMPLER_DIM_CUBE]              = "TextureCube",
+        [HLSL_SAMPLER_DIM_CUBEARRAY]         = "TextureCubeArray",
+        [HLSL_SAMPLER_DIM_BUFFER]            = "Buffer",
+        [HLSL_SAMPLER_DIM_STRUCTURED_BUFFER] = "StructuredBuffer",
+        [HLSL_SAMPLER_DIM_RAW_BUFFER]        = "ByteAddressBuffer",
     };
     static const char * const uav_type_names[] =
     {
@@ -1270,9 +1278,11 @@ static const char * get_fx_4_type_name(const struct hlsl_type *type)
             return "SamplerState";
 
         case HLSL_CLASS_TEXTURE:
+            VKD3D_ASSERT(type->sampler_dim < ARRAY_SIZE(texture_type_names));
             return texture_type_names[type->sampler_dim];
 
         case HLSL_CLASS_UAV:
+            VKD3D_ASSERT(type->sampler_dim < ARRAY_SIZE(uav_type_names));
             return uav_type_names[type->sampler_dim];
 
         case HLSL_CLASS_DEPTH_STENCIL_STATE:
@@ -1436,18 +1446,22 @@ static uint32_t write_fx_4_type(const struct type_entry *type, struct fx_write_c
     {
         static const uint32_t texture_type[] =
         {
-            [HLSL_SAMPLER_DIM_GENERIC]   = FX_4_OBJECT_TYPE_TEXTURE,
-            [HLSL_SAMPLER_DIM_1D]        = FX_4_OBJECT_TYPE_TEXTURE_1D,
-            [HLSL_SAMPLER_DIM_1DARRAY]   = FX_4_OBJECT_TYPE_TEXTURE_1DARRAY,
-            [HLSL_SAMPLER_DIM_2D]        = FX_4_OBJECT_TYPE_TEXTURE_2D,
-            [HLSL_SAMPLER_DIM_2DARRAY]   = FX_4_OBJECT_TYPE_TEXTURE_2DARRAY,
-            [HLSL_SAMPLER_DIM_2DMS]      = FX_4_OBJECT_TYPE_TEXTURE_2DMS,
-            [HLSL_SAMPLER_DIM_2DMSARRAY] = FX_4_OBJECT_TYPE_TEXTURE_2DMSARRAY,
-            [HLSL_SAMPLER_DIM_3D]        = FX_4_OBJECT_TYPE_TEXTURE_3D,
-            [HLSL_SAMPLER_DIM_CUBE]      = FX_4_OBJECT_TYPE_TEXTURE_CUBE,
-            [HLSL_SAMPLER_DIM_CUBEARRAY] = FX_4_OBJECT_TYPE_TEXTURE_CUBEARRAY,
+            [HLSL_SAMPLER_DIM_GENERIC]           = FX_4_OBJECT_TYPE_TEXTURE,
+            [HLSL_SAMPLER_DIM_1D]                = FX_4_OBJECT_TYPE_TEXTURE_1D,
+            [HLSL_SAMPLER_DIM_1DARRAY]           = FX_4_OBJECT_TYPE_TEXTURE_1DARRAY,
+            [HLSL_SAMPLER_DIM_2D]                = FX_4_OBJECT_TYPE_TEXTURE_2D,
+            [HLSL_SAMPLER_DIM_2DARRAY]           = FX_4_OBJECT_TYPE_TEXTURE_2DARRAY,
+            [HLSL_SAMPLER_DIM_2DMS]              = FX_4_OBJECT_TYPE_TEXTURE_2DMS,
+            [HLSL_SAMPLER_DIM_2DMSARRAY]         = FX_4_OBJECT_TYPE_TEXTURE_2DMSARRAY,
+            [HLSL_SAMPLER_DIM_3D]                = FX_4_OBJECT_TYPE_TEXTURE_3D,
+            [HLSL_SAMPLER_DIM_CUBE]              = FX_4_OBJECT_TYPE_TEXTURE_CUBE,
+            [HLSL_SAMPLER_DIM_CUBEARRAY]         = FX_4_OBJECT_TYPE_TEXTURE_CUBEARRAY,
+            [HLSL_SAMPLER_DIM_BUFFER]            = FX_4_OBJECT_TYPE_BUFFER,
+            [HLSL_SAMPLER_DIM_STRUCTURED_BUFFER] = FX_5_OBJECT_TYPE_SRV_STRUCTURED_BUFFER,
+            [HLSL_SAMPLER_DIM_RAW_BUFFER]        = FX_5_OBJECT_TYPE_SRV_RAW_BUFFER,
         };
 
+        VKD3D_ASSERT(element_type->sampler_dim < ARRAY_SIZE(texture_type));
         put_u32_unaligned(buffer, texture_type[element_type->sampler_dim]);
     }
     else if (element_type->class == HLSL_CLASS_SAMPLER)
@@ -1468,6 +1482,7 @@ static uint32_t write_fx_4_type(const struct type_entry *type, struct fx_write_c
             [HLSL_SAMPLER_DIM_RAW_BUFFER]        = FX_5_OBJECT_TYPE_UAV_RAW_BUFFER,
         };
 
+        VKD3D_ASSERT(element_type->sampler_dim < ARRAY_SIZE(uav_type));
         put_u32_unaligned(buffer, uav_type[element_type->sampler_dim]);
     }
     else if (element_type->class == HLSL_CLASS_DEPTH_STENCIL_VIEW)
@@ -2147,10 +2162,8 @@ static int hlsl_fx_2_write(struct hlsl_ctx *ctx, struct vkd3d_shader_code *out)
         ctx->result = fx.status;
 
     if (!ctx->result)
-    {
-        out->code = buffer.data;
-        out->size = buffer.size;
-    }
+        vkd3d_shader_code_from_bytecode_buffer(out, &buffer);
+    vkd3d_bytecode_buffer_cleanup(&buffer);
 
     return fx_write_context_cleanup(&fx);
 }
@@ -3215,7 +3228,7 @@ static unsigned int decompose_fx_4_state_function_call(struct hlsl_ir_var *var,
     const struct state_block_function_info *info;
     struct function_component components[9];
     struct hlsl_ctx *ctx = fx->ctx;
-    unsigned int i;
+    unsigned int i, count;
 
     if (!entry->is_function_call)
         return 1;
@@ -3243,16 +3256,16 @@ static unsigned int decompose_fx_4_state_function_call(struct hlsl_ir_var *var,
 
     get_state_block_function_components(info, components, entry->args_count);
 
-    for (i = 0; i < entry->args_count; ++i)
+    for (i = 0, count = entry->args_count; i < count; ++i)
     {
         const struct function_component *comp = &components[i];
-        unsigned int arg_index = (i + 1) % entry->args_count;
+        unsigned int arg_index = (i + 1) % count;
         block->entries[entry_index + i] = clone_stateblock_entry(ctx, entry, comp->name,
                 comp->lhs_has_index, comp->lhs_index, true, arg_index);
     }
     hlsl_free_state_block_entry(entry);
 
-    return entry->args_count;
+    return count;
 }
 
 /* For some states assignment sets all of the elements. This behaviour is limited to certain states of BlendState
@@ -3581,7 +3594,6 @@ static bool is_supported_object_variable(const struct hlsl_ctx *ctx, const struc
         case HLSL_CLASS_RASTERIZER_STATE:
         case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_SAMPLER:
-        case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_BLEND_STATE:
         case HLSL_CLASS_VERTEX_SHADER:
         case HLSL_CLASS_GEOMETRY_SHADER:
@@ -3593,6 +3605,13 @@ static bool is_supported_object_variable(const struct hlsl_ctx *ctx, const struc
             if (ctx->profile->major_version < 5)
                 return false;
             return true;
+        case HLSL_CLASS_TEXTURE:
+            if (ctx->profile->major_version >= 5)
+                return true;
+            if (type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER
+                    || type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
+                return false;
+            return true;
         case HLSL_CLASS_UAV:
             if (ctx->profile->major_version < 5)
                 return false;
@@ -3676,10 +3695,8 @@ static int hlsl_fx_4_write(struct hlsl_ctx *ctx, struct vkd3d_shader_code *out)
         ctx->result = fx.status;
 
     if (!ctx->result)
-    {
-        out->code = buffer.data;
-        out->size = buffer.size;
-    }
+        vkd3d_shader_code_from_bytecode_buffer(out, &buffer);
+    vkd3d_bytecode_buffer_cleanup(&buffer);
 
     return fx_write_context_cleanup(&fx);
 }
@@ -3739,10 +3756,8 @@ static int hlsl_fx_5_write(struct hlsl_ctx *ctx, struct vkd3d_shader_code *out)
         ctx->result = fx.status;
 
     if (!ctx->result)
-    {
-        out->code = buffer.data;
-        out->size = buffer.size;
-    }
+        vkd3d_shader_code_from_bytecode_buffer(out, &buffer);
+    vkd3d_bytecode_buffer_cleanup(&buffer);
 
     return fx_write_context_cleanup(&fx);
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index b62a087d290..1d0bafa4cd8 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -2220,12 +2220,16 @@ struct hlsl_ir_node *hlsl_block_add_resource_load(struct hlsl_ctx *ctx, struct h
     return append_new_instr(ctx, block, &load->node);
 }
 
-static struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx,
-        enum hlsl_resource_store_type type, const struct hlsl_deref *resource, struct hlsl_ir_node *coords,
+static struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx, enum hlsl_resource_store_type type,
+        const struct hlsl_deref *resource, struct hlsl_ir_node *byte_offset, struct hlsl_ir_node *coords,
         struct hlsl_ir_node *value, uint32_t writemask, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_resource_store *store;
 
+    if (type != HLSL_RESOURCE_STORE
+            || hlsl_deref_get_type(ctx, resource)->sampler_dim != HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
+        VKD3D_ASSERT(!byte_offset);
+
     if (!(store = hlsl_alloc(ctx, sizeof(*store))))
         return NULL;
     init_node(&store->node, HLSL_IR_RESOURCE_STORE, NULL, loc);
@@ -2233,16 +2237,19 @@ static struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx,
     store->writemask = writemask;
 
     hlsl_copy_deref(ctx, &store->resource, resource);
+    hlsl_src_from_node(&store->byte_offset, byte_offset);
     hlsl_src_from_node(&store->coords, coords);
     hlsl_src_from_node(&store->value, value);
     return &store->node;
 }
 
 struct hlsl_ir_node *hlsl_block_add_resource_store(struct hlsl_ctx *ctx, struct hlsl_block *block,
-        enum hlsl_resource_store_type type, const struct hlsl_deref *resource, struct hlsl_ir_node *coords,
-        struct hlsl_ir_node *value, uint32_t writemask, const struct vkd3d_shader_location *loc)
+        enum hlsl_resource_store_type type, const struct hlsl_deref *resource,
+        struct hlsl_ir_node *byte_offset, struct hlsl_ir_node *coords, struct hlsl_ir_node *value,
+        uint32_t writemask, const struct vkd3d_shader_location *loc)
 {
-    return append_new_instr(ctx, block, hlsl_new_resource_store(ctx, type, resource, coords, value, writemask, loc));
+    return append_new_instr(ctx, block, hlsl_new_resource_store(ctx, type,
+            resource, byte_offset, coords, value, writemask, loc));
 }
 
 struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, uint32_t s, unsigned int component_count,
@@ -2512,13 +2519,13 @@ bool hlsl_index_is_resource_access(struct hlsl_ir_index *index)
     return type->class == HLSL_CLASS_TEXTURE || type->class == HLSL_CLASS_UAV;
 }
 
-bool hlsl_index_chain_has_resource_access(struct hlsl_ir_index *index)
+struct hlsl_ir_index *hlsl_index_chain_find_resource_access(struct hlsl_ir_index *index)
 {
     if (hlsl_index_is_resource_access(index))
-        return true;
+        return index;
     if (index->val.node->type == HLSL_IR_INDEX)
-        return hlsl_index_chain_has_resource_access(hlsl_ir_index(index->val.node));
-    return false;
+        return hlsl_index_chain_find_resource_access(hlsl_ir_index(index->val.node));
+    return NULL;
 }
 
 bool hlsl_index_chain_has_tgsm_access(struct hlsl_ir_index *index)
@@ -2836,6 +2843,7 @@ static struct hlsl_ir_node *clone_resource_store(struct hlsl_ctx *ctx,
     }
     clone_src(map, &dst->coords, &src->coords);
     clone_src(map, &dst->value, &src->value);
+    clone_src(map, &dst->byte_offset, &src->byte_offset);
     return &dst->node;
 }
 
@@ -3131,7 +3139,7 @@ struct hlsl_ir_node *hlsl_clone_instr(struct hlsl_ctx *ctx, const struct hlsl_ir
     return ret;
 }
 
-struct hlsl_ir_function_decl *hlsl_new_func_decl(struct hlsl_ctx *ctx,
+struct hlsl_ir_function_decl *hlsl_new_func_decl(struct hlsl_ctx *ctx, uint32_t storage_modifiers,
         struct hlsl_type *return_type, const struct hlsl_func_parameters *parameters,
         const struct hlsl_semantic *semantic, const struct vkd3d_shader_location *loc)
 {
@@ -3141,6 +3149,7 @@ struct hlsl_ir_function_decl *hlsl_new_func_decl(struct hlsl_ctx *ctx,
     if (!(decl = hlsl_alloc(ctx, sizeof(*decl))))
         return NULL;
     hlsl_block_init(&decl->body);
+    decl->storage_modifiers = storage_modifiers;
     decl->return_type = return_type;
     decl->parameters = *parameters;
     decl->loc = *loc;
@@ -3990,6 +3999,11 @@ static void dump_ir_resource_store(struct hlsl_ctx *ctx,
         vkd3d_string_buffer_printf(buffer, ", value = ");
         dump_src(buffer, &store->value);
     }
+    if (store->byte_offset.node)
+    {
+        vkd3d_string_buffer_printf(buffer, ", byte_offset = ");
+        dump_src(buffer, &store->byte_offset);
+    }
     vkd3d_string_buffer_printf(buffer, ")");
 }
 
@@ -4417,6 +4431,7 @@ static void free_ir_string_constant(struct hlsl_ir_string_constant *string)
 static void free_ir_resource_store(struct hlsl_ir_resource_store *store)
 {
     hlsl_cleanup_deref(&store->resource);
+    hlsl_src_remove(&store->byte_offset);
     hlsl_src_remove(&store->coords);
     hlsl_src_remove(&store->value);
     vkd3d_free(store);
@@ -5321,6 +5336,8 @@ int hlsl_parse(const struct vkd3d_shader_compile_info *compile_info,
         {
             if (!decl->has_body)
                 continue;
+            if (decl->storage_modifiers & HLSL_STORAGE_STATIC)
+                continue;
             if (entry_func)
             {
                 /* Depending on d3dcompiler version, either the first or last is
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index cc86fecf532..f37b86ecdf0 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -425,7 +425,7 @@ struct hlsl_attribute
 #define HLSL_STORAGE_NOPERSPECTIVE       0x00008000
 #define HLSL_STORAGE_LINEAR              0x00010000
 #define HLSL_MODIFIER_SINGLE             0x00020000
-#define HLSL_MODIFIER_EXPORT             0x00040000
+#define HLSL_STORAGE_EXPORT              0x00040000
 #define HLSL_STORAGE_ANNOTATION          0x00080000
 #define HLSL_MODIFIER_UNORM              0x00100000
 #define HLSL_MODIFIER_SNORM              0x00200000
@@ -637,6 +637,9 @@ struct hlsl_ir_function_decl
     /* Item entry in hlsl_ir_function.overloads. */
     struct list entry;
 
+    /* Storage modifiers (HLSL_STORAGE_*). */
+    uint32_t storage_modifiers;
+
     /* Function to which this declaration corresponds. */
     struct hlsl_ir_function *func;
 
@@ -930,7 +933,7 @@ struct hlsl_ir_resource_store
     struct hlsl_ir_node node;
     enum hlsl_resource_store_type store_type;
     struct hlsl_deref resource;
-    struct hlsl_src coords, value;
+    struct hlsl_src byte_offset, coords, value;
     uint8_t writemask;
 };
 
@@ -1610,8 +1613,9 @@ void hlsl_block_add_loop(struct hlsl_ctx *ctx, struct hlsl_block *block,
 struct hlsl_ir_node *hlsl_block_add_resource_load(struct hlsl_ctx *ctx, struct hlsl_block *block,
         const struct hlsl_resource_load_params *params, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_block_add_resource_store(struct hlsl_ctx *ctx, struct hlsl_block *block,
-        enum hlsl_resource_store_type type, const struct hlsl_deref *resource, struct hlsl_ir_node *coords,
-        struct hlsl_ir_node *value, uint32_t writemask, const struct vkd3d_shader_location *loc);
+        enum hlsl_resource_store_type type, const struct hlsl_deref *resource,
+        struct hlsl_ir_node *byte_offset, struct hlsl_ir_node *coords, struct hlsl_ir_node *value,
+        uint32_t writemask, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_block_add_simple_load(struct hlsl_ctx *ctx, struct hlsl_block *block,
         struct hlsl_ir_var *var, const struct vkd3d_shader_location *loc);
 void hlsl_block_add_simple_store(struct hlsl_ctx *ctx, struct hlsl_block *block,
@@ -1709,7 +1713,7 @@ struct hlsl_ir_node *hlsl_new_cast(struct hlsl_ctx *ctx, struct hlsl_ir_node *no
 struct hlsl_ir_node *hlsl_new_constant(struct hlsl_ctx *ctx, struct hlsl_type *type,
         const struct hlsl_constant_value *value, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_copy(struct hlsl_ctx *ctx, struct hlsl_ir_node *node);
-struct hlsl_ir_function_decl *hlsl_new_func_decl(struct hlsl_ctx *ctx,
+struct hlsl_ir_function_decl *hlsl_new_func_decl(struct hlsl_ctx *ctx, uint32_t storage_modifiers,
         struct hlsl_type *return_type, const struct hlsl_func_parameters *parameters,
         const struct hlsl_semantic *semantic, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_if(struct hlsl_ctx *ctx, struct hlsl_ir_node *condition, struct hlsl_block *then_block,
@@ -1739,7 +1743,7 @@ struct hlsl_ir_node *hlsl_new_store_index(struct hlsl_ctx *ctx, const struct hls
 
 bool hlsl_index_is_noncontiguous(struct hlsl_ir_index *index);
 bool hlsl_index_is_resource_access(struct hlsl_ir_index *index);
-bool hlsl_index_chain_has_resource_access(struct hlsl_ir_index *index);
+struct hlsl_ir_index *hlsl_index_chain_find_resource_access(struct hlsl_ir_index *index);
 bool hlsl_index_chain_has_tgsm_access(struct hlsl_ir_index *index);
 
 struct hlsl_ir_node *hlsl_new_compile(struct hlsl_ctx *ctx, const struct hlsl_profile_info *profile,
@@ -1843,6 +1847,10 @@ bool hlsl_offset_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref *deref
 unsigned int hlsl_offset_from_deref_safe(struct hlsl_ctx *ctx, const struct hlsl_deref *deref);
 struct hlsl_reg hlsl_reg_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref *deref);
 
+struct hlsl_ir_node *hlsl_block_add_packed_index_offset_append(struct hlsl_ctx *ctx,
+        struct hlsl_block *block, struct hlsl_ir_node *prev_offset, struct hlsl_ir_node *idx,
+        struct hlsl_type *type, const struct vkd3d_shader_location *loc);
+
 bool hlsl_copy_propagation_execute(struct hlsl_ctx *ctx, struct hlsl_block *block);
 struct hlsl_ir_node *hlsl_fold_binary_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block);
 struct hlsl_ir_node *hlsl_fold_constant_exprs(struct hlsl_ctx *ctx,
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.l b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
index c41d807cca1..24d08b314a4 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.l
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
@@ -216,15 +216,15 @@ while                   {return KW_WHILE;               }
 {IDENTIFIER}            {
                             struct hlsl_ctx *ctx = yyget_extra(yyscanner);
 
-                            yylval->name = hlsl_strdup(ctx, yytext);
                             if (hlsl_version_ge(ctx, 5, 1) && !strcmp(yytext, "ConstantBuffer"))
                                 return KW_CONSTANTBUFFER;
-                            else if (hlsl_get_var(ctx->cur_scope, yytext) || hlsl_get_function(ctx, yytext))
+
+                            yylval->name = hlsl_strdup(ctx, yytext);
+                            if (hlsl_get_var(ctx->cur_scope, yytext) || hlsl_get_function(ctx, yytext))
                                 return VAR_IDENTIFIER;
-                            else if (hlsl_get_type(ctx->cur_scope, yytext, true, true))
+                            if (hlsl_get_type(ctx->cur_scope, yytext, true, true))
                                 return TYPE_IDENTIFIER;
-                            else
-                                return NEW_IDENTIFIER;
+                            return NEW_IDENTIFIER;
                         }
 
 {STRING}                {
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index a45fa1d8b7e..e382255938d 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -1994,11 +1994,172 @@ static bool invert_swizzle_matrix(const struct hlsl_matrix_swizzle *swizzle,
     return true;
 }
 
+static bool add_resource_store(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_index *lhs, struct hlsl_ir_index *resource_access,
+        struct hlsl_ir_node *rhs, unsigned int width, uint32_t writemask, bool matrix_writemask)
+{
+    struct hlsl_ir_node *coords = resource_access->idx.node;
+    struct hlsl_type *resource_type, *resource_format;
+    struct vkd3d_shader_location loc = lhs->node.loc;
+    unsigned int dim_count, expected_width;
+    struct hlsl_deref resource_deref;
+
+    if (!hlsl_init_deref_from_index_chain(ctx, &resource_deref, resource_access->val.node))
+        return false;
+
+    resource_type = hlsl_deref_get_type(ctx, &resource_deref);
+    resource_format = resource_type->e.resource.format;
+    expected_width = resource_format->e.numeric.dimx * resource_format->e.numeric.dimy;
+    VKD3D_ASSERT(resource_type->class == HLSL_CLASS_TEXTURE || resource_type->class == HLSL_CLASS_UAV);
+
+    if (resource_type->class != HLSL_CLASS_UAV)
+        hlsl_error(ctx, &loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE, "Read-only resources cannot be stored to.");
+
+    dim_count = hlsl_sampler_dim_count(resource_type->sampler_dim);
+
+    VKD3D_ASSERT(coords->data_type->class == HLSL_CLASS_VECTOR);
+    VKD3D_ASSERT(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
+    VKD3D_ASSERT(coords->data_type->e.numeric.dimx == dim_count);
+
+    if (resource_type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
+    {
+        struct hlsl_ir_node *field_offset = hlsl_block_add_uint_constant(ctx, block, 0, &loc);
+        struct hlsl_type *val_type = lhs->node.data_type;
+        struct hlsl_ir_index *ptr = lhs, *prev = NULL;
+
+        if (rhs->data_type->class > HLSL_CLASS_LAST_NUMERIC)
+        {
+            hlsl_fixme(ctx, &loc, "Composite type structured buffer stores.");
+            return false;
+        }
+
+        while (ptr != resource_access)
+        {
+            struct hlsl_ir_index *next = hlsl_ir_index(ptr->val.node);
+            struct hlsl_type *type = ptr->val.node->data_type;
+
+            if (hlsl_index_is_noncontiguous(next))
+            {
+                type = next->val.node->data_type;
+            }
+            else if (hlsl_index_is_noncontiguous(ptr))
+            {
+                if (prev)
+                {
+                    type = prev->val.node->data_type;
+                }
+                else
+                {
+                    val_type = ptr->val.node->data_type;
+                    type = ptr->node.data_type;
+                }
+            }
+
+            field_offset = hlsl_block_add_packed_index_offset_append(ctx,
+                    block, field_offset, ptr->idx.node, type, &loc);
+
+            prev = ptr;
+            ptr = next;
+        }
+
+        if (matrix_writemask || rhs->data_type->class == HLSL_CLASS_MATRIX)
+        {
+            /* Type of the minor inner vector. column type for row major,
+             * row type for column major. */
+            struct hlsl_type *minor_type = hlsl_get_vector_type(ctx,
+                    val_type->e.numeric.type, hlsl_type_minor_size(val_type));
+            struct hlsl_block writes;
+            bool written = false;
+
+            hlsl_block_init(&writes);
+
+            for (unsigned int i = 0, k = 0; i < val_type->e.numeric.dimy; ++i)
+            {
+                bool row_major = hlsl_type_is_row_major(val_type);
+                struct hlsl_ir_node *mtx_offset;
+                struct hlsl_ir_node *row_c;
+
+                row_c = hlsl_block_add_uint_constant(ctx, &writes, i, &loc);
+                mtx_offset = hlsl_block_add_packed_index_offset_append(ctx, &writes,
+                        field_offset, row_c, row_major ? val_type : minor_type, &loc);
+
+                for (unsigned int j = 0; j < val_type->e.numeric.dimx; ++j)
+                {
+                    struct hlsl_ir_node *column_c, *load, *col_offset;
+
+                    if (matrix_writemask)
+                    {
+                        unsigned int idx = i * 4 + j;
+
+                        if (!(writemask & (1u << idx)))
+                            continue;
+                    }
+
+                    written = true;
+                    column_c = hlsl_block_add_uint_constant(ctx, &writes, j, &loc);
+                    col_offset = hlsl_block_add_packed_index_offset_append(ctx, &writes,
+                            mtx_offset, column_c, row_major ? minor_type : val_type, &loc);
+                    load = hlsl_add_load_component(ctx, &writes, rhs, k++, &loc);
+                    hlsl_block_add_resource_store(ctx, &writes, HLSL_RESOURCE_STORE,
+                            &resource_deref, col_offset, coords, load, VKD3DSP_WRITEMASK_0, &loc);
+                }
+            }
+
+            if (written)
+                hlsl_block_add_block(block, &writes);
+            hlsl_block_cleanup(&writes);
+        }
+        else
+        {
+            unsigned int size = val_type->e.numeric.dimx;
+
+            for (unsigned int i = 0, k = 0; i < size; ++i)
+            {
+                struct hlsl_ir_node *c, *load, *offset;
+
+                if (!(writemask & (1u << i)))
+                    continue;
+
+                if (val_type->class == HLSL_CLASS_SCALAR)
+                {
+                    VKD3D_ASSERT(i == 0);
+                    VKD3D_ASSERT(size == 1);
+
+                    offset = field_offset;
+                }
+                else
+                {
+                    c = hlsl_block_add_uint_constant(ctx, block, i, &loc);
+                    offset = hlsl_block_add_packed_index_offset_append(ctx, block, field_offset, c, val_type, &loc);
+                }
+
+                load = hlsl_add_load_component(ctx, block, rhs, k++, &loc);
+                hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STORE,
+                        &resource_deref, offset, coords, load, VKD3DSP_WRITEMASK_0, &loc);
+            }
+        }
+    }
+    else
+    {
+        if (width != expected_width)
+            hlsl_error(ctx, &loc, VKD3D_SHADER_ERROR_HLSL_INVALID_WRITEMASK,
+                    "Resource store expressions must write to all components.");
+
+        hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STORE,
+                &resource_deref, NULL, coords, rhs, writemask, &loc);
+    }
+
+    hlsl_cleanup_deref(&resource_deref);
+
+    return true;
+}
+
 static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_node *lhs,
         enum parse_assign_op assign_op, struct hlsl_ir_node *rhs, bool is_function_out_arg)
 {
     struct hlsl_type *lhs_type = lhs->data_type;
     unsigned int writemask = 0, width = 0;
+    struct hlsl_ir_index *resource_access;
     bool matrix_writemask = false;
     bool first_cast = true;
 
@@ -2107,42 +2268,11 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
      * stored to. This is corrected. */
     rhs = add_cast(ctx, block, rhs, lhs_type, &rhs->loc);
 
-    if (lhs->type == HLSL_IR_INDEX && hlsl_index_chain_has_resource_access(hlsl_ir_index(lhs)))
+    if (lhs->type == HLSL_IR_INDEX && (resource_access = hlsl_index_chain_find_resource_access(hlsl_ir_index(lhs))))
     {
-        struct hlsl_ir_node *coords = hlsl_ir_index(lhs)->idx.node;
-        struct hlsl_deref resource_deref;
-        struct hlsl_type *resource_type;
-        unsigned int dim_count;
-
-        if (!hlsl_index_is_resource_access(hlsl_ir_index(lhs)))
-        {
-            hlsl_fixme(ctx, &lhs->loc, "Non-direct structured resource store.");
-            return false;
-        }
-
-        if (!hlsl_init_deref_from_index_chain(ctx, &resource_deref, hlsl_ir_index(lhs)->val.node))
+        if (!add_resource_store(ctx, block, hlsl_ir_index(lhs),
+                resource_access, rhs, width, writemask, matrix_writemask))
             return false;
-
-        resource_type = hlsl_deref_get_type(ctx, &resource_deref);
-        VKD3D_ASSERT(resource_type->class == HLSL_CLASS_TEXTURE || resource_type->class == HLSL_CLASS_UAV);
-
-        if (resource_type->class != HLSL_CLASS_UAV)
-            hlsl_error(ctx, &lhs->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
-                    "Read-only resources cannot be stored to.");
-
-        dim_count = hlsl_sampler_dim_count(resource_type->sampler_dim);
-
-        if (width != resource_type->e.resource.format->e.numeric.dimx * resource_type->e.resource.format->e.numeric.dimy)
-            hlsl_error(ctx, &lhs->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_WRITEMASK,
-                    "Resource store expressions must write to all components.");
-
-        VKD3D_ASSERT(coords->data_type->class == HLSL_CLASS_VECTOR);
-        VKD3D_ASSERT(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
-        VKD3D_ASSERT(coords->data_type->e.numeric.dimx == dim_count);
-
-        hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STORE,
-                &resource_deref, coords, rhs, writemask, &lhs->loc);
-        hlsl_cleanup_deref(&resource_deref);
     }
     else if (matrix_writemask)
     {
@@ -5236,7 +5366,7 @@ static bool intrinsic_interlocked(struct hlsl_ctx *ctx, enum hlsl_interlocked_op
         return false;
 
     /* TODO: groupshared variables */
-    if (lhs->type == HLSL_IR_INDEX && hlsl_index_chain_has_resource_access(hlsl_ir_index(lhs)))
+    if (lhs->type == HLSL_IR_INDEX && hlsl_index_chain_find_resource_access(hlsl_ir_index(lhs)))
     {
         if (!hlsl_index_is_resource_access(hlsl_ir_index(lhs)))
         {
@@ -6620,7 +6750,8 @@ static bool add_store_method_call(struct hlsl_ctx *ctx, struct hlsl_block *block
     if (!hlsl_init_deref_from_index_chain(ctx, &resource_deref, object))
         return false;
 
-    hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STORE, &resource_deref, offset, rhs, writemask, loc);
+    hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STORE,
+            &resource_deref, NULL, offset, rhs, writemask, loc);
     hlsl_cleanup_deref(&resource_deref);
 
     return true;
@@ -6645,7 +6776,7 @@ static bool add_so_append_method_call(struct hlsl_ctx *ctx, struct hlsl_block *b
     if (!(rhs = add_implicit_conversion(ctx, block, params->args[0], object->data_type->e.so.type, loc)))
         return false;
 
-    hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STREAM_APPEND, &so_deref, NULL, rhs, 0, loc);
+    hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STREAM_APPEND, &so_deref, NULL, NULL, rhs, 0, loc);
     hlsl_cleanup_deref(&so_deref);
 
     return true;
@@ -6666,7 +6797,7 @@ static bool add_so_restartstrip_method_call(struct hlsl_ctx *ctx, struct hlsl_bl
     if (!hlsl_init_deref_from_index_chain(ctx, &so_deref, object))
         return false;
 
-    hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STREAM_RESTART, &so_deref, NULL, NULL, 0, loc);
+    hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STREAM_RESTART, &so_deref, NULL, NULL, NULL, 0, loc);
     hlsl_cleanup_deref(&so_deref);
 
     return true;
@@ -7269,6 +7400,7 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
 %type <name> var_identifier
 %type <name> stateblock_lhs_identifier
 %type <name> name_opt
+%destructor { vkd3d_free($$); } <name>
 
 %type <parameter> parameter
 %type <parameter> parameter_decl
@@ -7561,6 +7693,7 @@ base_optional:
             if ($$->class != HLSL_CLASS_STRUCT)
             {
                 hlsl_error(ctx, &@2, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE, "Base type \"%s\" is not a struct.", $2);
+                vkd3d_free($2);
                 YYABORT;
             }
             vkd3d_free($2);
@@ -7764,7 +7897,7 @@ func_prototype_no_attrs:
             /* Functions are unconditionally inlined. */
             modifiers &= ~HLSL_MODIFIER_INLINE;
 
-            if (modifiers & ~(HLSL_MODIFIERS_MAJORITY_MASK | HLSL_MODIFIER_EXPORT))
+            if (modifiers & ~(HLSL_MODIFIERS_MAJORITY_MASK | HLSL_STORAGE_EXPORT | HLSL_STORAGE_STATIC))
                 hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_MODIFIER,
                         "Unexpected modifier used on a function.");
             if (!(type = apply_type_modifiers(ctx, $2, &modifiers, true, &@1)))
@@ -7800,6 +7933,13 @@ func_prototype_no_attrs:
                     hlsl_note(ctx, &$$.decl->loc, VKD3D_SHADER_LOG_ERROR, "\"%s\" was previously declared here.", $3);
                 }
 
+                if (($$.decl->storage_modifiers & HLSL_STORAGE_STATIC) != (modifiers & HLSL_STORAGE_STATIC))
+                {
+                    hlsl_error(ctx, &@3, VKD3D_SHADER_ERROR_HLSL_REDEFINED,
+                            "\"%s\" was already declared with different storage modifiers.", $3);
+                    hlsl_note(ctx, &$$.decl->loc, VKD3D_SHADER_LOG_ERROR, "\"%s\" was previously declared here.", $3);
+                }
+
                 vkd3d_free($3);
 
                 /* We implement function invocation by copying to input
@@ -7860,7 +8000,7 @@ func_prototype_no_attrs:
             }
             else
             {
-                if (!($$.decl = hlsl_new_func_decl(ctx, type, &$5, &$7.semantic, &@3)))
+                if (!($$.decl = hlsl_new_func_decl(ctx, modifiers, type, &$5, &$7.semantic, &@3)))
                     YYABORT;
 
                 hlsl_add_function(ctx, $3, $$.decl);
@@ -8551,6 +8691,7 @@ type_no_void:
 
             if (hlsl_is_numeric_type(type) && type->e.numeric.type == HLSL_TYPE_INT)
             {
+                vkd3d_free($2);
                 if (!(type = hlsl_type_clone(ctx, type, 0, 0)))
                     YYABORT;
                 vkd3d_free((void *)type->name);
@@ -8561,6 +8702,7 @@ type_no_void:
             {
                 hlsl_error(ctx, &@2, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                         "The 'unsigned' keyword can't be used with type %s.", $2);
+                vkd3d_free($2);
             }
 
             $$ = type;
@@ -8970,6 +9112,7 @@ array:
     | '[' expr ']'
         {
             $$ = evaluate_static_expression_as_uint(ctx, $2, &@2);
+            destroy_block($2);
 
             if (!$$)
             {
@@ -8984,8 +9127,6 @@ array:
                         "Array size %u is not between 1 and 65536.", $$);
                 YYABORT;
             }
-
-            destroy_block($2);
         }
 
 arrays:
@@ -9085,7 +9226,7 @@ var_modifiers:
         }
     | KW_EXPORT var_modifiers
         {
-            $$ = add_modifiers(ctx, $2, HLSL_MODIFIER_EXPORT, &@1);
+            $$ = add_modifiers(ctx, $2, HLSL_STORAGE_EXPORT, &@1);
         }
     | KW_UNORM var_modifiers
         {
@@ -9126,6 +9267,7 @@ var_modifiers:
             else
                 hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_UNKNOWN_MODIFIER,
                         "Unknown modifier %s.", debugstr_a($1));
+            vkd3d_free($1);
         }
 
 complex_initializer:
@@ -9729,9 +9871,11 @@ postfix_expr:
             if (!add_method_call(ctx, $1, object, $3, &$5, &@3))
             {
                 destroy_block($1);
+                vkd3d_free($3);
                 vkd3d_free($5.args);
                 YYABORT;
             }
+            vkd3d_free($3);
             vkd3d_free($5.args);
             $$ = $1;
         }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index 7d5f1ff8402..43320ffa5d3 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -191,8 +191,7 @@ static unsigned int struct_field_get_packed_offset(const struct hlsl_type *recor
     return align(offset, hlsl_type_get_packed_alignment(record->e.record.fields[field_idx].type));
 }
 
-
-static struct hlsl_ir_node *hlsl_block_add_packed_index_offset_append(struct hlsl_ctx *ctx,
+struct hlsl_ir_node *hlsl_block_add_packed_index_offset_append(struct hlsl_ctx *ctx,
         struct hlsl_block *block, struct hlsl_ir_node *prev_offset, struct hlsl_ir_node *idx,
         struct hlsl_type *type, const struct vkd3d_shader_location *loc)
 {
@@ -1798,7 +1797,7 @@ static struct hlsl_ir_node *lower_tgsm_stores(struct hlsl_ctx *ctx,
     coords = hlsl_block_add_uint_constant(ctx, block, 0, &instr->loc);
 
     return hlsl_block_add_resource_store(ctx, block, HLSL_RESOURCE_STORE, &res_deref,
-            coords, store->rhs.node, store->writemask, &instr->loc);
+            NULL, coords, store->rhs.node, store->writemask, &instr->loc);
 }
 
 /* Allocate a unique, ordered index to each instruction, which will be used for
@@ -6299,6 +6298,8 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
                 store->coords.node->last_read = last_read;
             if (store->value.node)
                 store->value.node->last_read = last_read;
+            if (store->byte_offset.node)
+                store->byte_offset.node->last_read = last_read;
             break;
         }
         case HLSL_IR_SWIZZLE:
@@ -11093,14 +11094,11 @@ static void sm1_generate_ctab(struct hlsl_ctx *ctx, struct vkd3d_shader_code *ct
     struct vkd3d_bytecode_buffer buffer = {0};
 
     write_sm1_uniforms(ctx, &buffer);
-    if (buffer.status)
-    {
-        vkd3d_free(buffer.data);
+    if (ctx->result >= 0 && buffer.status < 0)
         ctx->result = buffer.status;
-        return;
-    }
-    ctab->code = buffer.data;
-    ctab->size = buffer.size;
+    if (ctx->result >= 0)
+        vkd3d_shader_code_from_bytecode_buffer(ctab, &buffer);
+    vkd3d_bytecode_buffer_cleanup(&buffer);
 }
 
 static enum vkd3d_shader_input_sysval_semantic vkd3d_siv_from_sysval_indexed(enum vkd3d_shader_sysval_semantic sysval,
@@ -12087,6 +12085,7 @@ static bool sm4_generate_vsir_instr_resource_store(struct hlsl_ctx *ctx,
     struct hlsl_ir_node *instr = &store->node;
     bool tgsm = store->resource.var->is_tgsm;
     struct vkd3d_shader_instruction *ins;
+    bool structured;
 
     if (store->store_type != HLSL_RESOURCE_STORE)
     {
@@ -12119,19 +12118,24 @@ static bool sm4_generate_vsir_instr_resource_store(struct hlsl_ctx *ctx,
         return false;
     }
 
-    if (resource_type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
-    {
-        hlsl_fixme(ctx, &store->node.loc, "Structured buffers store is not implemented.");
-        return false;
-    }
-
     if (tgsm && !hlsl_is_numeric_type(resource_type))
     {
         hlsl_fixme(ctx, &store->node.loc, "Store to structured TGSM.");
         return false;
     }
 
-    if (tgsm || resource_type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
+    if ((structured = resource_type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER))
+    {
+        if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VSIR_OP_STORE_STRUCTURED, 1, 3)))
+            return false;
+
+        if (!sm4_generate_vsir_init_dst_operand_from_deref(ctx, program, &ins->dst[0],
+                &store->resource, &instr->loc, store->writemask))
+            return false;
+
+        vsir_src_from_hlsl_node(&ins->src[1], ctx, store->byte_offset.node, VKD3DSP_WRITEMASK_ALL);
+    }
+    else if (tgsm || resource_type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
     {
         if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VSIR_OP_STORE_RAW, 1, 2)))
             return false;
@@ -12151,7 +12155,7 @@ static bool sm4_generate_vsir_instr_resource_store(struct hlsl_ctx *ctx,
     }
 
     vsir_src_from_hlsl_node(&ins->src[0], ctx, coords, VKD3DSP_WRITEMASK_ALL);
-    vsir_src_from_hlsl_node(&ins->src[1], ctx, value, VKD3DSP_WRITEMASK_ALL);
+    vsir_src_from_hlsl_node(&ins->src[structured ? 2 : 1], ctx, value, VKD3DSP_WRITEMASK_ALL);
 
     return true;
 }
@@ -14320,14 +14324,11 @@ static void sm4_generate_rdef(struct hlsl_ctx *ctx, struct vkd3d_shader_code *rd
 
     sm4_free_extern_resources(extern_resources, extern_resources_count);
 
-    if (buffer.status)
-    {
-        vkd3d_free(buffer.data);
+    if (ctx->result >= 0 && buffer.status < 0)
         ctx->result = buffer.status;
-        return;
-    }
-    rdef->code = buffer.data;
-    rdef->size = buffer.size;
+    if (ctx->result >= 0)
+        vkd3d_shader_code_from_bytecode_buffer(rdef, &buffer);
+    vkd3d_bytecode_buffer_cleanup(&buffer);
 }
 
 static bool loop_unrolling_generate_const_bool_store(struct hlsl_ctx *ctx, struct hlsl_ir_var *var,
@@ -14905,8 +14906,9 @@ static struct hlsl_ir_node *lower_f16tof32(struct hlsl_ctx *ctx, struct hlsl_ir_
 
     if (!(body = hlsl_sprintf_alloc(ctx, template, component_count, component_count)))
         return NULL;
-
-    if (!(func = hlsl_compile_internal_function(ctx, "soft_f16tof32", body)))
+    func = hlsl_compile_internal_function(ctx, "soft_f16tof32", body);
+    vkd3d_free(body);
+    if (!func)
         return NULL;
 
     lhs = func->parameters.vars[0];
@@ -14969,8 +14971,9 @@ static struct hlsl_ir_node *lower_f32tof16(struct hlsl_ctx *ctx, struct hlsl_ir_
 
     if (!(body = hlsl_sprintf_alloc(ctx, template, component_count, component_count)))
         return NULL;
-
-    if (!(func = hlsl_compile_internal_function(ctx, "soft_f32tof16", body)))
+    func = hlsl_compile_internal_function(ctx, "soft_f32tof16", body);
+    vkd3d_free(body);
+    if (!func)
         return NULL;
 
     lhs = func->parameters.vars[0];
@@ -15110,8 +15113,9 @@ static struct hlsl_ir_node *lower_isinf(struct hlsl_ctx *ctx, struct hlsl_ir_nod
     component_count = hlsl_type_component_count(rhs->data_type);
     if (!(body = hlsl_sprintf_alloc(ctx, template, component_count, component_count)))
         return NULL;
-
-    if (!(func = hlsl_compile_internal_function(ctx, "isinf", body)))
+    func = hlsl_compile_internal_function(ctx, "isinf", body);
+    vkd3d_free(body);
+    if (!func)
         return NULL;
 
     hlsl_block_add_simple_store(ctx, block, func->parameters.vars[0], rhs);
@@ -15514,17 +15518,19 @@ int hlsl_emit_vsir(struct hlsl_ctx *ctx, const struct vkd3d_shader_compile_info
     process_entry_function(ctx, &semantic_vars, &body, &initializer_block, entry_func);
 
     if (ctx->result)
+    {
+        hlsl_block_cleanup(&body);
+        hlsl_block_cleanup(&initializer_block);
         return ctx->result;
+    }
 
     if (profile->type == VKD3D_SHADER_TYPE_HULL)
     {
         process_entry_function(ctx, &patch_semantic_vars, &patch_body, &initializer_block, ctx->patch_constant_func);
         if (ctx->result)
-            return ctx->result;
+            goto done;
     }
 
-    hlsl_block_cleanup(&initializer_block);
-
     if (profile->major_version < 4)
     {
         mark_indexable_vars(ctx, &body);
@@ -15550,7 +15556,7 @@ int hlsl_emit_vsir(struct hlsl_ctx *ctx, const struct vkd3d_shader_compile_info
     }
 
     if (ctx->result)
-        return ctx->result;
+        goto done;
 
     generate_vsir_signature(ctx, program, entry_func, &semantic_vars);
     if (program->shader_version.type == VKD3D_SHADER_TYPE_HULL)
@@ -15563,15 +15569,22 @@ int hlsl_emit_vsir(struct hlsl_ctx *ctx, const struct vkd3d_shader_compile_info
     else
         sm4_generate_rdef(ctx, reflection_data);
     if (ctx->result)
-        return ctx->result;
+        goto done;
 
     if (program->shader_version.major < 4)
         sm1_generate_vsir(ctx, compile_info, entry_func, &semantic_vars, &body, config_flags, program);
     else
         sm4_generate_vsir(ctx, compile_info, entry_func, &semantic_vars, &body,
                 &patch_semantic_vars, &patch_body, config_flags, program);
+
     if (ctx->result)
         vkd3d_shader_free_shader_code(reflection_data);
 
+done:
+    if (profile->type == VKD3D_SHADER_TYPE_HULL)
+        hlsl_block_cleanup(&patch_body);
+    hlsl_block_cleanup(&body);
+    hlsl_block_cleanup(&initializer_block);
+
     return ctx->result;
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index c56fee6426e..06ce5801066 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -528,6 +528,24 @@ struct vkd3d_shader_instruction *shader_instruction_array_append(struct vkd3d_sh
     return &array->elements[array->count - 1];
 }
 
+/* NOTE: This might be replaced by a single field in vsir_program at some point. */
+static unsigned int vsir_program_get_idxtemp_count(struct vsir_program *program)
+{
+    struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
+    struct vkd3d_shader_instruction *ins;
+    size_t count = 0;
+
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
+    {
+        if (ins->opcode != VSIR_OP_DCL_INDEXABLE_TEMP)
+            continue;
+        if (count < ins->declaration.indexable_temp.register_idx + 1)
+            count = ins->declaration.indexable_temp.register_idx + 1;
+    }
+
+    return count;
+}
+
 bool vsir_program_add_icb(struct vsir_program *program, struct vkd3d_shader_immediate_constant_buffer *icb)
 {
     if (!vkd3d_array_reserve((void **)&program->icbs, &program->icb_capacity,
@@ -1153,7 +1171,8 @@ static bool vsir_instruction_is_dcl(const struct vkd3d_shader_instruction *instr
 {
     enum vkd3d_shader_opcode opcode = instruction->opcode;
     return (VSIR_OP_DCL <= opcode && opcode <= VSIR_OP_DCL_VERTICES_OUT)
-            || opcode == VSIR_OP_HS_DECLS;
+            || opcode == VSIR_OP_HS_DECLS || opcode == VSIR_OP_DEF
+            || opcode == VSIR_OP_DEFI || opcode == VSIR_OP_DEFB;
 }
 
 /* NOTE: Immediate constant buffers are not cloned, so the source must not be destroyed while the
@@ -2515,6 +2534,162 @@ fail:
     return VKD3D_ERROR_OUT_OF_MEMORY;
 }
 
+static bool vsir_register_replace_loop_register_with_temp(struct vsir_program *program,
+        struct vkd3d_shader_register *reg, unsigned int idxtemp_idx, unsigned int temp_id)
+{
+    if (reg->type == VKD3DSPR_LOOP)
+    {
+        reg->type = VKD3DSPR_TEMP;
+        reg->idx_count = 1;
+        reg->idx[0].offset = temp_id;
+        reg->idx[0].rel_addr = NULL;
+        return true;
+    }
+
+    if (reg->idx[0].rel_addr && reg->idx[0].rel_addr->reg.type == VKD3DSPR_LOOP)
+    {
+        if (!shader_register_clone_relative_addresses(reg, program))
+            return false;
+        if (reg->type == VKD3DSPR_INPUT)
+        {
+            reg->type = VKD3DSPR_IDXTEMP;
+            reg->idx_count = 2;
+            reg->idx[1].offset = reg->idx[0].offset;
+            reg->idx[1].rel_addr = reg->idx[0].rel_addr;
+            vsir_src_operand_init_temp_u32(reg->idx[1].rel_addr, temp_id);
+            reg->idx[0].offset = idxtemp_idx;
+            reg->idx[0].rel_addr = NULL;
+        }
+        else
+        {
+            vsir_src_operand_init_temp_u32(reg->idx[0].rel_addr, temp_id);
+        }
+    }
+
+    return true;
+}
+
+static enum vkd3d_result vsir_program_lower_loop(struct vsir_program *program,
+        struct vsir_program_iterator *loop, unsigned int idxtmp_idx)
+{
+    struct vkd3d_shader_instruction *ins = vsir_program_iterator_current(loop);
+    struct vkd3d_shader_location location = ins->location;
+    const struct vsir_src_operand *src = ins->src;
+    unsigned int iter_id, neg_id, val_id;
+    struct vsir_program_iterator it;
+    unsigned int depth = 1;
+    unsigned int i;
+
+    /* loop aL, SRC1
+     *   <instructions, using aL>
+     * endloop
+     *      ->
+     * mov rITER.x, SRC1.x
+     * ineg srNEG, SRC1.z
+     * iadd rVAL.x, SRC1.y, srNEG
+     * loop
+     *     breakp_z rITER.x
+     *     iadd rITER.x, rITER.x, -1
+     *     iadd rVAL.x, rVAL.x, SRC1.z
+     *     <instructions, replacing
+     *         aL -> rVAL.x
+     *         vN[aL] -> xIDXTEMP[rVAL.x]
+     *     >
+     * endloop
+     */
+
+    VKD3D_ASSERT(ins->src_count == 2);
+
+    if (!(ins = vsir_program_iterator_insert_before(loop, &it, 6)))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    if (!vsir_instruction_init_with_params(program, ins, &location, VSIR_OP_MOV, 1, 1))
+        goto fail;
+    iter_id = program->temp_count++;
+    vsir_dst_operand_init_temp_u32(&ins->dst[0], iter_id);
+    ins->src[0] = src[1];
+    ins->src[0].swizzle = vsir_combine_swizzles(src[1].swizzle, VKD3D_SHADER_SWIZZLE(X, X, X, X));
+
+    ins = vsir_program_iterator_next(&it);
+    if (!vsir_instruction_init_with_params(program, ins, &location, VSIR_OP_INEG, 1, 1))
+        goto fail;
+    neg_id = program->ssa_count++;
+    vsir_dst_operand_init_ssa_scalar(&ins->dst[0], neg_id, src[1].reg.data_type);
+    ins->src[0] = src[1];
+    ins->src[0].swizzle = vsir_combine_swizzles(src[1].swizzle, VKD3D_SHADER_SWIZZLE(Z, Z, Z, Z));
+
+    ins = vsir_program_iterator_next(&it);
+    if (!vsir_instruction_init_with_params(program, ins, &location, VSIR_OP_IADD, 1, 2))
+        goto fail;
+    val_id = program->temp_count++;
+    vsir_dst_operand_init_temp_u32(&ins->dst[0], val_id);
+    ins->src[0] = src[1];
+    ins->src[0].swizzle = vsir_combine_swizzles(src[1].swizzle, VKD3D_SHADER_SWIZZLE(Y, Y, Y, Y));
+    vsir_src_operand_init_ssa_scalar(&ins->src[1], neg_id, src[1].reg.data_type);
+
+    ins = vsir_program_iterator_next(&it);
+    vsir_instruction_init(ins, &location, VSIR_OP_LOOP);
+
+    ins = vsir_program_iterator_next(&it);
+    if (!vsir_instruction_init_with_params(program, ins, &location, VSIR_OP_BREAKP, 0, 1))
+        goto fail;
+    ins->flags = VKD3D_SHADER_CONDITIONAL_OP_Z;
+    vsir_src_operand_init_temp_u32(&ins->src[0], iter_id);
+
+    ins = vsir_program_iterator_next(&it);
+    if (!vsir_instruction_init_with_params(program, ins, &location, VSIR_OP_IADD, 1, 2))
+        goto fail;
+    vsir_dst_operand_init_temp_u32(&ins->dst[0], iter_id);
+    vsir_src_operand_init_temp_u32(&ins->src[0], iter_id);
+    vsir_src_operand_init_const_u32(&ins->src[1], ~0u);
+
+    ins = vsir_program_iterator_next(&it);
+    if (!vsir_instruction_init_with_params(program, ins, &location, VSIR_OP_IADD, 1, 2))
+        goto fail;
+    vsir_dst_operand_init_temp_u32(&ins->dst[0], val_id);
+    vsir_src_operand_init_temp_u32(&ins->src[0], val_id);
+    ins->src[1] = src[1];
+    ins->src[1].swizzle = vsir_combine_swizzles(src[1].swizzle, VKD3D_SHADER_SWIZZLE(Z, Z, Z, Z));
+
+    for (ins = vsir_program_iterator_next(&it); ins; ins = vsir_program_iterator_next(&it))
+    {
+        if (ins->opcode == VSIR_OP_LOOP)
+        {
+            ++depth;
+            continue;
+        }
+
+        if (ins->opcode == VSIR_OP_ENDLOOP)
+        {
+            --depth;
+            if (!depth)
+                break;
+            continue;
+        }
+
+        if (depth != 1)
+            continue;
+
+        for (i = 0; i < ins->dst_count; ++i)
+        {
+            if (!vsir_register_replace_loop_register_with_temp(program, &ins->dst[i].reg, idxtmp_idx, val_id))
+                return VKD3D_ERROR_OUT_OF_MEMORY;
+        }
+
+        for (i = 0; i < ins->src_count; ++i)
+        {
+            if (!vsir_register_replace_loop_register_with_temp(program, &ins->src[i].reg, idxtmp_idx, val_id))
+                return VKD3D_ERROR_OUT_OF_MEMORY;
+        }
+    }
+
+    return VKD3D_OK;
+
+fail:
+    vsir_program_iterator_nop_range(&it, loop, &location);
+
+    return VKD3D_ERROR_OUT_OF_MEMORY;
+}
+
 static enum vkd3d_result vsir_program_lower_texbem(struct vsir_program *program,
         struct vsir_program_iterator *it, struct vkd3d_shader_message_context *message_context)
 {
@@ -2821,11 +2996,6 @@ static enum vkd3d_result vsir_program_lower_d3dbc_instructions(struct vsir_progr
                         vsir_opcode_get_name(ins->opcode, "<unknown>"), ins->opcode);
                 return VKD3D_ERROR_NOT_IMPLEMENTED;
 
-            case VSIR_OP_LOOP:
-                vkd3d_shader_error(ctx->message_context, &ins->location, VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED,
-                        "Aborting due to unimplemented feature: Lower SM1 loops.");
-                return VKD3D_ERROR_NOT_IMPLEMENTED;
-
             default:
                 ret = VKD3D_OK;
                 break;
@@ -2838,6 +3008,167 @@ static enum vkd3d_result vsir_program_lower_d3dbc_instructions(struct vsir_progr
     return VKD3D_OK;
 }
 
+static struct vkd3d_shader_instruction *vsir_program_iterator_dcl_indexable_temp_before(
+        struct vsir_transformation_context *ctx, struct vsir_program_iterator *it, size_t idx, size_t register_size)
+{
+    struct vkd3d_shader_location loc = ctx->null_location;
+    struct vkd3d_shader_indexable_temp *t;
+    struct vkd3d_shader_instruction *ins;
+
+    if ((ins = vsir_program_iterator_current(it)))
+        loc = ins->location;
+
+    if (!(ins = vsir_program_iterator_insert_before_and_move(it, 1)))
+        return NULL;
+
+    vsir_instruction_init(ins, &loc, VSIR_OP_DCL_INDEXABLE_TEMP);
+    t = &ins->declaration.indexable_temp;
+    t->register_idx = idx;
+    t->register_size = register_size;
+    t->alignment = 0;
+    t->data_type = VSIR_DATA_F32;
+    t->component_count = 4;
+    t->has_function_scope = false;
+
+    vsir_program_iterator_next(it);
+
+    return ins;
+}
+
+static enum vkd3d_result vsir_program_copy_d3dbc_input_to_indexable_temp(struct vsir_program *program,
+        struct vsir_transformation_context *ctx, unsigned int *idxtemp_idx)
+{
+    struct vsir_program_iterator dcl_it = vsir_program_iterator(&program->instructions);
+    struct vsir_program_iterator mov_it = vsir_program_iterator(&program->instructions);
+    struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
+    struct vkd3d_shader_location loc = ctx->null_location;
+    struct vkd3d_shader_instruction *ins, *dcl_ins;
+    struct vkd3d_shader_semantic *semantic;
+    size_t register_size = 0;
+    size_t dcl_count = 0;
+
+    *idxtemp_idx = vsir_program_get_idxtemp_count(program);
+
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
+    {
+        if (ins->opcode == VSIR_OP_DCL)
+        {
+            semantic = &ins->declaration.semantic;
+            if (semantic->resource.reg.reg.type != VKD3DSPR_INPUT)
+                continue;
+            register_size = max(register_size, semantic->resource.reg.reg.idx[0].offset + 1);
+            ++dcl_count;
+        }
+
+        if (!vsir_instruction_is_dcl(ins) && ins->opcode != VSIR_OP_NOP)
+        {
+            loc = ins->location;
+            break;
+        }
+    }
+
+    if (!register_size)
+        return VKD3D_OK;
+    if (!vsir_program_iterator_dcl_indexable_temp_before(ctx, &it, *idxtemp_idx, register_size))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    if (!(ins = vsir_program_iterator_insert_before(&it, &mov_it, dcl_count)))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+
+    for (dcl_ins = vsir_program_iterator_head(&dcl_it); dcl_ins; dcl_ins = vsir_program_iterator_next(&dcl_it))
+    {
+        struct vsir_dst_operand *dst;
+        struct vsir_src_operand *src;
+
+        if (dcl_ins->opcode == VSIR_OP_DCL)
+        {
+            semantic = &dcl_ins->declaration.semantic;
+            if (semantic->resource.reg.reg.type != VKD3DSPR_INPUT)
+                continue;
+
+            if (!vsir_instruction_init_with_params(program, ins, &dcl_ins->location, VSIR_OP_MOV, 1, 1))
+                goto fail;
+
+            dst = &ins->dst[0];
+            vsir_dst_operand_init(dst, VKD3DSPR_IDXTEMP, VSIR_DATA_F32, 2);
+            dst->reg.idx[0].offset = *idxtemp_idx;
+            dst->reg.idx[1].offset = semantic->resource.reg.reg.idx[0].offset;
+            dst->reg.dimension = VSIR_DIMENSION_VEC4;
+            dst->write_mask = semantic->resource.reg.write_mask;
+
+            src = &ins->src[0];
+            vsir_src_operand_init(src, VKD3DSPR_INPUT, VSIR_DATA_F32, 1);
+            src->reg.idx[0].offset = semantic->resource.reg.reg.idx[0].offset;
+            src->reg.dimension = VSIR_DIMENSION_VEC4;
+            src->modifiers = 0;
+            src->swizzle = vsir_swizzle_from_writemask(semantic->resource.reg.write_mask);
+
+            ins = vsir_program_iterator_next(&mov_it);
+
+            if (--dcl_count == 0)
+                return VKD3D_OK;
+        }
+    }
+    vkd3d_unreachable();
+
+fail:
+    vsir_program_iterator_prev(&it);
+    vsir_program_iterator_nop_range(&mov_it, &it, &loc);
+    return VKD3D_ERROR_OUT_OF_MEMORY;
+}
+
+static bool is_input_register_with_loop_relative_addressing(struct vkd3d_shader_register *reg)
+{
+    if (reg->type != VKD3DSPR_INPUT)
+        return false;
+    if (!reg->idx_count || !reg->idx[0].rel_addr)
+        return false;
+    return reg->idx[0].rel_addr->reg.type == VKD3DSPR_LOOP;
+}
+
+static enum vkd3d_result vsir_program_lower_d3dbc_loops(
+        struct vsir_program *program, struct vsir_transformation_context *ctx)
+{
+    struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
+    bool has_loop = false, has_input_with_loop_rel_addr = false;
+    struct vkd3d_shader_instruction *ins;
+    unsigned int idxtemp_idx, i;
+    enum vkd3d_result ret;
+
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
+    {
+        if (ins->opcode == VSIR_OP_LOOP)
+            has_loop = true;
+
+        if (!vsir_instruction_is_dcl(ins))
+        {
+            for (i = 0; i < ins->dst_count; ++i)
+            {
+                has_input_with_loop_rel_addr |= is_input_register_with_loop_relative_addressing(&ins->dst[i].reg);
+            }
+            for (i = 0; i < ins->src_count; ++i)
+            {
+                has_input_with_loop_rel_addr |= is_input_register_with_loop_relative_addressing(&ins->src[i].reg);
+            }
+            if (has_input_with_loop_rel_addr)
+                break;
+        }
+    }
+    if (!has_loop)
+        return VKD3D_OK;
+    if (has_input_with_loop_rel_addr)
+        vsir_program_copy_d3dbc_input_to_indexable_temp(program, ctx, &idxtemp_idx);
+
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
+    {
+        if (ins->opcode == VSIR_OP_LOOP)
+        {
+            if ((ret = vsir_program_lower_loop(program, &it, idxtemp_idx)) < 0)
+                return ret;
+        }
+    }
+    return VKD3D_OK;
+}
+
 static enum vkd3d_result vsir_program_lower_modifiers(struct vsir_program *program,
         struct vsir_transformation_context *ctx)
 {
@@ -4213,7 +4544,7 @@ static enum vkd3d_result shader_signature_merge(struct io_normaliser *normaliser
                     e->interpolation_mode = f->interpolation_mode;
             }
 
-            vkd3d_free((void *)f->semantic_name);
+            vsir_signature_element_cleanup(f);
         }
     }
     element_count = new_count;
@@ -4242,7 +4573,7 @@ static enum vkd3d_result shader_signature_merge(struct io_normaliser *normaliser
         {
             TRACE("Register %u mask %#x semantic %s%u has already been merged, dropping it.\n",
                     e->register_index, e->mask, e->semantic_name, e->semantic_index);
-            vkd3d_free((void *)e->semantic_name);
+            vsir_signature_element_cleanup(e);
             continue;
         }
 
@@ -6413,7 +6744,8 @@ static enum vkd3d_result vsir_cfg_init(struct vsir_cfg *cfg, struct vsir_program
                 vsir_program_iterator_next(&current_block->begin);
                 if (!cfg->entry)
                     cfg->entry = current_block;
-                ++defined_block_count;
+                if (label > defined_block_count)
+                    defined_block_count = label;
                 break;
             }
 
@@ -8913,30 +9245,11 @@ static enum vkd3d_result sysval_array_normaliser_add_input_copy(
     return VKD3D_OK;
 }
 
-/* NOTE: This might be replaced by a single field in vsir_program at some point. */
-static unsigned int vsir_program_get_idxtemp_count(struct vsir_program *program)
-{
-    struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
-    struct vkd3d_shader_instruction *ins;
-    size_t count = 0;
-
-    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
-    {
-        if (ins->opcode != VSIR_OP_DCL_INDEXABLE_TEMP)
-            continue;
-        if (count < ins->declaration.indexable_temp.register_idx)
-            count = ins->declaration.indexable_temp.register_idx;
-    }
-
-    return count;
-}
-
 static enum vkd3d_result sysval_array_normaliser_dcl_indexable_temp(
         struct sysval_array_normaliser *normaliser, struct vsir_program_iterator *it, size_t idx)
 {
     struct vsir_program *program = normaliser->ctx->program;
     unsigned int register_size = normaliser->reg_count;
-    struct vkd3d_shader_indexable_temp *t;
     struct vkd3d_shader_instruction *ins;
     unsigned int control_point_count;
 
@@ -8947,20 +9260,10 @@ static enum vkd3d_result sysval_array_normaliser_dcl_indexable_temp(
     if (control_point_count && (!normaliser->output || vsir_opcode_is_fork_or_join_phase(normaliser->phase)))
         register_size *= program->input_control_point_count;
 
-    if (!(ins = vsir_program_iterator_insert_before_and_move(it, 1)))
+    if (!(ins = vsir_program_iterator_dcl_indexable_temp_before(
+            normaliser->ctx, it, normaliser->idxtemp_idx, register_size)))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    vsir_instruction_init_with_params(program, ins, &normaliser->ctx->null_location, VSIR_OP_DCL_INDEXABLE_TEMP, 0, 0);
-    t = &ins->declaration.indexable_temp;
-    t->register_idx = normaliser->idxtemp_idx;
-    t->register_size = register_size;
-    t->alignment = 0;
-    t->data_type = VSIR_DATA_F32;
-    t->component_count = 4;
-    t->has_function_scope = false;
-
-    vsir_program_iterator_next(it);
-
     return VKD3D_OK;
 }
 
@@ -9232,6 +9535,7 @@ static void vsir_program_remove_signature_element(struct vsir_program *program,
             shader_register_remove_signature_element(&ins->src[i].reg, type, index);
     }
 
+    vsir_signature_element_cleanup(&signature->elements[index]);
     memmove(&signature->elements[index], &signature->elements[index + 1],
             sizeof(*signature->elements) * (signature->element_count - 1 - index));
     --signature->element_count;
@@ -9276,9 +9580,6 @@ static enum vkd3d_result vsir_program_normalise_sysval_array(struct vsir_transfo
     if (!output && program->shader_version.type == VKD3D_SHADER_TYPE_VERTEX)
         return VKD3D_OK;
 
-    if (TRACE_ON())
-        vsir_program_trace(program);
-
     it = vsir_program_iterator(&program->instructions);
     for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
     {
@@ -9292,7 +9593,7 @@ static enum vkd3d_result vsir_program_normalise_sysval_array(struct vsir_transfo
 
         if (declarations && !vsir_instruction_is_dcl(ins) && ins->opcode != VSIR_OP_NOP)
         {
-            unsigned int idxtemp_idx = vsir_program_get_idxtemp_count(program) + 1;
+            unsigned int idxtemp_idx = vsir_program_get_idxtemp_count(program);
 
             declarations = false;
 
@@ -9305,6 +9606,8 @@ static enum vkd3d_result vsir_program_normalise_sysval_array(struct vsir_transfo
             if ((!output || vsir_opcode_is_fork_or_join_phase(normaliser.phase))
                     && (res = sysval_array_normaliser_add_input_copy(&normaliser, &it)) < 0)
                 return res;
+
+            ins = vsir_program_iterator_current(&it);
         }
 
         if (!declarations)
@@ -9323,8 +9626,6 @@ static enum vkd3d_result vsir_program_normalise_sysval_array(struct vsir_transfo
         }
     }
     VKD3D_ASSERT(!declarations);
-    if (TRACE_ON())
-        vsir_program_trace(program);
     sysval_array_normaliser_remove_old_signature_elements(&normaliser);
 
     return VKD3D_OK;
@@ -9719,6 +10020,7 @@ static enum vkd3d_result vsir_program_add_fog_input(struct vsir_program *program
         struct vsir_transformation_context *ctx)
 {
     struct shader_signature *signature = &program->input_signature;
+    struct signature_element *e;
     uint32_t register_idx = 0;
 
     if (program->shader_version.type != VKD3D_SHADER_TYPE_PIXEL)
@@ -9736,7 +10038,10 @@ static enum vkd3d_result vsir_program_add_fog_input(struct vsir_program *program
         return VKD3D_OK;
 
     for (unsigned int i = 0; i < signature->element_count; ++i)
-        register_idx = max(register_idx, signature->elements[i].register_index + 1);
+    {
+        e = &signature->elements[i];
+        register_idx = max(register_idx, e->register_index + e->register_count);
+    }
 
     if (!add_signature_element(signature, "FOG", 0, VKD3DSP_WRITEMASK_0, register_idx, VKD3DSIM_LINEAR))
         return VKD3D_ERROR_OUT_OF_MEMORY;
@@ -14641,6 +14946,8 @@ static void vsir_transform_(
     if ((ctx->result = step(ctx->program, ctx)) < 0)
     {
         WARN("Transformation \"%s\" failed with result %d.\n", step_name, ctx->result);
+        if (TRACE_ON())
+            vsir_program_trace(ctx->program);
         return;
     }
 
@@ -14648,6 +14955,8 @@ static void vsir_transform_(
             ctx->compile_info->source_name, ctx->message_context)) < 0)
     {
         WARN("Validation failed with result %d after transformation \"%s\".\n", ctx->result, step_name);
+        if (TRACE_ON())
+            vsir_program_trace(ctx->program);
         return;
     }
 }
@@ -15306,7 +15615,7 @@ enum vkd3d_result vsir_program_optimize(struct vsir_program *program, uint64_t c
     vsir_transformation_context_init(&ctx, program, config_flags, compile_info, message_context);
     vsir_optimize(&ctx);
 
-    if (TRACE_ON())
+    if (TRACE_ON() && ctx.result >= 0)
         vsir_program_trace(program);
 
     return ctx.result;
@@ -15344,6 +15653,7 @@ enum vkd3d_result vsir_program_lower_d3dbc(struct vsir_program *program, uint64_
     struct vsir_transformation_context ctx;
 
     vsir_transformation_context_init(&ctx, program, config_flags, compile_info, message_context);
+    vsir_transform(&ctx, vsir_program_lower_d3dbc_loops);
     vsir_transform(&ctx, vsir_program_lower_d3dbc_instructions);
 
     if (program->shader_version.major == 1 && program->shader_version.type == VKD3D_SHADER_TYPE_PIXEL)
@@ -15354,7 +15664,7 @@ enum vkd3d_result vsir_program_lower_d3dbc(struct vsir_program *program, uint64_
         vsir_transform(&ctx, vsir_program_normalise_ps1_output);
     }
 
-    if (TRACE_ON())
+    if (TRACE_ON() && ctx.result >= 0)
         vsir_program_trace(program);
 
     return ctx.result;
@@ -15422,7 +15732,7 @@ enum vkd3d_result vsir_program_transform(struct vsir_program *program, uint64_t
     vsir_transform(&ctx, vsir_program_insert_fragment_fog);
     vsir_transform(&ctx, vsir_program_insert_vertex_fog);
 
-    if (TRACE_ON())
+    if (TRACE_ON() && ctx.result >= 0)
         vsir_program_trace(program);
 
     return ctx.result;
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index cd253700e4d..5a75c0bc5fd 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -4363,6 +4363,7 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
         case VSIR_OP_SINCOS:
         case VSIR_OP_SQRT:
         case VSIR_OP_STORE_RAW:
+        case VSIR_OP_STORE_STRUCTURED:
         case VSIR_OP_STORE_UAV_TYPED:
         case VSIR_OP_SWITCH:
         case VSIR_OP_UDIV:
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index d19ff27a882..ddbf91ac482 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -474,6 +474,11 @@ void vkd3d_shader_error(struct vkd3d_shader_message_context *context, const stru
     va_end(args);
 }
 
+void vkd3d_bytecode_buffer_cleanup(struct vkd3d_bytecode_buffer *buffer)
+{
+    vkd3d_free(buffer->data);
+}
+
 size_t bytecode_align(struct vkd3d_bytecode_buffer *buffer)
 {
     size_t aligned_size = align(buffer->size, 4);
@@ -552,6 +557,16 @@ void set_string(struct vkd3d_bytecode_buffer *buffer, size_t offset, const char
     bytecode_set_bytes(buffer, offset, string, length);
 }
 
+void vkd3d_shader_code_from_bytecode_buffer(struct vkd3d_shader_code *code, struct vkd3d_bytecode_buffer *buffer)
+{
+    code->size = buffer->size;
+    code->code = buffer->data;
+
+    buffer->data = NULL;
+    buffer->size = 0;
+    buffer->capacity = 0;
+}
+
 struct shader_dump_data
 {
     uint8_t checksum[16];
@@ -2045,7 +2060,7 @@ void shader_signature_cleanup(struct shader_signature *signature)
 {
     for (unsigned int i = 0; i < signature->element_count; ++i)
     {
-        vkd3d_free((void *)signature->elements[i].semantic_name);
+        vsir_signature_element_cleanup(&signature->elements[i]);
     }
     vkd3d_free(signature->elements);
     signature->elements = NULL;
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index 2f52ed5527b..8e4254352b0 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -1229,6 +1229,11 @@ struct signature_element
     unsigned int target_location;
 };
 
+static inline void vsir_signature_element_cleanup(struct signature_element *e)
+{
+    vkd3d_free((void *)e->semantic_name);
+}
+
 static inline bool vsir_signature_element_is_array(const struct signature_element *element,
         const struct vsir_normalisation_flags *flags)
 {
@@ -1859,6 +1864,8 @@ size_t bytecode_put_bytes_unaligned(struct vkd3d_bytecode_buffer *buffer, const
 size_t bytecode_reserve_bytes(struct vkd3d_bytecode_buffer *buffer, size_t size);
 void set_u32(struct vkd3d_bytecode_buffer *buffer, size_t offset, uint32_t value);
 void set_string(struct vkd3d_bytecode_buffer *buffer, size_t offset, const char *string, size_t length);
+void vkd3d_bytecode_buffer_cleanup(struct vkd3d_bytecode_buffer *buffer);
+void vkd3d_shader_code_from_bytecode_buffer(struct vkd3d_shader_code *code, struct vkd3d_bytecode_buffer *buffer);
 
 static inline size_t put_u32(struct vkd3d_bytecode_buffer *buffer, uint32_t value)
 {
-- 
2.51.0

