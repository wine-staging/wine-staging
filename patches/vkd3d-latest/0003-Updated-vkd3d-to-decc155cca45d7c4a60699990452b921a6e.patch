From 97f16d7d3743f07c6dd64999bf3ea0f227c0c2ce Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 22 Jul 2025 07:27:52 +1000
Subject: [PATCH] Updated vkd3d to decc155cca45d7c4a60699990452b921a6e0fa65.

---
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c        |  24 +-
 libs/vkd3d/libs/vkd3d-shader/d3dbc.c          |  25 +-
 libs/vkd3d/libs/vkd3d-shader/dxil.c           | 128 ++--
 libs/vkd3d/libs/vkd3d-shader/glsl.c           |  44 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c   | 219 +++---
 libs/vkd3d/libs/vkd3d-shader/ir.c             | 639 ++++++++++--------
 libs/vkd3d/libs/vkd3d-shader/msl.c            |  40 +-
 libs/vkd3d/libs/vkd3d-shader/spirv.c          |  60 +-
 libs/vkd3d/libs/vkd3d-shader/tpf.c            |  75 +-
 .../libs/vkd3d-shader/vkd3d_shader_main.c     |  16 +-
 .../libs/vkd3d-shader/vkd3d_shader_private.h  | 109 ++-
 11 files changed, 806 insertions(+), 573 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index ae9278f68b1..7d10cf98f71 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -384,25 +384,25 @@ static void shader_print_resource_type(struct vkd3d_d3d_asm_compiler *compiler,
                 compiler->colours.error, type, compiler->colours.reset);
 }
 
-static void shader_print_data_type(struct vkd3d_d3d_asm_compiler *compiler, enum vkd3d_data_type type)
+static void shader_print_data_type(struct vkd3d_d3d_asm_compiler *compiler, enum vsir_data_type type)
 {
     static const char *const data_type_names[] =
     {
-        [VKD3D_DATA_FLOAT    ] = "float",
         [VKD3D_DATA_INT      ] = "int",
         [VKD3D_DATA_UINT     ] = "uint",
         [VKD3D_DATA_UNORM    ] = "unorm",
         [VKD3D_DATA_SNORM    ] = "snorm",
         [VKD3D_DATA_OPAQUE   ] = "opaque",
         [VKD3D_DATA_MIXED    ] = "mixed",
-        [VKD3D_DATA_DOUBLE   ] = "double",
         [VKD3D_DATA_CONTINUED] = "<continued>",
         [VKD3D_DATA_UNUSED   ] = "<unused>",
         [VKD3D_DATA_UINT8    ] = "uint8",
         [VKD3D_DATA_UINT64   ] = "uint64",
         [VKD3D_DATA_BOOL     ] = "bool",
         [VKD3D_DATA_UINT16   ] = "uint16",
-        [VKD3D_DATA_HALF     ] = "half",
+        [VSIR_DATA_F16      ] = "half",
+        [VSIR_DATA_F32      ] = "float",
+        [VSIR_DATA_F64      ] = "double",
     };
 
     if (type < ARRAY_SIZE(data_type_names))
@@ -412,7 +412,7 @@ static void shader_print_data_type(struct vkd3d_d3d_asm_compiler *compiler, enum
                 compiler->colours.error, type, compiler->colours.reset);
 }
 
-static void shader_dump_resource_data_type(struct vkd3d_d3d_asm_compiler *compiler, const enum vkd3d_data_type *type)
+static void shader_dump_resource_data_type(struct vkd3d_d3d_asm_compiler *compiler, const enum vsir_data_type *type)
 {
     int i;
 
@@ -730,7 +730,7 @@ static void shader_print_register(struct vkd3d_d3d_asm_compiler *compiler, const
             case VSIR_DIMENSION_SCALAR:
                 switch (reg->data_type)
                 {
-                    case VKD3D_DATA_FLOAT:
+                    case VSIR_DATA_F32:
                         if (untyped)
                             shader_print_untyped_literal(compiler, "", reg->u.immconst_u32[0], "");
                         else
@@ -752,7 +752,7 @@ static void shader_print_register(struct vkd3d_d3d_asm_compiler *compiler, const
             case VSIR_DIMENSION_VEC4:
                 switch (reg->data_type)
                 {
-                    case VKD3D_DATA_FLOAT:
+                    case VSIR_DATA_F32:
                         if (untyped)
                         {
                             shader_print_untyped_literal(compiler, "", reg->u.immconst_u32[0], "");
@@ -800,7 +800,7 @@ static void shader_print_register(struct vkd3d_d3d_asm_compiler *compiler, const
         /* A double2 vector is treated as a float4 vector in enum vsir_dimension. */
         if (reg->dimension == VSIR_DIMENSION_SCALAR || reg->dimension == VSIR_DIMENSION_VEC4)
         {
-            if (reg->data_type == VKD3D_DATA_DOUBLE)
+            if (reg->data_type == VSIR_DATA_F64)
             {
                 shader_print_double_literal(compiler, "", reg->u.immconst_f64[0], "");
                 if (reg->dimension == VSIR_DIMENSION_VEC4)
@@ -1684,10 +1684,10 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
                 shader_print_int_literal(compiler, ",", ins->texel_offset.w, ")");
             }
 
-            if (ins->resource_data_type[0] != VKD3D_DATA_FLOAT
-                    || ins->resource_data_type[1] != VKD3D_DATA_FLOAT
-                    || ins->resource_data_type[2] != VKD3D_DATA_FLOAT
-                    || ins->resource_data_type[3] != VKD3D_DATA_FLOAT)
+            if (ins->resource_data_type[0] != VSIR_DATA_F32
+                    || ins->resource_data_type[1] != VSIR_DATA_F32
+                    || ins->resource_data_type[2] != VSIR_DATA_F32
+                    || ins->resource_data_type[3] != VSIR_DATA_F32)
                 shader_dump_resource_data_type(compiler, ins->resource_data_type);
 
             for (i = 0; i < ins->dst_count; ++i)
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index eeb4deff61f..2dd9c731010 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -563,7 +563,7 @@ static void d3dbc_parse_register(struct vkd3d_shader_sm1_parser *d3dbc,
 
     reg_type = parse_register_type(d3dbc, param, &index_offset);
     idx_count = idx_count_from_reg_type(reg_type);
-    vsir_register_init(reg, reg_type, VKD3D_DATA_FLOAT, idx_count);
+    vsir_register_init(reg, reg_type, VSIR_DATA_F32, idx_count);
     reg->precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
     reg->non_uniform = false;
     if (idx_count == 1)
@@ -1088,10 +1088,10 @@ static void shader_sm1_read_semantic(struct vkd3d_shader_sm1_parser *sm1,
     {
         semantic->resource_type = resource_type_table[resource_type];
     }
-    semantic->resource_data_type[0] = VKD3D_DATA_FLOAT;
-    semantic->resource_data_type[1] = VKD3D_DATA_FLOAT;
-    semantic->resource_data_type[2] = VKD3D_DATA_FLOAT;
-    semantic->resource_data_type[3] = VKD3D_DATA_FLOAT;
+    semantic->resource_data_type[0] = VSIR_DATA_F32;
+    semantic->resource_data_type[1] = VSIR_DATA_F32;
+    semantic->resource_data_type[2] = VSIR_DATA_F32;
+    semantic->resource_data_type[3] = VSIR_DATA_F32;
     shader_sm1_parse_dst_param(sm1, dst_token, NULL, &semantic->resource.reg);
     range = &semantic->resource.range;
     range->space = 0;
@@ -1101,7 +1101,7 @@ static void shader_sm1_read_semantic(struct vkd3d_shader_sm1_parser *sm1,
 }
 
 static void shader_sm1_read_immconst(struct vkd3d_shader_sm1_parser *sm1, const uint32_t **ptr,
-        struct vkd3d_shader_src_param *src_param, enum vsir_dimension dimension, enum vkd3d_data_type data_type)
+        struct vkd3d_shader_src_param *src_param, enum vsir_dimension dimension, enum vsir_data_type data_type)
 {
     unsigned int count = dimension == VSIR_DIMENSION_VEC4 ? 4 : 1;
 
@@ -1272,10 +1272,10 @@ static void shader_sm1_read_instruction(struct vkd3d_shader_sm1_parser *sm1, str
 
     ins->resource_type = VKD3D_SHADER_RESOURCE_NONE;
     ins->resource_stride = 0;
-    ins->resource_data_type[0] = VKD3D_DATA_FLOAT;
-    ins->resource_data_type[1] = VKD3D_DATA_FLOAT;
-    ins->resource_data_type[2] = VKD3D_DATA_FLOAT;
-    ins->resource_data_type[3] = VKD3D_DATA_FLOAT;
+    ins->resource_data_type[0] = VSIR_DATA_F32;
+    ins->resource_data_type[1] = VSIR_DATA_F32;
+    ins->resource_data_type[2] = VSIR_DATA_F32;
+    ins->resource_data_type[3] = VSIR_DATA_F32;
     memset(&ins->texel_offset, 0, sizeof(ins->texel_offset));
 
     p = *ptr;
@@ -1295,7 +1295,7 @@ static void shader_sm1_read_instruction(struct vkd3d_shader_sm1_parser *sm1, str
     else if (ins->opcode == VSIR_OP_DEF)
     {
         shader_sm1_read_dst_param(sm1, &p, dst_param);
-        shader_sm1_read_immconst(sm1, &p, &src_params[0], VSIR_DIMENSION_VEC4, VKD3D_DATA_FLOAT);
+        shader_sm1_read_immconst(sm1, &p, &src_params[0], VSIR_DIMENSION_VEC4, VSIR_DATA_F32);
         shader_sm1_scan_register(sm1, &dst_param->reg, dst_param->write_mask, true);
     }
     else if (ins->opcode == VSIR_OP_DEFB)
@@ -2147,6 +2147,9 @@ int d3dbc_compile(struct vsir_program *program, uint64_t config_flags,
     if ((result = vsir_allocate_temp_registers(program, message_context)))
         return result;
 
+    if ((result = vsir_update_dcl_temps(program, message_context)))
+        return result;
+
     d3dbc.program = program;
     d3dbc.message_context = message_context;
     switch (version->type)
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index db74a7bfbcc..f8f0d2543bd 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -882,9 +882,9 @@ struct sm6_descriptor_info
     struct vkd3d_shader_register_range range;
     enum vkd3d_shader_resource_type resource_type;
     enum dxil_resource_kind kind;
-    enum vkd3d_data_type resource_data_type;
+    enum vsir_data_type resource_data_type;
     enum vkd3d_shader_register_type reg_type;
-    enum vkd3d_data_type reg_data_type;
+    enum vsir_data_type reg_data_type;
 };
 
 struct sm6_parser
@@ -2467,13 +2467,13 @@ static struct vkd3d_shader_dst_param *instruction_dst_params_alloc(struct vkd3d_
 }
 
 static void register_init_with_id(struct vkd3d_shader_register *reg,
-        enum vkd3d_shader_register_type reg_type, enum vkd3d_data_type data_type, unsigned int id)
+        enum vkd3d_shader_register_type reg_type, enum vsir_data_type data_type, unsigned int id)
 {
     vsir_register_init(reg, reg_type, data_type, 1);
     reg->idx[0].offset = id;
 }
 
-static enum vkd3d_data_type vkd3d_data_type_from_sm6_type(const struct sm6_type *type)
+static enum vsir_data_type vsir_data_type_from_dxil(const struct sm6_type *type)
 {
     if (type->class == TYPE_CLASS_INTEGER)
     {
@@ -2499,14 +2499,14 @@ static enum vkd3d_data_type vkd3d_data_type_from_sm6_type(const struct sm6_type
         switch (type->u.width)
         {
             case 16:
-                return VKD3D_DATA_HALF;
+                return VSIR_DATA_F16;
             case 32:
-                return VKD3D_DATA_FLOAT;
+                return VSIR_DATA_F32;
             case 64:
-                return VKD3D_DATA_DOUBLE;
+                return VSIR_DATA_F64;
             default:
                 FIXME("Unhandled width %u.\n", type->u.width);
-                return VKD3D_DATA_FLOAT;
+                return VSIR_DATA_F32;
         }
     }
 
@@ -2562,8 +2562,8 @@ static void register_convert_to_minimum_precision(struct vkd3d_shader_register *
 
     switch (reg->data_type)
     {
-        case VKD3D_DATA_HALF:
-            reg->data_type = VKD3D_DATA_FLOAT;
+        case VSIR_DATA_F16:
+            reg->data_type = VSIR_DATA_F32;
             reg->precision = VKD3D_SHADER_REGISTER_PRECISION_MIN_FLOAT_16;
             if (reg->type == VKD3DSPR_IMMCONST)
             {
@@ -2594,10 +2594,10 @@ static void sm6_register_from_value(struct vkd3d_shader_register *reg, const str
         struct sm6_parser *sm6)
 {
     const struct sm6_type *scalar_type;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
 
     scalar_type = sm6_type_get_scalar_type(value->type, 0);
-    data_type = vkd3d_data_type_from_sm6_type(scalar_type);
+    data_type = vsir_data_type_from_dxil(scalar_type);
 
     switch (value->value_type)
     {
@@ -3237,7 +3237,7 @@ static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, co
     dst->u.data = icb;
 
     icb->register_idx = sm6->icb_count++;
-    icb->data_type = vkd3d_data_type_from_sm6_type(elem_type);
+    icb->data_type = vsir_data_type_from_dxil(elem_type);
     icb->element_count = type->u.array.count;
     icb->component_count = 1;
     icb->is_null = !operands;
@@ -3248,10 +3248,10 @@ static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, co
     count = type->u.array.count;
     switch (icb->data_type)
     {
-        case VKD3D_DATA_HALF:
+        case VSIR_DATA_F16:
             for (i = 0; i < count; ++i)
                 icb->data[i] = half_to_float(operands[i]);
-            icb->data_type = VKD3D_DATA_FLOAT;
+            icb->data_type = VSIR_DATA_F32;
             break;
 
         case VKD3D_DATA_UINT16:
@@ -3260,13 +3260,13 @@ static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, co
             icb->data_type = VKD3D_DATA_UINT;
             break;
 
-        case VKD3D_DATA_FLOAT:
+        case VSIR_DATA_F32:
         case VKD3D_DATA_UINT:
             for (i = 0; i < count; ++i)
                 icb->data[i] = operands[i];
             break;
 
-        case VKD3D_DATA_DOUBLE:
+        case VSIR_DATA_F64:
         case VKD3D_DATA_UINT64:
             data64 = (uint64_t *)icb->data;
             for (i = 0; i < count; ++i)
@@ -3690,7 +3690,7 @@ static void sm6_parser_declare_indexable_temp(struct sm6_parser *sm6, const stru
         unsigned int count, unsigned int alignment, bool has_function_scope, unsigned int init,
         struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
 {
-    enum vkd3d_data_type data_type = vkd3d_data_type_from_sm6_type(elem_type);
+    enum vsir_data_type data_type = vsir_data_type_from_dxil(elem_type);
 
     if (ins)
         vsir_instruction_init(ins, &sm6->p.location, VSIR_OP_DCL_INDEXABLE_TEMP);
@@ -4068,8 +4068,8 @@ static enum vkd3d_result sm6_parser_globals_init(struct sm6_parser *sm6)
     return VKD3D_OK;
 }
 
-static void dst_param_io_init(struct vkd3d_shader_dst_param *param,
-        const struct signature_element *e, enum vkd3d_shader_register_type reg_type)
+static void dst_param_io_init(struct vkd3d_shader_dst_param *param, const struct signature_element *e,
+        enum vkd3d_shader_register_type reg_type, enum vsir_dimension dimension)
 {
     enum vkd3d_shader_component_type component_type;
 
@@ -4078,8 +4078,8 @@ static void dst_param_io_init(struct vkd3d_shader_dst_param *param,
     param->shift = 0;
     /* DXIL types do not have signedness. Load signed elements as unsigned. */
     component_type = e->component_type == VKD3D_SHADER_COMPONENT_INT ? VKD3D_SHADER_COMPONENT_UINT : e->component_type;
-    vsir_register_init(&param->reg, reg_type, vkd3d_data_type_from_component_type(component_type), 0);
-    param->reg.dimension = VSIR_DIMENSION_VEC4;
+    vsir_register_init(&param->reg, reg_type, vsir_data_type_from_component_type(component_type), 0);
+    param->reg.dimension = dimension;
 }
 
 static void src_params_init_from_operands(struct vkd3d_shader_src_param *src_params,
@@ -4092,8 +4092,10 @@ static void src_params_init_from_operands(struct vkd3d_shader_src_param *src_par
 }
 
 static enum vkd3d_shader_register_type register_type_from_dxil_semantic_kind(
-        enum vkd3d_shader_sysval_semantic sysval_semantic, bool is_input)
+        enum vkd3d_shader_sysval_semantic sysval_semantic, bool is_input, enum vsir_dimension *dimension)
 {
+    *dimension = VSIR_DIMENSION_VEC4;
+
     switch (sysval_semantic)
     {
         /* VSIR does not use an I/O register for SV_SampleIndex, but its
@@ -4104,10 +4106,13 @@ static enum vkd3d_shader_register_type register_type_from_dxil_semantic_kind(
         case VKD3D_SHADER_SV_COVERAGE:
             return is_input ? VKD3DSPR_COVERAGE : VKD3DSPR_SAMPLEMASK;
         case VKD3D_SHADER_SV_DEPTH:
+            *dimension = VSIR_DIMENSION_SCALAR;
             return VKD3DSPR_DEPTHOUT;
         case VKD3D_SHADER_SV_DEPTH_GREATER_EQUAL:
+            *dimension = VSIR_DIMENSION_SCALAR;
             return VKD3DSPR_DEPTHOUTGE;
         case VKD3D_SHADER_SV_DEPTH_LESS_EQUAL:
+            *dimension = VSIR_DIMENSION_SCALAR;
             return VKD3DSPR_DEPTHOUTLE;
         default:
             return VKD3DSPR_INVALID;
@@ -4147,18 +4152,21 @@ static void sm6_parser_init_signature(struct sm6_parser *sm6, const struct shade
 
     for (i = 0; i < s->element_count; ++i)
     {
+        enum vsir_dimension dimension;
+
         e = &s->elements[i];
 
         param = &params[i];
 
         if (e->register_index == UINT_MAX
-                && (io_reg_type = register_type_from_dxil_semantic_kind(e->sysval_semantic, is_input)) != VKD3DSPR_NULL)
+                && (io_reg_type = register_type_from_dxil_semantic_kind(
+                e->sysval_semantic, is_input, &dimension)) != VKD3DSPR_NULL)
         {
-            dst_param_io_init(param, e, io_reg_type);
+            dst_param_io_init(param, e, io_reg_type, dimension);
             continue;
         }
 
-        dst_param_io_init(param, e, reg_type);
+        dst_param_io_init(param, e, reg_type, VSIR_DIMENSION_VEC4);
         count = 0;
 
         if (is_control_point)
@@ -5169,7 +5177,7 @@ static void sm6_parser_emit_dx_cbuffer_load(struct sm6_parser *sm6, enum dx_intr
 
     type = sm6_type_get_scalar_type(dst->type, 0);
     VKD3D_ASSERT(type);
-    src_param->reg.data_type = vkd3d_data_type_from_sm6_type(type);
+    src_param->reg.data_type = vsir_data_type_from_dxil(type);
     if (data_type_is_64_bit(src_param->reg.data_type))
         src_param->swizzle = vsir_swizzle_64_from_32(src_param->swizzle);
     else
@@ -5179,7 +5187,7 @@ static void sm6_parser_emit_dx_cbuffer_load(struct sm6_parser *sm6, enum dx_intr
 }
 
 static void sm6_parser_dcl_register_builtin(struct sm6_parser *sm6, enum vkd3d_shader_opcode handler_idx,
-        enum vkd3d_shader_register_type reg_type, enum vkd3d_data_type data_type, unsigned int component_count)
+        enum vkd3d_shader_register_type reg_type, enum vsir_data_type data_type, unsigned int component_count)
 {
     struct vkd3d_shader_dst_param *dst_param;
     struct vkd3d_shader_instruction *ins;
@@ -5194,8 +5202,8 @@ static void sm6_parser_dcl_register_builtin(struct sm6_parser *sm6, enum vkd3d_s
     }
 }
 
-static void sm6_parser_emit_dx_input_register_mov(struct sm6_parser *sm6,
-        struct vkd3d_shader_instruction *ins, enum vkd3d_shader_register_type reg_type, enum vkd3d_data_type data_type)
+static void sm6_parser_emit_dx_input_register_mov(struct sm6_parser *sm6, struct vkd3d_shader_instruction *ins,
+        enum vkd3d_shader_register_type reg_type, enum vsir_data_type data_type, bool scalar)
 {
     struct vkd3d_shader_src_param *src_param;
 
@@ -5205,6 +5213,8 @@ static void sm6_parser_emit_dx_input_register_mov(struct sm6_parser *sm6,
         return;
     sm6_parser_dcl_register_builtin(sm6, VSIR_OP_DCL_INPUT, reg_type, data_type, 1);
     vsir_register_init(&src_param->reg, reg_type, data_type, 0);
+    if (!scalar)
+        src_param->reg.dimension = VSIR_DIMENSION_VEC4;
     src_param_init(src_param);
 
     instruction_dst_param_init_ssa_scalar(ins, sm6);
@@ -5213,7 +5223,7 @@ static void sm6_parser_emit_dx_input_register_mov(struct sm6_parser *sm6,
 static void sm6_parser_emit_dx_coverage(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_COVERAGE, VKD3D_DATA_UINT);
+    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_COVERAGE, VKD3D_DATA_UINT, false);
 }
 
 static const struct sm6_descriptor_info *sm6_parser_get_descriptor(struct sm6_parser *sm6,
@@ -5333,8 +5343,8 @@ static void sm6_parser_emit_dx_domain_location(struct sm6_parser *sm6, enum dx_i
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
         return;
-    sm6_parser_dcl_register_builtin(sm6, VSIR_OP_DCL_INPUT, VKD3DSPR_TESSCOORD, VKD3D_DATA_FLOAT, 3);
-    vsir_register_init(&src_param->reg, VKD3DSPR_TESSCOORD, VKD3D_DATA_FLOAT, 0);
+    sm6_parser_dcl_register_builtin(sm6, VSIR_OP_DCL_INPUT, VKD3DSPR_TESSCOORD, VSIR_DATA_F32, 3);
+    vsir_register_init(&src_param->reg, VKD3DSPR_TESSCOORD, VSIR_DATA_F32, 0);
     src_param->reg.dimension = VSIR_DIMENSION_VEC4;
     src_param_init_scalar(src_param, component_idx);
 
@@ -5477,11 +5487,9 @@ static void sm6_parser_emit_dx_compute_builtin(struct sm6_parser *sm6, enum dx_i
     if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
         return;
     vsir_register_init(&src_param->reg, reg_type, VKD3D_DATA_UINT, 0);
+    src_param->reg.dimension = VSIR_DIMENSION_VEC4;
     if (component_count > 1)
-    {
-        src_param->reg.dimension = VSIR_DIMENSION_VEC4;
         component_idx = sm6_value_get_constant_uint(operands[0], sm6);
-    }
     src_param_init_scalar(src_param, component_idx);
 
     instruction_dst_param_init_ssa_scalar(ins, sm6);
@@ -5713,13 +5721,13 @@ static void sm6_parser_emit_dx_make_double(struct sm6_parser *sm6, enum dx_intri
 static void sm6_parser_emit_dx_output_control_point_id(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_OUTPOINTID, VKD3D_DATA_UINT);
+    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_OUTPOINTID, VKD3D_DATA_UINT, true);
 }
 
 static void sm6_parser_emit_dx_primitive_id(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
-    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_PRIMID, VKD3D_DATA_UINT);
+    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, VKD3DSPR_PRIMID, VKD3D_DATA_UINT, true);
 }
 
 static enum vkd3d_shader_opcode dx_map_quad_op(enum dxil_quad_op_kind op)
@@ -5996,12 +6004,12 @@ static void sm6_parser_emit_dx_get_sample_count(struct sm6_parser *sm6, enum dx_
 
     if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
         return;
-    vsir_register_init(&src_param->reg, VKD3DSPR_RASTERIZER, VKD3D_DATA_FLOAT, 0);
+    vsir_register_init(&src_param->reg, VKD3DSPR_RASTERIZER, VSIR_DATA_F32, 0);
     src_param->reg.dimension = VSIR_DIMENSION_VEC4;
     src_param_init(src_param);
 
     instruction_dst_param_init_ssa_scalar(ins, sm6);
-    ins->dst->reg.data_type = VKD3D_DATA_FLOAT;
+    ins->dst->reg.data_type = VSIR_DATA_F32;
 }
 
 static void sm6_parser_emit_dx_get_sample_pos(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
@@ -6030,7 +6038,7 @@ static void sm6_parser_emit_dx_get_sample_pos(struct sm6_parser *sm6, enum dx_in
     else
     {
         src_param_init_vector(&src_params[0], 2);
-        vsir_register_init(&src_params[0].reg, VKD3DSPR_RASTERIZER, VKD3D_DATA_FLOAT, 0);
+        vsir_register_init(&src_params[0].reg, VKD3DSPR_RASTERIZER, VSIR_DATA_F32, 0);
         src_params[0].reg.dimension = VSIR_DIMENSION_VEC4;
         src_param_init_from_value(&src_params[1], operands[0], sm6);
     }
@@ -6535,7 +6543,7 @@ static void sm6_parser_emit_dx_wave_builtin(struct sm6_parser *sm6, enum dx_intr
             vkd3d_unreachable();
     }
 
-    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, type, VKD3D_DATA_UINT);
+    sm6_parser_emit_dx_input_register_mov(sm6, state->ins, type, VKD3D_DATA_UINT, true);
 }
 
 struct sm6_dx_opcode_info
@@ -9031,7 +9039,7 @@ static enum vkd3d_shader_resource_type shader_resource_type_from_dxil_resource_k
     }
 }
 
-static const enum vkd3d_data_type data_type_table[] =
+static const enum vsir_data_type data_type_table[] =
 {
     [COMPONENT_TYPE_INVALID]     = VKD3D_DATA_UNUSED,
     [COMPONENT_TYPE_I1]          = VKD3D_DATA_UNUSED,
@@ -9041,30 +9049,30 @@ static const enum vkd3d_data_type data_type_table[] =
     [COMPONENT_TYPE_U32]         = VKD3D_DATA_UINT,
     [COMPONENT_TYPE_I64]         = VKD3D_DATA_UNUSED,
     [COMPONENT_TYPE_U64]         = VKD3D_DATA_UNUSED,
-    [COMPONENT_TYPE_F16]         = VKD3D_DATA_FLOAT,
-    [COMPONENT_TYPE_F32]         = VKD3D_DATA_FLOAT,
-    [COMPONENT_TYPE_F64]         = VKD3D_DATA_DOUBLE,
+    [COMPONENT_TYPE_F16]         = VSIR_DATA_F32,
+    [COMPONENT_TYPE_F32]         = VSIR_DATA_F32,
+    [COMPONENT_TYPE_F64]         = VSIR_DATA_F64,
     [COMPONENT_TYPE_SNORMF16]    = VKD3D_DATA_SNORM,
     [COMPONENT_TYPE_UNORMF16]    = VKD3D_DATA_UNORM,
     [COMPONENT_TYPE_SNORMF32]    = VKD3D_DATA_SNORM,
     [COMPONENT_TYPE_UNORMF32]    = VKD3D_DATA_UNORM,
-    [COMPONENT_TYPE_SNORMF64]    = VKD3D_DATA_DOUBLE,
-    [COMPONENT_TYPE_UNORMF64]    = VKD3D_DATA_DOUBLE,
+    [COMPONENT_TYPE_SNORMF64]    = VSIR_DATA_F64,
+    [COMPONENT_TYPE_UNORMF64]    = VSIR_DATA_F64,
     [COMPONENT_TYPE_PACKEDS8X32] = VKD3D_DATA_UNUSED,
     [COMPONENT_TYPE_PACKEDU8X32] = VKD3D_DATA_UNUSED,
 };
 
-static enum vkd3d_data_type vkd3d_data_type_from_dxil_component_type(enum dxil_component_type type,
+static enum vsir_data_type vsir_data_type_from_dxil_component_type(enum dxil_component_type type,
         struct sm6_parser *sm6)
 {
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
 
     if (type >= ARRAY_SIZE(data_type_table) || (data_type = data_type_table[type]) == VKD3D_DATA_UNUSED)
     {
         FIXME("Unhandled component type %u.\n", type);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
                 "Resource descriptor component type %u is unhandled.", type);
-        return VKD3D_DATA_FLOAT;
+        return VSIR_DATA_F32;
     }
 
     return data_type;
@@ -9072,7 +9080,7 @@ static enum vkd3d_data_type vkd3d_data_type_from_dxil_component_type(enum dxil_c
 
 struct resource_additional_values
 {
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     unsigned int byte_stride;
 };
 
@@ -9113,7 +9121,7 @@ static bool resources_load_additional_values(struct resource_additional_values *
                             "An untyped resource has type %u.", value);
                     return false;
                 }
-                info->data_type = vkd3d_data_type_from_dxil_component_type(value, sm6);
+                info->data_type = vsir_data_type_from_dxil_component_type(value, sm6);
                 break;
 
             case RESOURCE_TAG_ELEMENT_STRIDE:
@@ -9241,8 +9249,8 @@ static struct vkd3d_shader_resource *sm6_parser_resources_load_common_info(struc
 }
 
 static void init_resource_declaration(struct vkd3d_shader_resource *resource,
-        enum vkd3d_shader_register_type reg_type, enum vkd3d_data_type data_type, unsigned int id,
-        const struct vkd3d_shader_register_range *range)
+        enum vkd3d_shader_register_type reg_type, enum vsir_data_type data_type,
+        unsigned int id, const struct vkd3d_shader_register_range *range)
 {
     struct vkd3d_shader_dst_param *param = &resource->reg;
 
@@ -9413,7 +9421,7 @@ static enum vkd3d_result sm6_parser_resources_load_cbv(struct sm6_parser *sm6,
     ins->declaration.cb.src.modifiers = VKD3DSPSM_NONE;
 
     reg = &ins->declaration.cb.src.reg;
-    vsir_register_init(reg, VKD3DSPR_CONSTBUFFER, VKD3D_DATA_FLOAT, 3);
+    vsir_register_init(reg, VKD3DSPR_CONSTBUFFER, VSIR_DATA_F32, 3);
     reg->idx[0].offset = d->id;
     reg->idx[1].offset = d->range.first;
     reg->idx[2].offset = d->range.last;
@@ -9421,8 +9429,8 @@ static enum vkd3d_result sm6_parser_resources_load_cbv(struct sm6_parser *sm6,
     ins->declaration.cb.range = d->range;
 
     d->reg_type = VKD3DSPR_CONSTBUFFER;
-    d->reg_data_type = VKD3D_DATA_FLOAT;
-    d->resource_data_type = VKD3D_DATA_FLOAT;
+    d->reg_data_type = VSIR_DATA_F32;
+    d->resource_data_type = VSIR_DATA_F32;
 
     return VKD3D_OK;
 }
@@ -9815,7 +9823,9 @@ static enum vkd3d_result sm6_parser_read_signature(struct sm6_parser *sm6, const
 
         if ((is_register = e->register_index == UINT_MAX))
         {
-            if (register_type_from_dxil_semantic_kind(e->sysval_semantic, is_input) == VKD3DSPR_INVALID)
+            enum vsir_dimension dimension;
+
+            if (register_type_from_dxil_semantic_kind(e->sysval_semantic, is_input, &dimension) == VKD3DSPR_INVALID)
             {
                 WARN("Unhandled I/O register semantic kind %u.\n", j);
                 vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
diff --git a/libs/vkd3d/libs/vkd3d-shader/glsl.c b/libs/vkd3d/libs/vkd3d-shader/glsl.c
index b3e3d10791d..bf407f0fc9c 100644
--- a/libs/vkd3d/libs/vkd3d-shader/glsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/glsl.c
@@ -328,12 +328,12 @@ static void glsl_src_cleanup(struct glsl_src *src, struct vkd3d_string_buffer_ca
 }
 
 static void shader_glsl_print_bitcast(struct vkd3d_string_buffer *dst, struct vkd3d_glsl_generator *gen,
-        const char *src, enum vkd3d_data_type dst_data_type, enum vkd3d_data_type src_data_type, unsigned int size)
+        const char *src, enum vsir_data_type dst_data_type, enum vsir_data_type src_data_type, unsigned int size)
 {
     if (dst_data_type == VKD3D_DATA_UNORM || dst_data_type == VKD3D_DATA_SNORM)
-        dst_data_type = VKD3D_DATA_FLOAT;
+        dst_data_type = VSIR_DATA_F32;
     if (src_data_type == VKD3D_DATA_UNORM || src_data_type == VKD3D_DATA_SNORM)
-        src_data_type = VKD3D_DATA_FLOAT;
+        src_data_type = VSIR_DATA_F32;
 
     if (dst_data_type == src_data_type)
     {
@@ -341,7 +341,7 @@ static void shader_glsl_print_bitcast(struct vkd3d_string_buffer *dst, struct vk
         return;
     }
 
-    if (src_data_type == VKD3D_DATA_FLOAT)
+    if (src_data_type == VSIR_DATA_F32)
     {
         switch (dst_data_type)
         {
@@ -360,7 +360,7 @@ static void shader_glsl_print_bitcast(struct vkd3d_string_buffer *dst, struct vk
     {
         switch (dst_data_type)
         {
-            case VKD3D_DATA_FLOAT:
+            case VSIR_DATA_F32:
                 vkd3d_string_buffer_printf(dst, "uintBitsToFloat(%s)", src);
                 return;
             case VKD3D_DATA_INT:
@@ -381,11 +381,11 @@ static void shader_glsl_print_bitcast(struct vkd3d_string_buffer *dst, struct vk
 }
 
 static void shader_glsl_print_src(struct vkd3d_string_buffer *buffer, struct vkd3d_glsl_generator *gen,
-        const struct vkd3d_shader_src_param *vsir_src, uint32_t mask, enum vkd3d_data_type data_type)
+        const struct vkd3d_shader_src_param *vsir_src, uint32_t mask, enum vsir_data_type data_type)
 {
     const struct vkd3d_shader_register *reg = &vsir_src->reg;
     struct vkd3d_string_buffer *register_name, *str;
-    enum vkd3d_data_type src_data_type;
+    enum vsir_data_type src_data_type;
     unsigned int size;
 
     register_name = vkd3d_string_buffer_get(&gen->string_buffers);
@@ -397,7 +397,7 @@ static void shader_glsl_print_src(struct vkd3d_string_buffer *buffer, struct vkd
     if (reg->type == VKD3DSPR_IMMCONST || reg->type == VKD3DSPR_THREADID)
         src_data_type = VKD3D_DATA_UINT;
     else
-        src_data_type = VKD3D_DATA_FLOAT;
+        src_data_type = VSIR_DATA_F32;
 
     shader_glsl_print_register_name(register_name, gen, reg);
 
@@ -492,7 +492,7 @@ static void shader_glsl_print_subscript(struct vkd3d_string_buffer *buffer, stru
 }
 
 static void VKD3D_PRINTF_FUNC(4, 0) shader_glsl_vprint_assignment(struct vkd3d_glsl_generator *gen,
-        struct glsl_dst *dst, enum vkd3d_data_type data_type, const char *format, va_list args)
+        struct glsl_dst *dst, enum vsir_data_type data_type, const char *format, va_list args)
 {
     struct vkd3d_string_buffer *buffer = gen->buffer;
     uint32_t modifiers = dst->vsir->modifiers;
@@ -519,7 +519,7 @@ static void VKD3D_PRINTF_FUNC(4, 0) shader_glsl_vprint_assignment(struct vkd3d_g
             vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
                     "Internal compiler error: Unhandled destination register data type %#x.", data_type);
             /* fall through */
-        case VKD3D_DATA_FLOAT:
+        case VSIR_DATA_F32:
             close = false;
             break;
         case VKD3D_DATA_INT:
@@ -550,7 +550,7 @@ static void VKD3D_PRINTF_FUNC(3, 4) shader_glsl_print_assignment(
 }
 
 static void VKD3D_PRINTF_FUNC(4, 5) shader_glsl_print_assignment_ext(struct vkd3d_glsl_generator *gen,
-        struct glsl_dst *dst, enum vkd3d_data_type data_type, const char *format, ...)
+        struct glsl_dst *dst, enum vsir_data_type data_type, const char *format, ...)
 {
     va_list args;
 
@@ -797,7 +797,7 @@ static void shader_glsl_ld(struct vkd3d_glsl_generator *gen, const struct vkd3d_
     const struct vkd3d_shader_descriptor_info1 *d;
     enum vkd3d_shader_resource_type resource_type;
     struct vkd3d_string_buffer *fetch;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     struct glsl_src coord;
     struct glsl_dst dst;
     uint32_t coord_mask;
@@ -826,7 +826,7 @@ static void shader_glsl_ld(struct vkd3d_glsl_generator *gen, const struct vkd3d_
         resource_space = 0;
         resource_type = VKD3D_SHADER_RESOURCE_TEXTURE_2D;
         sample_count = 1;
-        data_type = VKD3D_DATA_FLOAT;
+        data_type = VSIR_DATA_F32;
     }
 
     if ((resource_type_info = shader_glsl_get_resource_type_info(resource_type)))
@@ -912,7 +912,7 @@ static void shader_glsl_sample(struct vkd3d_glsl_generator *gen, const struct vk
     enum vkd3d_shader_resource_type resource_type;
     unsigned int component_idx, coord_size;
     struct vkd3d_string_buffer *sample;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     struct glsl_dst dst;
 
     bias = ins->opcode == VSIR_OP_SAMPLE_B;
@@ -946,7 +946,7 @@ static void shader_glsl_sample(struct vkd3d_glsl_generator *gen, const struct vk
                 "Internal compiler error: Undeclared resource descriptor %u.", resource_id);
         resource_space = 0;
         resource_type = VKD3D_SHADER_RESOURCE_TEXTURE_2D;
-        data_type = VKD3D_DATA_FLOAT;
+        data_type = VSIR_DATA_F32;
     }
 
     if ((resource_type_info = shader_glsl_get_resource_type_info(resource_type)))
@@ -1061,7 +1061,7 @@ static void shader_glsl_load_uav_typed(struct vkd3d_glsl_generator *gen, const s
     enum vkd3d_shader_resource_type resource_type;
     unsigned int uav_id, uav_idx, uav_space;
     struct vkd3d_string_buffer *load;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     struct glsl_src coord;
     struct glsl_dst dst;
     uint32_t coord_mask;
@@ -1084,7 +1084,7 @@ static void shader_glsl_load_uav_typed(struct vkd3d_glsl_generator *gen, const s
                 "Internal compiler error: Undeclared UAV descriptor %u.", uav_id);
         uav_space = 0;
         resource_type = VKD3D_SHADER_RESOURCE_TEXTURE_2D;
-        data_type = VKD3D_DATA_FLOAT;
+        data_type = VSIR_DATA_F32;
     }
 
     if ((resource_type_info = shader_glsl_get_resource_type_info(resource_type)))
@@ -1121,7 +1121,7 @@ static void shader_glsl_store_uav_typed(struct vkd3d_glsl_generator *gen, const
     enum vkd3d_shader_resource_type resource_type;
     unsigned int uav_id, uav_idx, uav_space;
     struct vkd3d_string_buffer *image_data;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     struct glsl_src image_coord;
     uint32_t coord_mask;
 
@@ -1143,7 +1143,7 @@ static void shader_glsl_store_uav_typed(struct vkd3d_glsl_generator *gen, const
                 "Internal compiler error: Undeclared UAV descriptor %u.", uav_id);
         uav_space = 0;
         resource_type = VKD3D_SHADER_RESOURCE_TEXTURE_2D;
-        data_type = VKD3D_DATA_FLOAT;
+        data_type = VSIR_DATA_F32;
     }
 
     if ((resource_type_info = shader_glsl_get_resource_type_info(resource_type)))
@@ -1174,7 +1174,7 @@ static void shader_glsl_store_uav_typed(struct vkd3d_glsl_generator *gen, const
                 vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
                         "Internal compiler error: Unhandled data type %#x.", data_type);
                 /* fall through */
-            case VKD3D_DATA_FLOAT:
+            case VSIR_DATA_F32:
             case VKD3D_DATA_UNORM:
             case VKD3D_DATA_SNORM:
                 vkd3d_string_buffer_printf(image_data, "vec4(");
@@ -1779,7 +1779,7 @@ static void shader_glsl_generate_uav_declaration(struct vkd3d_glsl_generator *ge
                     "Internal compiler error: Unhandled data type %#x for UAV %u.",
                     uav->resource_data_type, uav->register_id);
             /* fall through */
-        case VKD3D_DATA_FLOAT:
+        case VSIR_DATA_F32:
         case VKD3D_DATA_UNORM:
         case VKD3D_DATA_SNORM:
             image_type_prefix = "";
@@ -2001,7 +2001,7 @@ static void shader_glsl_generate_sampler_declaration(struct vkd3d_glsl_generator
         case VKD3D_DATA_INT:
             sampler_type_prefix = "i";
             break;
-        case VKD3D_DATA_FLOAT:
+        case VSIR_DATA_F32:
         case VKD3D_DATA_UNORM:
         case VKD3D_DATA_SNORM:
             sampler_type_prefix = "";
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index afd6169514f..86198ce548f 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -233,6 +233,20 @@ static bool divert_written_uniform_derefs_to_temp(struct hlsl_ctx *ctx, struct h
     return true;
 }
 
+static void warn_on_field_semantic(struct hlsl_ctx *ctx,
+        const struct hlsl_struct_field *field, const struct hlsl_semantic *outer)
+{
+    if (!field->semantic.name)
+        return;
+
+    if (!ascii_strcasecmp(field->semantic.name, outer->name) && field->semantic.index == outer->index)
+        return;
+
+    hlsl_warning(ctx, &field->loc, VKD3D_SHADER_WARNING_HLSL_OVERRIDDEN_SEMANTIC,
+            "Field semantic %s%u is overridden by outer semantic %s%u.\n",
+            field->semantic.name, field->semantic.index, outer->name, outer->index);
+}
+
 static void validate_field_semantic(struct hlsl_ctx *ctx, struct hlsl_struct_field *field)
 {
     if (!field->semantic.name && hlsl_is_numeric_type(hlsl_get_multiarray_element_type(field->type))
@@ -288,10 +302,10 @@ static bool types_are_semantic_equivalent(struct hlsl_ctx *ctx, const struct hls
 
 static struct hlsl_ir_var *add_semantic_var(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *func,
         struct hlsl_ir_var *var, struct hlsl_type *type, uint32_t modifiers, struct hlsl_semantic *semantic,
-        uint32_t index, uint32_t stream_index, bool output, bool force_align, bool create,
-        const struct vkd3d_shader_location *loc)
+        uint32_t stream_index, bool output, bool force_align, bool create, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_semantic new_semantic;
+    uint32_t index = semantic->index;
     struct hlsl_ir_var *ext_var;
     const char *prefix;
     char *new_name;
@@ -397,7 +411,7 @@ static uint32_t combine_field_storage_modifiers(uint32_t modifiers, uint32_t fie
 
 static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *func,
         struct hlsl_block *block, uint32_t prim_index, struct hlsl_ir_load *lhs,
-        uint32_t modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index, bool force_align)
+        uint32_t modifiers, struct hlsl_semantic *semantic, bool force_align)
 {
     struct hlsl_type *type = lhs->node.data_type, *vector_type_src, *vector_type_dst;
     struct vkd3d_shader_location *loc = &lhs->node.loc;
@@ -442,8 +456,9 @@ static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_dec
             prim_type_src->modifiers = var->data_type->modifiers & HLSL_PRIMITIVE_MODIFIERS_MASK;
 
             if (!(input = add_semantic_var(ctx, func, var, prim_type_src,
-                    modifiers, semantic, semantic_index + i, 0, false, force_align, true, loc)))
+                    modifiers, semantic, 0, false, force_align, true, loc)))
                 return;
+            ++semantic->index;
             hlsl_init_simple_deref_from_var(&prim_deref, input);
 
             idx = hlsl_block_add_uint_constant(ctx, block, prim_index, &var->loc);
@@ -455,8 +470,9 @@ static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_dec
         else
         {
             if (!(input = add_semantic_var(ctx, func, var, vector_type_src,
-                    modifiers, semantic, semantic_index + i, 0, false, force_align, true, loc)))
+                    modifiers, semantic, 0, false, force_align, true, loc)))
                 return;
+            ++semantic->index;
 
             if (!(load = hlsl_new_var_load(ctx, input, &var->loc)))
                 return;
@@ -482,7 +498,7 @@ static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_dec
 
 static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *func,
         struct hlsl_block *block, uint32_t prim_index, struct hlsl_ir_load *lhs,
-        uint32_t modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index, bool force_align)
+        uint32_t modifiers, struct hlsl_semantic *semantic, bool force_align)
 {
     struct vkd3d_shader_location *loc = &lhs->node.loc;
     struct hlsl_type *type = lhs->node.data_type;
@@ -494,21 +510,31 @@ static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_ir_func
     {
         struct hlsl_ir_load *element_load;
         struct hlsl_struct_field *field;
-        uint32_t elem_semantic_index;
 
         for (i = 0; i < hlsl_type_element_count(type); ++i)
         {
             uint32_t element_modifiers;
 
+            if (type->class == HLSL_CLASS_STRUCT)
+                loc = &type->e.record.fields[i].loc;
+
+            c = hlsl_block_add_uint_constant(ctx, block, i, &var->loc);
+
+            /* This redundant load is expected to be deleted later by DCE. */
+            if (!(element_load = hlsl_new_load_index(ctx, &lhs->src, c, loc)))
+                return;
+            hlsl_block_add_instr(block, &element_load->node);
+
             if (type->class == HLSL_CLASS_ARRAY)
             {
-                elem_semantic_index = semantic_index
-                        + i * hlsl_type_get_array_element_reg_size(type->e.array.type, HLSL_REGSET_NUMERIC) / 4;
                 element_modifiers = modifiers;
                 force_align = true;
 
                 if (hlsl_type_is_primitive_array(type))
                     prim_index = i;
+
+                prepend_input_copy_recurse(ctx, func, block, prim_index,
+                        element_load, element_modifiers, semantic, force_align);
             }
             else
             {
@@ -518,28 +544,33 @@ static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_ir_func
                     hlsl_fixme(ctx, &field->loc, "Prepend uniform copies for resource components within structs.");
                     continue;
                 }
-                validate_field_semantic(ctx, field);
-                semantic = &field->semantic;
-                elem_semantic_index = semantic->index;
-                loc = &field->loc;
                 element_modifiers = combine_field_storage_modifiers(modifiers, field->storage_modifiers);
                 force_align = (i == 0);
-            }
 
-            c = hlsl_block_add_uint_constant(ctx, block, i, &var->loc);
+                if (semantic->name)
+                {
+                    warn_on_field_semantic(ctx, field, semantic);
+                    prepend_input_copy_recurse(ctx, func, block, prim_index,
+                            element_load, element_modifiers, semantic, force_align);
+                }
+                else
+                {
+                    struct hlsl_semantic semantic_copy;
 
-            /* This redundant load is expected to be deleted later by DCE. */
-            if (!(element_load = hlsl_new_load_index(ctx, &lhs->src, c, loc)))
-                return;
-            hlsl_block_add_instr(block, &element_load->node);
+                    validate_field_semantic(ctx, field);
 
-            prepend_input_copy_recurse(ctx, func, block, prim_index, element_load,
-                    element_modifiers, semantic, elem_semantic_index, force_align);
+                    if (!(hlsl_clone_semantic(ctx, &semantic_copy, &field->semantic)))
+                        return;
+                    prepend_input_copy_recurse(ctx, func, block, prim_index,
+                            element_load, element_modifiers, &semantic_copy, force_align);
+                    hlsl_cleanup_semantic(&semantic_copy);
+                }
+            }
         }
     }
     else
     {
-        prepend_input_copy(ctx, func, block, prim_index, lhs, modifiers, semantic, semantic_index, force_align);
+        prepend_input_copy(ctx, func, block, prim_index, lhs, modifiers, semantic, force_align);
     }
 }
 
@@ -547,6 +578,7 @@ static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_ir_func
  * and copy the former to the latter, so that writes to input variables work. */
 static void prepend_input_var_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *func, struct hlsl_ir_var *var)
 {
+    struct hlsl_semantic semantic_copy;
     struct hlsl_ir_load *load;
     struct hlsl_block block;
 
@@ -557,15 +589,20 @@ static void prepend_input_var_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function
         return;
     hlsl_block_add_instr(&block, &load->node);
 
-    prepend_input_copy_recurse(ctx, func, &block, 0, load, var->storage_modifiers,
-            &var->semantic, var->semantic.index, false);
+    if (!hlsl_clone_semantic(ctx, &semantic_copy, &var->semantic))
+    {
+        hlsl_block_cleanup(&block);
+        return;
+    }
+    prepend_input_copy_recurse(ctx, func, &block, 0, load, var->storage_modifiers, &semantic_copy, false);
+    hlsl_cleanup_semantic(&semantic_copy);
 
     list_move_head(&func->body.instrs, &block.instrs);
 }
 
 static void append_output_copy(struct hlsl_ctx *ctx, struct hlsl_block *block,
         struct hlsl_ir_function_decl *func, struct hlsl_ir_load *rhs, uint32_t modifiers,
-        struct hlsl_semantic *semantic, uint32_t semantic_index, uint32_t stream_index, bool force_align, bool create)
+        struct hlsl_semantic *semantic, uint32_t stream_index, bool force_align, bool create)
 {
     struct hlsl_type *type = rhs->node.data_type, *vector_type;
     struct vkd3d_shader_location *loc = &rhs->node.loc;
@@ -594,9 +631,10 @@ static void append_output_copy(struct hlsl_ctx *ctx, struct hlsl_block *block,
         struct hlsl_ir_var *output;
         struct hlsl_ir_node *load;
 
-        if (!(output = add_semantic_var(ctx, func, var, vector_type,
-                modifiers, semantic, semantic_index + i, stream_index, true, force_align, create, loc)))
+        if (!(output = add_semantic_var(ctx, func, var, vector_type, modifiers,
+                semantic, stream_index, true, force_align, create, loc)))
             return;
+        ++semantic->index;
 
         if (type->class == HLSL_CLASS_MATRIX)
         {
@@ -615,8 +653,8 @@ static void append_output_copy(struct hlsl_ctx *ctx, struct hlsl_block *block,
 }
 
 static void append_output_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_block *block,
-        struct hlsl_ir_function_decl *func, const struct hlsl_type *type, struct hlsl_ir_load *rhs, uint32_t modifiers,
-        struct hlsl_semantic *semantic, uint32_t semantic_index, uint32_t stream_index, bool force_align, bool create)
+        struct hlsl_ir_function_decl *func, const struct hlsl_type *type, struct hlsl_ir_load *rhs,
+        uint32_t modifiers, struct hlsl_semantic *semantic, uint32_t stream_index, bool force_align, bool create)
 {
     struct vkd3d_shader_location *loc = &rhs->node.loc;
     struct hlsl_ir_var *var = rhs->src.var;
@@ -627,47 +665,62 @@ static void append_output_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_block *
     {
         for (i = 0; i < hlsl_type_element_count(type); ++i)
         {
-            uint32_t element_modifiers, elem_semantic_index;
             const struct hlsl_type *element_type;
             struct hlsl_ir_load *element_load;
             struct hlsl_struct_field *field;
+            uint32_t element_modifiers;
+
+            if (type->class == HLSL_CLASS_STRUCT)
+                loc = &type->e.record.fields[i].loc;
+
+            c = hlsl_block_add_uint_constant(ctx, block, i, &var->loc);
+            if (!(element_load = hlsl_new_load_index(ctx, &rhs->src, c, loc)))
+                return;
+            hlsl_block_add_instr(block, &element_load->node);
 
             if (type->class == HLSL_CLASS_ARRAY)
             {
-                elem_semantic_index = semantic_index
-                        + i * hlsl_type_get_array_element_reg_size(type->e.array.type, HLSL_REGSET_NUMERIC) / 4;
                 element_type = type->e.array.type;
                 element_modifiers = modifiers;
                 force_align = true;
+
+                append_output_copy_recurse(ctx, block, func, element_type, element_load,
+                        element_modifiers, semantic, stream_index, force_align, create);
             }
             else
             {
                 field = &type->e.record.fields[i];
                 if (hlsl_type_is_resource(field->type))
                     continue;
-                validate_field_semantic(ctx, field);
-                semantic = &field->semantic;
-                elem_semantic_index = semantic->index;
-                loc = &field->loc;
                 element_type = field->type;
                 element_modifiers = combine_field_storage_modifiers(modifiers, field->storage_modifiers);
                 force_align = (i == 0);
-            }
 
-            c = hlsl_block_add_uint_constant(ctx, block, i, &var->loc);
+                if (semantic->name)
+                {
+                    warn_on_field_semantic(ctx, field, semantic);
 
-            if (!(element_load = hlsl_new_load_index(ctx, &rhs->src, c, loc)))
-                return;
-            hlsl_block_add_instr(block, &element_load->node);
+                    append_output_copy_recurse(ctx, block, func, element_type, element_load,
+                            element_modifiers, semantic, stream_index, force_align, create);
+                }
+                else
+                {
+                    struct hlsl_semantic semantic_copy;
+
+                    validate_field_semantic(ctx, field);
 
-            append_output_copy_recurse(ctx, block, func, element_type, element_load, element_modifiers, semantic,
-                    elem_semantic_index, stream_index, force_align, create);
+                    if (!hlsl_clone_semantic(ctx, &semantic_copy, &field->semantic))
+                        continue;
+                    append_output_copy_recurse(ctx, block, func, element_type, element_load,
+                            element_modifiers, &semantic_copy, stream_index, force_align, create);
+                    hlsl_cleanup_semantic(&semantic_copy);
+                }
+            }
         }
     }
     else
     {
-        append_output_copy(ctx, block, func, rhs, modifiers, semantic,
-                semantic_index, stream_index, force_align, create);
+        append_output_copy(ctx, block, func, rhs, modifiers, semantic, stream_index, force_align, create);
     }
 }
 
@@ -676,6 +729,7 @@ static void append_output_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_block *
  * variables work. */
 static void append_output_var_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *func, struct hlsl_ir_var *var)
 {
+    struct hlsl_semantic semantic_copy;
     struct hlsl_ir_load *load;
 
     /* This redundant load is expected to be deleted later by DCE. */
@@ -683,8 +737,11 @@ static void append_output_var_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function
         return;
     hlsl_block_add_instr(&func->body, &load->node);
 
-    append_output_copy_recurse(ctx, &func->body, func, var->data_type, load, var->storage_modifiers,
-            &var->semantic, var->semantic.index, 0, false, true);
+    if (!hlsl_clone_semantic(ctx, &semantic_copy, &var->semantic))
+        return;
+    append_output_copy_recurse(ctx, &func->body, func, var->data_type,
+            load, var->storage_modifiers, &semantic_copy, 0, false, true);
+    hlsl_cleanup_semantic(&semantic_copy);
 }
 
 bool hlsl_transform_ir(struct hlsl_ctx *ctx, bool (*func)(struct hlsl_ctx *ctx, struct hlsl_ir_node *, void *),
@@ -3375,6 +3432,7 @@ static bool lower_stream_appends(struct hlsl_ctx *ctx, struct hlsl_ir_node *inst
 {
     struct stream_append_ctx *append_ctx = context;
     struct hlsl_ir_resource_store *store;
+    struct hlsl_semantic semantic_copy;
     const struct hlsl_ir_node *rhs;
     const struct hlsl_type *type;
     struct hlsl_ir_var *var;
@@ -3405,9 +3463,12 @@ static bool lower_stream_appends(struct hlsl_ctx *ctx, struct hlsl_ir_node *inst
 
     hlsl_block_init(&block);
 
+    if (!hlsl_clone_semantic(ctx, &semantic_copy, &var->semantic))
+        return false;
     append_output_copy_recurse(ctx, &block, append_ctx->func, type->e.so.type, hlsl_ir_load(rhs),
-            var->storage_modifiers, &var->semantic, var->semantic.index,
-            var->regs[HLSL_REGSET_STREAM_OUTPUTS].index, false, !append_ctx->created[stream_index]);
+            var->storage_modifiers, &semantic_copy, var->regs[HLSL_REGSET_STREAM_OUTPUTS].index,
+            false, !append_ctx->created[stream_index]);
+    hlsl_cleanup_semantic(&semantic_copy);
 
     append_ctx->created[stream_index] = true;
 
@@ -8164,10 +8225,10 @@ static void generate_vsir_signature(struct hlsl_ctx *ctx,
     }
 }
 
-static enum vkd3d_data_type vsir_data_type_from_hlsl_type(struct hlsl_ctx *ctx, const struct hlsl_type *type)
+static enum vsir_data_type vsir_data_type_from_hlsl_type(struct hlsl_ctx *ctx, const struct hlsl_type *type)
 {
     if (hlsl_version_lt(ctx, 4, 0))
-        return VKD3D_DATA_FLOAT;
+        return VSIR_DATA_F32;
 
     if (type->class == HLSL_CLASS_ARRAY)
         return vsir_data_type_from_hlsl_type(ctx, type->e.array.type);
@@ -8178,11 +8239,11 @@ static enum vkd3d_data_type vsir_data_type_from_hlsl_type(struct hlsl_ctx *ctx,
         switch (type->e.numeric.type)
         {
             case HLSL_TYPE_DOUBLE:
-                return VKD3D_DATA_DOUBLE;
+                return VSIR_DATA_F64;
             case HLSL_TYPE_FLOAT:
-                return VKD3D_DATA_FLOAT;
+                return VSIR_DATA_F32;
             case HLSL_TYPE_HALF:
-                return VKD3D_DATA_HALF;
+                return VSIR_DATA_F16;
             case HLSL_TYPE_INT:
                 return VKD3D_DATA_INT;
             case HLSL_TYPE_UINT:
@@ -8195,7 +8256,7 @@ static enum vkd3d_data_type vsir_data_type_from_hlsl_type(struct hlsl_ctx *ctx,
     return VKD3D_DATA_UNUSED;
 }
 
-static enum vkd3d_data_type vsir_data_type_from_hlsl_instruction(struct hlsl_ctx *ctx,
+static enum vsir_data_type vsir_data_type_from_hlsl_instruction(struct hlsl_ctx *ctx,
         const struct hlsl_ir_node *instr)
 {
     return vsir_data_type_from_hlsl_type(ctx, instr->data_type);
@@ -8238,17 +8299,17 @@ static void sm1_generate_vsir_constant_defs(struct hlsl_ctx *ctx, struct vsir_pr
         ++instructions->count;
 
         dst_param = &ins->dst[0];
-        vsir_register_init(&dst_param->reg, VKD3DSPR_CONST, VKD3D_DATA_FLOAT, 1);
+        vsir_register_init(&dst_param->reg, VKD3DSPR_CONST, VSIR_DATA_F32, 1);
         ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
         ins->dst[0].reg.idx[0].offset = constant_reg->index;
         ins->dst[0].write_mask = VKD3DSP_WRITEMASK_ALL;
 
         src_param = &ins->src[0];
-        vsir_register_init(&src_param->reg, VKD3DSPR_IMMCONST, VKD3D_DATA_FLOAT, 0);
+        vsir_register_init(&src_param->reg, VKD3DSPR_IMMCONST, VSIR_DATA_F32, 0);
         src_param->reg.type = VKD3DSPR_IMMCONST;
         src_param->reg.precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
         src_param->reg.non_uniform = false;
-        src_param->reg.data_type = VKD3D_DATA_FLOAT;
+        src_param->reg.data_type = VSIR_DATA_F32;
         src_param->reg.dimension = VSIR_DIMENSION_VEC4;
         for (x = 0; x < 4; ++x)
             src_param->reg.u.immconst_f32[x] = constant_reg->value.f[x];
@@ -8324,7 +8385,7 @@ static void sm1_generate_vsir_sampler_dcls(struct hlsl_ctx *ctx,
                 semantic->resource_type = resource_type;
 
                 dst_param = &semantic->resource.reg;
-                vsir_register_init(&dst_param->reg, VKD3DSPR_SAMPLER, VKD3D_DATA_FLOAT, 1);
+                vsir_register_init(&dst_param->reg, VKD3DSPR_SAMPLER, VSIR_DATA_F32, 1);
                 dst_param->reg.dimension = VSIR_DIMENSION_NONE;
                 dst_param->reg.idx[0].offset = var->regs[HLSL_REGSET_SAMPLERS].index + i;
                 dst_param->write_mask = 0;
@@ -8394,7 +8455,7 @@ static struct vkd3d_shader_instruction *generate_vsir_add_program_instruction(
 
 static void vsir_src_from_hlsl_constant_value(struct vkd3d_shader_src_param *src,
         struct hlsl_ctx *ctx, const struct hlsl_constant_value *value,
-        enum vkd3d_data_type type, unsigned int width, unsigned int map_writemask)
+        enum vsir_data_type type, unsigned int width, unsigned int map_writemask)
 {
     unsigned int i, j;
 
@@ -8699,7 +8760,7 @@ static void sm1_generate_vsir_instr_constant(struct hlsl_ctx *ctx,
         return;
 
     src_param = &ins->src[0];
-    vsir_register_init(&src_param->reg, VKD3DSPR_CONST, VKD3D_DATA_FLOAT, 1);
+    vsir_register_init(&src_param->reg, VKD3DSPR_CONST, VSIR_DATA_F32, 1);
     src_param->reg.dimension = VSIR_DIMENSION_VEC4;
     src_param->reg.idx[0].offset = constant->reg.id;
     src_param->swizzle = generate_vsir_get_src_swizzle(constant->reg.writemask, instr->reg.writemask);
@@ -8789,13 +8850,13 @@ static void sm1_generate_vsir_instr_expr_per_component_instr_op(struct hlsl_ctx
                 return;
 
             dst_param = &ins->dst[0];
-            vsir_register_init(&dst_param->reg, instr->reg.type, VKD3D_DATA_FLOAT, 1);
+            vsir_register_init(&dst_param->reg, instr->reg.type, VSIR_DATA_F32, 1);
             dst_param->reg.idx[0].offset = instr->reg.id;
             dst_param->reg.dimension = VSIR_DIMENSION_VEC4;
             dst_param->write_mask = 1u << i;
 
             src_param = &ins->src[0];
-            vsir_register_init(&src_param->reg, operand->reg.type, VKD3D_DATA_FLOAT, 1);
+            vsir_register_init(&src_param->reg, operand->reg.type, VSIR_DATA_F32, 1);
             src_param->reg.idx[0].offset = operand->reg.id;
             src_param->reg.dimension = VSIR_DIMENSION_VEC4;
             c = vsir_swizzle_get_component(src_swizzle, i);
@@ -8825,13 +8886,13 @@ static void sm1_generate_vsir_instr_expr_sincos(struct hlsl_ctx *ctx, struct vsi
     if (ctx->profile->major_version < 3)
     {
         src_param = &ins->src[1];
-        vsir_register_init(&src_param->reg, VKD3DSPR_CONST, VKD3D_DATA_FLOAT, 1);
+        vsir_register_init(&src_param->reg, VKD3DSPR_CONST, VSIR_DATA_F32, 1);
         src_param->reg.dimension = VSIR_DIMENSION_VEC4;
         src_param->reg.idx[0].offset = ctx->d3dsincosconst1.id;
         src_param->swizzle = VKD3D_SHADER_NO_SWIZZLE;
 
         src_param = &ins->src[2];
-        vsir_register_init(&src_param->reg, VKD3DSPR_CONST, VKD3D_DATA_FLOAT, 1);
+        vsir_register_init(&src_param->reg, VKD3DSPR_CONST, VSIR_DATA_F32, 1);
         src_param->reg.dimension = VSIR_DIMENSION_VEC4;
         src_param->reg.idx[0].offset = ctx->d3dsincosconst2.id;
         src_param->swizzle = VKD3D_SHADER_NO_SWIZZLE;
@@ -9156,12 +9217,12 @@ static void sm1_generate_vsir_init_dst_param_from_deref(struct hlsl_ctx *ctx,
 
     if (type == VKD3DSPR_DEPTHOUT)
     {
-        vsir_register_init(&dst_param->reg, type, VKD3D_DATA_FLOAT, 0);
+        vsir_register_init(&dst_param->reg, type, VSIR_DATA_F32, 0);
         dst_param->reg.dimension = VSIR_DIMENSION_SCALAR;
     }
     else
     {
-        vsir_register_init(&dst_param->reg, type, VKD3D_DATA_FLOAT, 1);
+        vsir_register_init(&dst_param->reg, type, VSIR_DATA_F32, 1);
         dst_param->reg.idx[0].offset = register_index;
         dst_param->reg.dimension = VSIR_DIMENSION_VEC4;
     }
@@ -9184,7 +9245,7 @@ static void sm1_generate_vsir_instr_mova(struct hlsl_ctx *ctx,
         return;
 
     dst_param = &ins->dst[0];
-    vsir_register_init(&dst_param->reg, VKD3DSPR_ADDR, VKD3D_DATA_FLOAT, 0);
+    vsir_register_init(&dst_param->reg, VKD3DSPR_ADDR, VSIR_DATA_F32, 0);
     dst_param->write_mask = VKD3DSP_WRITEMASK_0;
 
     VKD3D_ASSERT(instr->data_type->class <= HLSL_CLASS_VECTOR);
@@ -9204,7 +9265,7 @@ static struct vkd3d_shader_src_param *sm1_generate_vsir_new_address_src(struct h
     }
 
     memset(idx_src, 0, sizeof(*idx_src));
-    vsir_register_init(&idx_src->reg, VKD3DSPR_ADDR, VKD3D_DATA_FLOAT, 0);
+    vsir_register_init(&idx_src->reg, VKD3DSPR_ADDR, VSIR_DATA_F32, 0);
     idx_src->reg.dimension = VSIR_DIMENSION_VEC4;
     idx_src->swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
     return idx_src;
@@ -9283,7 +9344,7 @@ static void sm1_generate_vsir_init_src_param_from_deref(struct hlsl_ctx *ctx,
         writemask = reg.writemask;
     }
 
-    vsir_register_init(&src_param->reg, type, VKD3D_DATA_FLOAT, 1);
+    vsir_register_init(&src_param->reg, type, VSIR_DATA_F32, 1);
     src_param->reg.dimension = VSIR_DIMENSION_VEC4;
     src_param->reg.idx[0].offset = register_index;
     src_param->reg.idx[0].rel_addr = src_rel_addr;
@@ -10132,18 +10193,18 @@ static void sm4_generate_vsir_instr_dcl_semantic(struct hlsl_ctx *ctx, struct vs
     if (is_primitive)
     {
         VKD3D_ASSERT(has_idx);
-        vsir_register_init(&dst_param->reg, type, VKD3D_DATA_FLOAT, 2);
+        vsir_register_init(&dst_param->reg, type, VSIR_DATA_F32, 2);
         dst_param->reg.idx[0].offset = var->data_type->e.array.elements_count;
         dst_param->reg.idx[1].offset = idx;
     }
     else if (has_idx)
     {
-        vsir_register_init(&dst_param->reg, type, VKD3D_DATA_FLOAT, 1);
+        vsir_register_init(&dst_param->reg, type, VSIR_DATA_F32, 1);
         dst_param->reg.idx[0].offset = idx;
     }
     else
     {
-        vsir_register_init(&dst_param->reg, type, VKD3D_DATA_FLOAT, 0);
+        vsir_register_init(&dst_param->reg, type, VSIR_DATA_F32, 0);
     }
 
     if (shader_sm4_is_scalar_register(&dst_param->reg))
@@ -10180,7 +10241,7 @@ static void sm4_generate_vsir_instr_dcl_indexable_temp(struct hlsl_ctx *ctx,
     ins->declaration.indexable_temp.register_idx = idx;
     ins->declaration.indexable_temp.register_size = size;
     ins->declaration.indexable_temp.alignment = 0;
-    ins->declaration.indexable_temp.data_type = VKD3D_DATA_FLOAT;
+    ins->declaration.indexable_temp.data_type = VSIR_DATA_F32;
     ins->declaration.indexable_temp.component_count = comp_count;
     ins->declaration.indexable_temp.has_function_scope = false;
 }
@@ -10371,7 +10432,7 @@ static void sm4_generate_vsir_rcp_using_div(struct hlsl_ctx *ctx,
     value.u[2].f = 1.0f;
     value.u[3].f = 1.0f;
     vsir_src_from_hlsl_constant_value(&ins->src[0], ctx, &value,
-            VKD3D_DATA_FLOAT, instr->data_type->e.numeric.dimx, dst_param->write_mask);
+            VSIR_DATA_F32, instr->data_type->e.numeric.dimx, dst_param->write_mask);
 
     vsir_src_from_hlsl_node(&ins->src[1], ctx, operand, dst_param->write_mask);
 }
@@ -12020,7 +12081,7 @@ static void sm4_generate_vsir_add_dcl_constant_buffer(struct hlsl_ctx *ctx,
     ins->declaration.cb.size = cbuffer->size;
 
     src_param = &ins->declaration.cb.src;
-    vsir_src_param_init(src_param, VKD3DSPR_CONSTBUFFER, VKD3D_DATA_FLOAT, 0);
+    vsir_src_param_init(src_param, VKD3DSPR_CONSTBUFFER, VSIR_DATA_F32, 0);
     src_param->reg.dimension = VSIR_DIMENSION_VEC4;
     src_param->swizzle = VKD3D_SHADER_NO_SWIZZLE;
 
@@ -12106,14 +12167,14 @@ static enum vkd3d_shader_resource_type sm4_generate_vsir_get_resource_type(const
     }
 }
 
-static enum vkd3d_data_type sm4_generate_vsir_get_format_type(const struct hlsl_type *type)
+static enum vsir_data_type sm4_generate_vsir_get_format_type(const struct hlsl_type *type)
 {
     const struct hlsl_type *format = type->e.resource.format;
 
     switch (format->e.numeric.type)
     {
         case HLSL_TYPE_DOUBLE:
-            return VKD3D_DATA_DOUBLE;
+            return VSIR_DATA_F64;
 
         case HLSL_TYPE_FLOAT:
         case HLSL_TYPE_HALF:
@@ -12121,7 +12182,7 @@ static enum vkd3d_data_type sm4_generate_vsir_get_format_type(const struct hlsl_
                 return VKD3D_DATA_UNORM;
             if (format->modifiers & HLSL_MODIFIER_SNORM)
                 return VKD3D_DATA_SNORM;
-            return VKD3D_DATA_FLOAT;
+            return VSIR_DATA_F32;
 
         case HLSL_TYPE_INT:
             return VKD3D_DATA_INT;
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index b060ccbb2bc..18cda0269af 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -555,7 +555,7 @@ static uint32_t vsir_combine_swizzles(uint32_t first, uint32_t second)
 }
 
 void vsir_register_init(struct vkd3d_shader_register *reg, enum vkd3d_shader_register_type reg_type,
-        enum vkd3d_data_type data_type, unsigned int idx_count)
+        enum vsir_data_type data_type, unsigned int idx_count)
 {
     reg->type = reg_type;
     reg->precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
@@ -581,7 +581,7 @@ static inline bool shader_register_is_phase_instance_id(const struct vkd3d_shade
 }
 
 void vsir_src_param_init(struct vkd3d_shader_src_param *param, enum vkd3d_shader_register_type reg_type,
-        enum vkd3d_data_type data_type, unsigned int idx_count)
+        enum vsir_data_type data_type, unsigned int idx_count)
 {
     vsir_register_init(&param->reg, reg_type, data_type, idx_count);
     param->swizzle = 0;
@@ -597,7 +597,7 @@ static void src_param_init_const_uint(struct vkd3d_shader_src_param *src, uint32
 static void vsir_src_param_init_io(struct vkd3d_shader_src_param *src,
         enum vkd3d_shader_register_type reg_type, const struct signature_element *e, unsigned int idx_count)
 {
-    vsir_src_param_init(src, reg_type, vkd3d_data_type_from_component_type(e->component_type), idx_count);
+    vsir_src_param_init(src, reg_type, vsir_data_type_from_component_type(e->component_type), idx_count);
     src->reg.dimension = VSIR_DIMENSION_VEC4;
     src->swizzle = vsir_swizzle_from_writemask(e->mask);
 }
@@ -609,13 +609,13 @@ void vsir_src_param_init_label(struct vkd3d_shader_src_param *param, unsigned in
     param->reg.idx[0].offset = label_id;
 }
 
-static void src_param_init_parameter(struct vkd3d_shader_src_param *src, uint32_t idx, enum vkd3d_data_type type)
+static void src_param_init_parameter(struct vkd3d_shader_src_param *src, uint32_t idx, enum vsir_data_type type)
 {
     vsir_src_param_init(src, VKD3DSPR_PARAMETER, type, 1);
     src->reg.idx[0].offset = idx;
 }
 
-static void src_param_init_parameter_vec4(struct vkd3d_shader_src_param *src, uint32_t idx, enum vkd3d_data_type type)
+static void src_param_init_parameter_vec4(struct vkd3d_shader_src_param *src, uint32_t idx, enum vsir_data_type type)
 {
     vsir_src_param_init(src, VKD3DSPR_PARAMETER, type, 1);
     src->reg.idx[0].offset = idx;
@@ -641,7 +641,7 @@ static void vsir_src_param_init_sampler(struct vkd3d_shader_src_param *src, unsi
 }
 
 static void src_param_init_ssa(struct vkd3d_shader_src_param *src, unsigned int idx,
-        enum vkd3d_data_type data_type, enum vsir_dimension dimension)
+        enum vsir_data_type data_type, enum vsir_dimension dimension)
 {
     vsir_src_param_init(src, VKD3DSPR_SSA, data_type, 1);
     src->reg.idx[0].offset = idx;
@@ -653,8 +653,8 @@ static void src_param_init_ssa(struct vkd3d_shader_src_param *src, unsigned int
     }
 }
 
-static void src_param_init_ssa_scalar(struct vkd3d_shader_src_param *src, unsigned int idx,
-        enum vkd3d_data_type data_type)
+static void src_param_init_ssa_scalar(struct vkd3d_shader_src_param *src,
+        unsigned int idx, enum vsir_data_type data_type)
 {
     src_param_init_ssa(src, idx, data_type, VSIR_DIMENSION_SCALAR);
 }
@@ -666,12 +666,12 @@ static void src_param_init_ssa_bool(struct vkd3d_shader_src_param *src, unsigned
 
 static void src_param_init_ssa_float(struct vkd3d_shader_src_param *src, unsigned int idx)
 {
-    src_param_init_ssa_scalar(src, idx, VKD3D_DATA_FLOAT);
+    src_param_init_ssa_scalar(src, idx, VSIR_DATA_F32);
 }
 
 static void src_param_init_ssa_float4(struct vkd3d_shader_src_param *src, unsigned int idx)
 {
-    src_param_init_ssa(src, idx, VKD3D_DATA_FLOAT, VSIR_DIMENSION_VEC4);
+    src_param_init_ssa(src, idx, VSIR_DATA_F32, VSIR_DIMENSION_VEC4);
 }
 
 static void src_param_init_temp_bool(struct vkd3d_shader_src_param *src, unsigned int idx)
@@ -682,13 +682,13 @@ static void src_param_init_temp_bool(struct vkd3d_shader_src_param *src, unsigne
 
 static void src_param_init_temp_float(struct vkd3d_shader_src_param *src, unsigned int idx)
 {
-    vsir_src_param_init(src, VKD3DSPR_TEMP, VKD3D_DATA_FLOAT, 1);
+    vsir_src_param_init(src, VKD3DSPR_TEMP, VSIR_DATA_F32, 1);
     src->reg.idx[0].offset = idx;
 }
 
 static void src_param_init_temp_float4(struct vkd3d_shader_src_param *src, unsigned int idx)
 {
-    vsir_src_param_init(src, VKD3DSPR_TEMP, VKD3D_DATA_FLOAT, 1);
+    vsir_src_param_init(src, VKD3DSPR_TEMP, VSIR_DATA_F32, 1);
     src->reg.dimension = VSIR_DIMENSION_VEC4;
     src->swizzle = VKD3D_SHADER_NO_SWIZZLE;
     src->reg.idx[0].offset = idx;
@@ -701,7 +701,7 @@ static void src_param_init_temp_uint(struct vkd3d_shader_src_param *src, unsigne
 }
 
 void vsir_dst_param_init(struct vkd3d_shader_dst_param *param, enum vkd3d_shader_register_type reg_type,
-        enum vkd3d_data_type data_type, unsigned int idx_count)
+        enum vsir_data_type data_type, unsigned int idx_count)
 {
     vsir_register_init(&param->reg, reg_type, data_type, idx_count);
     param->write_mask = VKD3DSP_WRITEMASK_0;
@@ -712,7 +712,7 @@ void vsir_dst_param_init(struct vkd3d_shader_dst_param *param, enum vkd3d_shader
 static void vsir_dst_param_init_io(struct vkd3d_shader_dst_param *dst, enum vkd3d_shader_register_type reg_type,
         const struct signature_element *e, unsigned int idx_count)
 {
-    vsir_dst_param_init(dst, reg_type, vkd3d_data_type_from_component_type(e->component_type), idx_count);
+    vsir_dst_param_init(dst, reg_type, vsir_data_type_from_component_type(e->component_type), idx_count);
     dst->reg.dimension = VSIR_DIMENSION_VEC4;
     dst->write_mask = e->mask;
 }
@@ -725,7 +725,7 @@ void vsir_dst_param_init_null(struct vkd3d_shader_dst_param *dst)
 }
 
 static void dst_param_init_ssa(struct vkd3d_shader_dst_param *dst, unsigned int idx,
-        enum vkd3d_data_type data_type, enum vsir_dimension dimension)
+        enum vsir_data_type data_type, enum vsir_dimension dimension)
 {
     vsir_dst_param_init(dst, VKD3DSPR_SSA, data_type, 1);
     dst->reg.idx[0].offset = idx;
@@ -737,8 +737,8 @@ static void dst_param_init_ssa(struct vkd3d_shader_dst_param *dst, unsigned int
     }
 }
 
-static void dst_param_init_ssa_scalar(struct vkd3d_shader_dst_param *dst, unsigned int idx,
-        enum vkd3d_data_type data_type)
+static void dst_param_init_ssa_scalar(struct vkd3d_shader_dst_param *dst,
+        unsigned int idx, enum vsir_data_type data_type)
 {
     dst_param_init_ssa(dst, idx, data_type, VSIR_DIMENSION_SCALAR);
 }
@@ -750,12 +750,12 @@ static void dst_param_init_ssa_bool(struct vkd3d_shader_dst_param *dst, unsigned
 
 static void dst_param_init_ssa_float(struct vkd3d_shader_dst_param *dst, unsigned int idx)
 {
-    dst_param_init_ssa_scalar(dst, idx, VKD3D_DATA_FLOAT);
+    dst_param_init_ssa_scalar(dst, idx, VSIR_DATA_F32);
 }
 
 static void dst_param_init_ssa_float4(struct vkd3d_shader_dst_param *dst, unsigned int idx)
 {
-    dst_param_init_ssa(dst, idx, VKD3D_DATA_FLOAT, VSIR_DIMENSION_VEC4);
+    dst_param_init_ssa(dst, idx, VSIR_DATA_F32, VSIR_DIMENSION_VEC4);
 }
 
 static void dst_param_init_temp_bool(struct vkd3d_shader_dst_param *dst, unsigned int idx)
@@ -766,7 +766,7 @@ static void dst_param_init_temp_bool(struct vkd3d_shader_dst_param *dst, unsigne
 
 static void dst_param_init_temp_float4(struct vkd3d_shader_dst_param *dst, unsigned int idx)
 {
-    vsir_dst_param_init(dst, VKD3DSPR_TEMP, VKD3D_DATA_FLOAT, 1);
+    vsir_dst_param_init(dst, VKD3DSPR_TEMP, VSIR_DATA_F32, 1);
     dst->reg.idx[0].offset = idx;
     dst->reg.dimension = VSIR_DIMENSION_VEC4;
 }
@@ -778,7 +778,7 @@ static void dst_param_init_temp_uint(struct vkd3d_shader_dst_param *dst, unsigne
 }
 
 static void dst_param_init_output(struct vkd3d_shader_dst_param *dst,
-        enum vkd3d_data_type data_type, uint32_t idx, uint32_t write_mask)
+        enum vsir_data_type data_type, uint32_t idx, uint32_t write_mask)
 {
     vsir_dst_param_init(dst, VKD3DSPR_OUTPUT, data_type, 1);
     dst->reg.idx[0].offset = idx;
@@ -850,15 +850,15 @@ static void vkd3d_shader_instruction_make_nop(struct vkd3d_shader_instruction *i
     vsir_instruction_init(ins, &location, VSIR_OP_NOP);
 }
 
-static bool get_opcode_from_rel_op(enum vkd3d_shader_rel_op rel_op, enum vkd3d_data_type data_type,
-        enum vkd3d_shader_opcode *opcode, bool *requires_swap)
+static bool get_opcode_from_rel_op(enum vkd3d_shader_rel_op rel_op,
+        enum vsir_data_type data_type, enum vkd3d_shader_opcode *opcode, bool *requires_swap)
 {
     switch (rel_op)
     {
         case VKD3D_SHADER_REL_OP_LT:
         case VKD3D_SHADER_REL_OP_GT:
             *requires_swap = (rel_op == VKD3D_SHADER_REL_OP_GT);
-            if (data_type == VKD3D_DATA_FLOAT)
+            if (data_type == VSIR_DATA_F32)
             {
                 *opcode = VSIR_OP_LTO;
                 return true;
@@ -868,7 +868,7 @@ static bool get_opcode_from_rel_op(enum vkd3d_shader_rel_op rel_op, enum vkd3d_d
         case VKD3D_SHADER_REL_OP_GE:
         case VKD3D_SHADER_REL_OP_LE:
             *requires_swap = (rel_op == VKD3D_SHADER_REL_OP_LE);
-            if (data_type == VKD3D_DATA_FLOAT)
+            if (data_type == VSIR_DATA_F32)
             {
                 *opcode = VSIR_OP_GEO;
                 return true;
@@ -877,7 +877,7 @@ static bool get_opcode_from_rel_op(enum vkd3d_shader_rel_op rel_op, enum vkd3d_d
 
         case VKD3D_SHADER_REL_OP_EQ:
             *requires_swap = false;
-            if (data_type == VKD3D_DATA_FLOAT)
+            if (data_type == VSIR_DATA_F32)
             {
                 *opcode = VSIR_OP_EQO;
                 return true;
@@ -886,7 +886,7 @@ static bool get_opcode_from_rel_op(enum vkd3d_shader_rel_op rel_op, enum vkd3d_d
 
         case VKD3D_SHADER_REL_OP_NE:
             *requires_swap = false;
-            if (data_type == VKD3D_DATA_FLOAT)
+            if (data_type == VSIR_DATA_F32)
             {
                 *opcode = VSIR_OP_NEO;
                 return true;
@@ -928,7 +928,7 @@ static enum vkd3d_result vsir_program_normalize_addr(struct vsir_program *progra
             ins2 = &program->instructions.elements[i + 1];
 
             ins->opcode = VSIR_OP_ROUND_NE;
-            vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_FLOAT, 1);
+            vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VSIR_DATA_F32, 1);
             ins->dst[0].reg.idx[0].offset = tmp_idx;
             ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
 
@@ -940,7 +940,7 @@ static enum vkd3d_result vsir_program_normalize_addr(struct vsir_program *progra
             ins2->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
             ins2->dst[0].write_mask = ins->dst[0].write_mask;
 
-            vsir_register_init(&ins2->src[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_FLOAT, 1);
+            vsir_register_init(&ins2->src[0].reg, VKD3DSPR_TEMP, VSIR_DATA_F32, 1);
             ins2->src[0].reg.idx[0].offset = tmp_idx;
             ins2->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
             ins2->src[0].swizzle = vsir_swizzle_from_writemask(ins2->dst[0].write_mask);
@@ -971,18 +971,16 @@ static enum vkd3d_result vsir_program_normalize_addr(struct vsir_program *progra
 }
 
 static enum vkd3d_result vsir_program_lower_ifc(struct vsir_program *program,
-        struct vkd3d_shader_instruction *ifc, unsigned int *tmp_idx,
+        struct vsir_program_iterator *it, unsigned int *tmp_idx,
         struct vkd3d_shader_message_context *message_context)
 {
-    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
-    size_t pos = ifc - instructions->elements;
-    struct vkd3d_shader_instruction *ins;
+    struct vkd3d_shader_instruction *ifc, *ins;
     enum vkd3d_shader_opcode opcode;
     bool swap;
 
-    if (!shader_instruction_array_insert_at(instructions, pos + 1, 2))
+    if (!vsir_program_iterator_insert_after(it, 2))
         return VKD3D_ERROR_OUT_OF_MEMORY;
-    ifc = &instructions->elements[pos];
+    ifc = vsir_program_iterator_current(it);
 
     if (*tmp_idx == ~0u)
         *tmp_idx = program->temp_count++;
@@ -996,7 +994,7 @@ static enum vkd3d_result vsir_program_lower_ifc(struct vsir_program *program,
         return VKD3D_ERROR_NOT_IMPLEMENTED;
     }
 
-    ins = &instructions->elements[pos + 1];
+    ins = vsir_program_iterator_next(it);
     if (!vsir_instruction_init_with_params(program, ins, &ifc->location, opcode, 1, 2))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1009,7 +1007,7 @@ static enum vkd3d_result vsir_program_lower_ifc(struct vsir_program *program,
     ins->src[1] = ifc->src[!swap];
 
     /* Create new if instruction using the previous result. */
-    ins = &instructions->elements[pos + 2];
+    ins = vsir_program_iterator_next(it);
     if (!vsir_instruction_init_with_params(program, ins, &ifc->location, VSIR_OP_IF, 0, 1))
         return VKD3D_ERROR_OUT_OF_MEMORY;
     ins->flags = VKD3D_SHADER_CONDITIONAL_OP_NZ;
@@ -1026,24 +1024,22 @@ static enum vkd3d_result vsir_program_lower_ifc(struct vsir_program *program,
 }
 
 static enum vkd3d_result vsir_program_lower_texkill(struct vsir_program *program,
-        struct vkd3d_shader_instruction *texkill, unsigned int *tmp_idx)
+        struct vsir_program_iterator *it, unsigned int *tmp_idx)
 {
     const unsigned int components_read = 3 + (program->shader_version.major >= 2);
-    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
-    size_t pos = texkill - instructions->elements;
-    struct vkd3d_shader_instruction *ins;
+    struct vkd3d_shader_instruction *ins, *texkill;
     unsigned int j;
 
-    if (!shader_instruction_array_insert_at(instructions, pos + 1, components_read + 1))
+    if (!vsir_program_iterator_insert_after(it, components_read + 1))
         return VKD3D_ERROR_OUT_OF_MEMORY;
-    texkill = &instructions->elements[pos];
+    texkill = vsir_program_iterator_current(it);
 
     if (*tmp_idx == ~0u)
         *tmp_idx = program->temp_count++;
 
     /* tmp = ins->src[0] < 0  */
 
-    ins = &instructions->elements[pos + 1];
+    ins = vsir_program_iterator_next(it);
     if (!vsir_instruction_init_with_params(program, ins, &texkill->location, VSIR_OP_LTO, 1, 2))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1054,7 +1050,7 @@ static enum vkd3d_result vsir_program_lower_texkill(struct vsir_program *program
 
     ins->src[0].reg = texkill->src[0].reg;
     ins->src[0].swizzle = VKD3D_SHADER_NO_SWIZZLE;
-    vsir_register_init(&ins->src[1].reg, VKD3DSPR_IMMCONST, VKD3D_DATA_FLOAT, 0);
+    vsir_register_init(&ins->src[1].reg, VKD3DSPR_IMMCONST, VSIR_DATA_F32, 0);
     ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
     ins->src[1].reg.u.immconst_f32[0] = 0.0f;
     ins->src[1].reg.u.immconst_f32[1] = 0.0f;
@@ -1067,7 +1063,7 @@ static enum vkd3d_result vsir_program_lower_texkill(struct vsir_program *program
 
     for (j = 1; j < components_read; ++j)
     {
-        ins = &instructions->elements[pos + 1 + j];
+        ins = vsir_program_iterator_next(it);
         if (!(vsir_instruction_init_with_params(program, ins, &texkill->location, VSIR_OP_OR, 1, 2)))
             return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1088,7 +1084,7 @@ static enum vkd3d_result vsir_program_lower_texkill(struct vsir_program *program
 
     /* discard_nz tmp.x */
 
-    ins = &instructions->elements[pos + 1 + components_read];
+    ins = vsir_program_iterator_next(it);
     if (!(vsir_instruction_init_with_params(program, ins, &texkill->location, VSIR_OP_DISCARD, 0, 1)))
         return VKD3D_ERROR_OUT_OF_MEMORY;
     ins->flags = VKD3D_SHADER_CONDITIONAL_OP_NZ;
@@ -1111,25 +1107,24 @@ static enum vkd3d_result vsir_program_lower_texkill(struct vsir_program *program
  * not fused for "precise" operations."
  * Windows drivers seem to conform with the latter, for SM 4-5 and SM 6. */
 static enum vkd3d_result vsir_program_lower_precise_mad(struct vsir_program *program,
-        struct vkd3d_shader_instruction *mad, unsigned int *tmp_idx)
+        struct vsir_program_iterator *it, unsigned int *tmp_idx)
 {
-    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
-    struct vkd3d_shader_instruction *mul_ins, *add_ins;
-    size_t pos = mad - instructions->elements;
+    struct vkd3d_shader_instruction *mad, *mul_ins, *add_ins;
     struct vkd3d_shader_dst_param *mul_dst;
 
+    mad = vsir_program_iterator_current(it);
+
     if (!(mad->flags & VKD3DSI_PRECISE_XYZW))
         return VKD3D_OK;
 
-    if (!shader_instruction_array_insert_at(instructions, pos + 1, 1))
+    if (!vsir_program_iterator_insert_after(it, 1))
         return VKD3D_ERROR_OUT_OF_MEMORY;
-    mad = &instructions->elements[pos];
 
     if (*tmp_idx == ~0u)
         *tmp_idx = program->temp_count++;
 
-    mul_ins = &instructions->elements[pos];
-    add_ins = &instructions->elements[pos + 1];
+    mul_ins = vsir_program_iterator_current(it);
+    add_ins = vsir_program_iterator_next(it);
 
     mul_ins->opcode = VSIR_OP_MUL;
     mul_ins->src_count = 2;
@@ -1174,13 +1169,13 @@ static enum vkd3d_result vsir_program_lower_imul(struct vsir_program *program,
 }
 
 static enum vkd3d_result vsir_program_lower_udiv(struct vsir_program *program,
-        struct vkd3d_shader_instruction *udiv, struct vsir_transformation_context *ctx)
+        struct vsir_program_iterator *it, struct vsir_transformation_context *ctx)
 {
-    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
-    size_t pos = udiv - instructions->elements;
-    struct vkd3d_shader_instruction *ins, *mov;
+    struct vkd3d_shader_instruction *udiv, *ins, *mov;
     unsigned int count = 2;
 
+    udiv = vsir_program_iterator_current(it);
+
     if (udiv->dst_count != 2)
     {
         vkd3d_shader_error(ctx->message_context, &udiv->location,
@@ -1195,21 +1190,19 @@ static enum vkd3d_result vsir_program_lower_udiv(struct vsir_program *program,
     if (udiv->dst[1].reg.type != VKD3DSPR_NULL)
         ++count;
 
-    if (!shader_instruction_array_insert_at(instructions, pos + 1, count))
+    if (!vsir_program_iterator_insert_after(it, count))
         return VKD3D_ERROR_OUT_OF_MEMORY;
-    udiv = &instructions->elements[pos];
-
-    ins = &instructions->elements[pos + 1];
+    udiv = vsir_program_iterator_current(it);
 
     /* Save the sources in a SSA in case a destination collides with a source. */
-    mov = ins++;
+    mov = vsir_program_iterator_next(it);
     if (!(vsir_instruction_init_with_params(program, mov, &udiv->location, VSIR_OP_MOV, 1, 1)))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
     mov->src[0] = udiv->src[0];
     dst_param_init_ssa(&mov->dst[0], program->ssa_count, udiv->src[0].reg.data_type, udiv->src[0].reg.dimension);
 
-    mov = ins++;
+    mov = vsir_program_iterator_next(it);
     if (!(vsir_instruction_init_with_params(program, mov, &udiv->location, VSIR_OP_MOV, 1, 1)))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1218,6 +1211,8 @@ static enum vkd3d_result vsir_program_lower_udiv(struct vsir_program *program,
 
     if (udiv->dst[0].reg.type != VKD3DSPR_NULL)
     {
+        ins = vsir_program_iterator_next(it);
+
         if (!(vsir_instruction_init_with_params(program, ins, &udiv->location, VSIR_OP_UDIV_SIMPLE, 1, 2)))
             return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1228,12 +1223,12 @@ static enum vkd3d_result vsir_program_lower_udiv(struct vsir_program *program,
         src_param_init_ssa(&ins->src[1], program->ssa_count + 1,
                 udiv->src[1].reg.data_type, udiv->src[1].reg.dimension);
         ins->dst[0] = udiv->dst[0];
-
-        ++ins;
     }
 
     if (udiv->dst[1].reg.type != VKD3DSPR_NULL)
     {
+        ins = vsir_program_iterator_next(it);
+
         if (!(vsir_instruction_init_with_params(program, ins, &udiv->location, VSIR_OP_UREM, 1, 2)))
             return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1244,8 +1239,6 @@ static enum vkd3d_result vsir_program_lower_udiv(struct vsir_program *program,
         src_param_init_ssa(&ins->src[1], program->ssa_count + 1,
                 udiv->src[1].reg.data_type, udiv->src[1].reg.dimension);
         ins->dst[0] = udiv->dst[1];
-
-        ++ins;
     }
 
     vkd3d_shader_instruction_make_nop(udiv);
@@ -1255,23 +1248,20 @@ static enum vkd3d_result vsir_program_lower_udiv(struct vsir_program *program,
 }
 
 static enum vkd3d_result vsir_program_lower_sm1_sincos(struct vsir_program *program,
-        struct vkd3d_shader_instruction *sincos)
+        struct vsir_program_iterator *it)
 {
-    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
-    size_t pos = sincos - instructions->elements;
-    struct vkd3d_shader_instruction *ins, *mov;
+    struct vkd3d_shader_instruction *ins, *mov, *sincos;
     unsigned int s, count;
 
+    sincos = vsir_program_iterator_current(it);
     count = 1 + vkd3d_popcount(sincos->dst[0].write_mask & (VKD3DSP_WRITEMASK_0 | VKD3DSP_WRITEMASK_1));
 
-    if (!shader_instruction_array_insert_at(instructions, pos + 1, count))
+    if (!vsir_program_iterator_insert_after(it, count))
         return VKD3D_ERROR_OUT_OF_MEMORY;
-    sincos = &instructions->elements[pos];
-
-    ins = &instructions->elements[pos + 1];
+    sincos = vsir_program_iterator_current(it);
 
     /* Save the source in a SSA in case a destination collides with the source. */
-    mov = ins++;
+    mov = vsir_program_iterator_next(it);
     if (!(vsir_instruction_init_with_params(program, mov, &sincos->location, VSIR_OP_MOV, 1, 1)))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1285,6 +1275,8 @@ static enum vkd3d_result vsir_program_lower_sm1_sincos(struct vsir_program *prog
 
     if (sincos->dst->write_mask & VKD3DSP_WRITEMASK_1)
     {
+        ins = vsir_program_iterator_next(it);
+
         if (!(vsir_instruction_init_with_params(program, ins, &sincos->location, VSIR_OP_SIN, 1, 1)))
             return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1294,12 +1286,12 @@ static enum vkd3d_result vsir_program_lower_sm1_sincos(struct vsir_program *prog
 
         ins->dst[0] = *sincos->dst;
         ins->dst[0].write_mask = VKD3DSP_WRITEMASK_1;
-
-        ++ins;
     }
 
     if (sincos->dst->write_mask & VKD3DSP_WRITEMASK_0)
     {
+        ins = vsir_program_iterator_next(it);
+
         if (!(vsir_instruction_init_with_params(program, ins, &sincos->location, VSIR_OP_COS, 1, 1)))
             return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1309,8 +1301,6 @@ static enum vkd3d_result vsir_program_lower_sm1_sincos(struct vsir_program *prog
 
         ins->dst[0] = *sincos->dst;
         ins->dst[0].write_mask = VKD3DSP_WRITEMASK_0;
-
-        ++ins;
     }
 
     vkd3d_shader_instruction_make_nop(sincos);
@@ -1320,13 +1310,13 @@ static enum vkd3d_result vsir_program_lower_sm1_sincos(struct vsir_program *prog
 }
 
 static enum vkd3d_result vsir_program_lower_sm4_sincos(struct vsir_program *program,
-        struct vkd3d_shader_instruction *sincos, struct vsir_transformation_context *ctx)
+        struct vsir_program_iterator *it, struct vsir_transformation_context *ctx)
 {
-    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
-    size_t pos = sincos - instructions->elements;
-    struct vkd3d_shader_instruction *ins, *mov;
+    struct vkd3d_shader_instruction *ins, *mov, *sincos;
     unsigned int count = 1;
 
+    sincos = vsir_program_iterator_current(it);
+
     if (sincos->dst_count != 2)
     {
         vkd3d_shader_error(ctx->message_context, &sincos->location,
@@ -1341,14 +1331,12 @@ static enum vkd3d_result vsir_program_lower_sm4_sincos(struct vsir_program *prog
     if (sincos->dst[1].reg.type != VKD3DSPR_NULL)
         ++count;
 
-    if (!shader_instruction_array_insert_at(instructions, pos + 1, count))
+    if (!vsir_program_iterator_insert_after(it, count))
         return VKD3D_ERROR_OUT_OF_MEMORY;
-    sincos = &instructions->elements[pos];
-
-    ins = &instructions->elements[pos + 1];
+    sincos = vsir_program_iterator_current(it);
 
     /* Save the source in a SSA in case a destination collides with the source. */
-    mov = ins++;
+    mov = vsir_program_iterator_next(it);
     if (!(vsir_instruction_init_with_params(program, mov, &sincos->location, VSIR_OP_MOV, 1, 1)))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1357,6 +1345,8 @@ static enum vkd3d_result vsir_program_lower_sm4_sincos(struct vsir_program *prog
 
     if (sincos->dst[0].reg.type != VKD3DSPR_NULL)
     {
+        ins = vsir_program_iterator_next(it);
+
         if (!(vsir_instruction_init_with_params(program, ins, &sincos->location, VSIR_OP_SIN, 1, 1)))
             return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1365,12 +1355,12 @@ static enum vkd3d_result vsir_program_lower_sm4_sincos(struct vsir_program *prog
         src_param_init_ssa(&ins->src[0], program->ssa_count,
                 sincos->src[0].reg.data_type, sincos->src[0].reg.dimension);
         ins->dst[0] = sincos->dst[0];
-
-        ++ins;
     }
 
     if (sincos->dst[1].reg.type != VKD3DSPR_NULL)
     {
+        ins = vsir_program_iterator_next(it);
+
         if (!(vsir_instruction_init_with_params(program, ins, &sincos->location, VSIR_OP_COS, 1, 1)))
             return VKD3D_ERROR_OUT_OF_MEMORY;
 
@@ -1379,8 +1369,6 @@ static enum vkd3d_result vsir_program_lower_sm4_sincos(struct vsir_program *prog
         src_param_init_ssa(&ins->src[0], program->ssa_count,
                 sincos->src[0].reg.data_type, sincos->src[0].reg.dimension);
         ins->dst[0] = sincos->dst[1];
-
-        ++ins;
     }
 
     vkd3d_shader_instruction_make_nop(sincos);
@@ -1390,30 +1378,33 @@ static enum vkd3d_result vsir_program_lower_sm4_sincos(struct vsir_program *prog
 }
 
 static enum vkd3d_result vsir_program_lower_texldp(struct vsir_program *program,
-        struct vkd3d_shader_instruction *tex, unsigned int *tmp_idx)
+        struct vsir_program_iterator *it, unsigned int *tmp_idx)
 {
-    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
-    struct vkd3d_shader_location *location = &tex->location;
-    struct vkd3d_shader_instruction *div_ins, *tex_ins;
-    size_t pos = tex - instructions->elements;
+    struct vkd3d_shader_instruction *div_ins, *tex, *tex_ins;
+    struct vsir_program_iterator it2;
     unsigned int w_comp;
 
+    tex = vsir_program_iterator_current(it);
+
     w_comp = vsir_swizzle_get_component(tex->src[0].swizzle, 3);
 
-    if (!shader_instruction_array_insert_at(instructions, pos + 1, 2))
+    if (!vsir_program_iterator_insert_after(it, 2))
         return VKD3D_ERROR_OUT_OF_MEMORY;
-    tex = &instructions->elements[pos];
+    tex = vsir_program_iterator_current(it);
 
     if (*tmp_idx == ~0u)
         *tmp_idx = program->temp_count++;
 
-    div_ins = &instructions->elements[pos + 1];
-    tex_ins = &instructions->elements[pos + 2];
+    /* Do not increment `it', because we need to scan the generated instructions
+     * again to lower TEXLD. */
+    it2 = *it;
+    div_ins = vsir_program_iterator_next(&it2);
+    tex_ins = vsir_program_iterator_next(&it2);
 
-    if (!vsir_instruction_init_with_params(program, div_ins, location, VSIR_OP_DIV, 1, 2))
+    if (!vsir_instruction_init_with_params(program, div_ins, &tex->location, VSIR_OP_DIV, 1, 2))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    vsir_dst_param_init(&div_ins->dst[0], VKD3DSPR_TEMP, VKD3D_DATA_FLOAT, 1);
+    vsir_dst_param_init(&div_ins->dst[0], VKD3DSPR_TEMP, VSIR_DATA_F32, 1);
     div_ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
     div_ins->dst[0].reg.idx[0].offset = *tmp_idx;
     div_ins->dst[0].write_mask = VKD3DSP_WRITEMASK_ALL;
@@ -1423,7 +1414,7 @@ static enum vkd3d_result vsir_program_lower_texldp(struct vsir_program *program,
     div_ins->src[1] = tex->src[0];
     div_ins->src[1].swizzle = vkd3d_shader_create_swizzle(w_comp, w_comp, w_comp, w_comp);
 
-    if (!vsir_instruction_init_with_params(program, tex_ins, location, VSIR_OP_TEXLD, 1, 2))
+    if (!vsir_instruction_init_with_params(program, tex_ins, &tex->location, VSIR_OP_TEXLD, 1, 2))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
     tex_ins->dst[0] = tex->dst[0];
@@ -1579,29 +1570,28 @@ static enum vkd3d_result vsir_program_lower_dcl_output(struct vsir_program *prog
 static enum vkd3d_result vsir_program_lower_instructions(struct vsir_program *program,
         struct vsir_transformation_context *ctx)
 {
-    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
+    struct vsir_program_iterator it = vsir_program_iterator(&program->instructions);
     struct vkd3d_shader_message_context *message_context = ctx->message_context;
-    unsigned int tmp_idx = ~0u, i;
+    struct vkd3d_shader_instruction *ins;
+    unsigned int tmp_idx = ~0u;
     enum vkd3d_result ret;
 
-    for (i = 0; i < instructions->count; ++i)
+    for (ins = vsir_program_iterator_head(&it); ins; ins = vsir_program_iterator_next(&it))
     {
-        struct vkd3d_shader_instruction *ins = &instructions->elements[i];
-
         switch (ins->opcode)
         {
             case VSIR_OP_IFC:
-                if ((ret = vsir_program_lower_ifc(program, ins, &tmp_idx, message_context)) < 0)
+                if ((ret = vsir_program_lower_ifc(program, &it, &tmp_idx, message_context)) < 0)
                     return ret;
                 break;
 
             case VSIR_OP_TEXKILL:
-                if ((ret = vsir_program_lower_texkill(program, ins, &tmp_idx)) < 0)
+                if ((ret = vsir_program_lower_texkill(program, &it, &tmp_idx)) < 0)
                     return ret;
                 break;
 
             case VSIR_OP_MAD:
-                if ((ret = vsir_program_lower_precise_mad(program, ins, &tmp_idx)) < 0)
+                if ((ret = vsir_program_lower_precise_mad(program, &it, &tmp_idx)) < 0)
                     return ret;
                 break;
 
@@ -1643,19 +1633,19 @@ static enum vkd3d_result vsir_program_lower_instructions(struct vsir_program *pr
                 break;
 
             case VSIR_OP_UDIV:
-                if ((ret = vsir_program_lower_udiv(program, ins, ctx)) < 0)
+                if ((ret = vsir_program_lower_udiv(program, &it, ctx)) < 0)
                     return ret;
                 break;
 
             case VSIR_OP_SINCOS:
                 if (ins->dst_count == 1)
                 {
-                    if ((ret = vsir_program_lower_sm1_sincos(program, ins)) < 0)
+                    if ((ret = vsir_program_lower_sm1_sincos(program, &it)) < 0)
                         return ret;
                 }
                 else
                 {
-                    if ((ret = vsir_program_lower_sm4_sincos(program, ins, ctx)) < 0)
+                    if ((ret = vsir_program_lower_sm4_sincos(program, &it, ctx)) < 0)
                         return ret;
                 }
                 break;
@@ -1663,7 +1653,7 @@ static enum vkd3d_result vsir_program_lower_instructions(struct vsir_program *pr
             case VSIR_OP_TEXLD:
                 if (ins->flags == VKD3DSI_TEXLD_PROJECT)
                 {
-                    if ((ret = vsir_program_lower_texldp(program, ins, &tmp_idx)) < 0)
+                    if ((ret = vsir_program_lower_texldp(program, &it, &tmp_idx)) < 0)
                         return ret;
                 }
                 else
@@ -1802,11 +1792,11 @@ static enum vkd3d_result vsir_program_ensure_diffuse(struct vsir_program *progra
     ins = &program->instructions.elements[i];
 
     vsir_instruction_init_with_params(program, ins, &no_loc, VSIR_OP_MOV, 1, 1);
-    vsir_dst_param_init(&ins->dst[0], VKD3DSPR_ATTROUT, VKD3D_DATA_FLOAT, 1);
+    vsir_dst_param_init(&ins->dst[0], VKD3DSPR_ATTROUT, VSIR_DATA_F32, 1);
     ins->dst[0].reg.idx[0].offset = 0;
     ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
     ins->dst[0].write_mask = VKD3DSP_WRITEMASK_ALL & ~program->diffuse_written_mask;
-    vsir_src_param_init(&ins->src[0], VKD3DSPR_IMMCONST, VKD3D_DATA_FLOAT, 0);
+    vsir_src_param_init(&ins->src[0], VKD3DSPR_IMMCONST, VSIR_DATA_F32, 0);
     ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
     for (i = 0; i < 4; ++i)
         ins->src[0].reg.u.immconst_f32[i] = 1.0f;
@@ -2026,8 +2016,8 @@ static enum vkd3d_result vsir_program_remap_output_signature(struct vsir_program
             e = &signature->elements[j];
 
             vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_MOV, 1, 1);
-            dst_param_init_output(&ins->dst[0], VKD3D_DATA_FLOAT, e->register_index, e->mask);
-            vsir_src_param_init(&ins->src[0], VKD3DSPR_IMMCONST, VKD3D_DATA_FLOAT, 0);
+            dst_param_init_output(&ins->dst[0], VSIR_DATA_F32, e->register_index, e->mask);
+            vsir_src_param_init(&ins->src[0], VKD3DSPR_IMMCONST, VSIR_DATA_F32, 0);
             ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
             ++ins;
         }
@@ -6842,7 +6832,7 @@ static enum vkd3d_result insert_alpha_test_before_ret(struct vsir_program *progr
             vsir_instruction_init_with_params(program, ins, &loc, opcodes[compare_func].float_opcode, 1, 2);
             src_param_init_temp_float(&ins->src[opcodes[compare_func].swap ? 1 : 0], colour_temp);
             src_param_init_parameter(&ins->src[opcodes[compare_func].swap ? 0 : 1],
-                    VKD3D_SHADER_PARAMETER_NAME_ALPHA_TEST_REF, VKD3D_DATA_FLOAT);
+                    VKD3D_SHADER_PARAMETER_NAME_ALPHA_TEST_REF, VSIR_DATA_F32);
             break;
 
         case VKD3D_SHADER_PARAMETER_DATA_TYPE_UINT32:
@@ -6875,7 +6865,7 @@ static enum vkd3d_result insert_alpha_test_before_ret(struct vsir_program *progr
 
     ++ins;
     vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_MOV, 1, 1);
-    vsir_dst_param_init(&ins->dst[0], VKD3DSPR_OUTPUT, VKD3D_DATA_FLOAT, 1);
+    vsir_dst_param_init(&ins->dst[0], VKD3DSPR_OUTPUT, VSIR_DATA_F32, 1);
     ins->dst[0].reg.idx[0].offset = colour_signature_idx;
     ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
     ins->dst[0].write_mask = program->output_signature.elements[colour_signature_idx].mask;
@@ -6992,11 +6982,11 @@ static enum vkd3d_result insert_clip_planes_before_ret(struct vsir_program *prog
 
         vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_DP4, 1, 2);
         src_param_init_temp_float4(&ins->src[0], position_temp);
-        src_param_init_parameter(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_CLIP_PLANE_0 + i, VKD3D_DATA_FLOAT);
+        src_param_init_parameter(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_CLIP_PLANE_0 + i, VSIR_DATA_F32);
         ins->src[1].swizzle = VKD3D_SHADER_NO_SWIZZLE;
         ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
 
-        vsir_dst_param_init(&ins->dst[0], VKD3DSPR_OUTPUT, VKD3D_DATA_FLOAT, 1);
+        vsir_dst_param_init(&ins->dst[0], VKD3DSPR_OUTPUT, VSIR_DATA_F32, 1);
         if (output_idx < 4)
             ins->dst[0].reg.idx[0].offset = low_signature_idx;
         else
@@ -7009,7 +6999,7 @@ static enum vkd3d_result insert_clip_planes_before_ret(struct vsir_program *prog
     }
 
     vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_MOV, 1, 1);
-    vsir_dst_param_init(&ins->dst[0], VKD3DSPR_OUTPUT, VKD3D_DATA_FLOAT, 1);
+    vsir_dst_param_init(&ins->dst[0], VKD3DSPR_OUTPUT, VSIR_DATA_F32, 1);
     ins->dst[0].reg.idx[0].offset = position_signature_idx;
     ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
     ins->dst[0].write_mask = program->output_signature.elements[position_signature_idx].mask;
@@ -7162,9 +7152,9 @@ static enum vkd3d_result insert_point_size_before_ret(struct vsir_program *progr
     ins = &program->instructions.elements[pos];
 
     vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_MOV, 1, 1);
-    vsir_dst_param_init(&ins->dst[0], VKD3DSPR_RASTOUT, VKD3D_DATA_FLOAT, 1);
+    vsir_dst_param_init(&ins->dst[0], VKD3DSPR_RASTOUT, VSIR_DATA_F32, 1);
     ins->dst[0].reg.idx[0].offset = VSIR_RASTOUT_POINT_SIZE;
-    src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_POINT_SIZE, VKD3D_DATA_FLOAT);
+    src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_POINT_SIZE, VSIR_DATA_F32);
 
     *ret_pos = pos + 1;
     return VKD3D_OK;
@@ -7298,7 +7288,7 @@ static enum vkd3d_result vsir_program_insert_point_size_clamp(struct vsir_progra
         {
             vsir_instruction_init_with_params(program, ins, loc, VSIR_OP_MAX, 1, 2);
             src_param_init_ssa_float(&ins->src[0], ssa_value);
-            src_param_init_parameter(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_POINT_SIZE_MIN, VKD3D_DATA_FLOAT);
+            src_param_init_parameter(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_POINT_SIZE_MIN, VSIR_DATA_F32);
             if (max_parameter)
             {
                 dst_param_init_ssa_float(&ins->dst[0], program->ssa_count);
@@ -7306,7 +7296,7 @@ static enum vkd3d_result vsir_program_insert_point_size_clamp(struct vsir_progra
             }
             else
             {
-                vsir_dst_param_init(&ins->dst[0], VKD3DSPR_RASTOUT, VKD3D_DATA_FLOAT, 1);
+                vsir_dst_param_init(&ins->dst[0], VKD3DSPR_RASTOUT, VSIR_DATA_F32, 1);
                 ins->dst[0].reg.idx[0].offset = VSIR_RASTOUT_POINT_SIZE;
             }
             ++ins;
@@ -7317,8 +7307,8 @@ static enum vkd3d_result vsir_program_insert_point_size_clamp(struct vsir_progra
         {
             vsir_instruction_init_with_params(program, ins, loc, VSIR_OP_MIN, 1, 2);
             src_param_init_ssa_float(&ins->src[0], ssa_value);
-            src_param_init_parameter(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_POINT_SIZE_MAX, VKD3D_DATA_FLOAT);
-            vsir_dst_param_init(&ins->dst[0], VKD3DSPR_RASTOUT, VKD3D_DATA_FLOAT, 1);
+            src_param_init_parameter(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_POINT_SIZE_MAX, VSIR_DATA_F32);
+            vsir_dst_param_init(&ins->dst[0], VKD3DSPR_RASTOUT, VSIR_DATA_F32, 1);
             ins->dst[0].reg.idx[0].offset = VSIR_RASTOUT_POINT_SIZE;
 
             ++i;
@@ -7495,7 +7485,7 @@ static enum vkd3d_result vsir_program_insert_point_coord(struct vsir_program *pr
         vsir_instruction_init_with_params(program, ins, &no_loc, VSIR_OP_MOV, 1, 1);
         dst_param_init_temp_float4(&ins->dst[0], coord_temp);
         ins->dst[0].write_mask = VKD3DSP_WRITEMASK_0 | VKD3DSP_WRITEMASK_1;
-        vsir_src_param_init(&ins->src[0], VKD3DSPR_POINT_COORD, VKD3D_DATA_FLOAT, 0);
+        vsir_src_param_init(&ins->src[0], VKD3DSPR_POINT_COORD, VSIR_DATA_F32, 0);
         ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
         ins->src[0].swizzle = VKD3D_SHADER_NO_SWIZZLE;
         ++ins;
@@ -7503,7 +7493,7 @@ static enum vkd3d_result vsir_program_insert_point_coord(struct vsir_program *pr
         vsir_instruction_init_with_params(program, ins, &no_loc, VSIR_OP_MOV, 1, 1);
         dst_param_init_temp_float4(&ins->dst[0], coord_temp);
         ins->dst[0].write_mask = VKD3DSP_WRITEMASK_2 | VKD3DSP_WRITEMASK_3;
-        vsir_src_param_init(&ins->src[0], VKD3DSPR_IMMCONST, VKD3D_DATA_FLOAT, 0);
+        vsir_src_param_init(&ins->src[0], VKD3DSPR_IMMCONST, VSIR_DATA_F32, 0);
         ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
         ++ins;
 
@@ -7573,8 +7563,8 @@ static enum vkd3d_result insert_fragment_fog_before_ret(struct vsir_program *pro
 
             vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_ADD, 1, 2);
             dst_param_init_ssa_float(&ins->dst[0], ssa_temp);
-            src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_FOG_END, VKD3D_DATA_FLOAT);
-            vsir_src_param_init(&ins->src[1], VKD3DSPR_INPUT, VKD3D_DATA_FLOAT, 1);
+            src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_FOG_END, VSIR_DATA_F32);
+            vsir_src_param_init(&ins->src[1], VKD3DSPR_INPUT, VSIR_DATA_F32, 1);
             ins->src[1].reg.idx[0].offset = fog_signature_idx;
             ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
             ins->src[1].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
@@ -7584,7 +7574,7 @@ static enum vkd3d_result insert_fragment_fog_before_ret(struct vsir_program *pro
             dst_param_init_ssa_float(&ins->dst[0], ssa_factor);
             ins->dst[0].modifiers = VKD3DSPDM_SATURATE;
             src_param_init_ssa_float(&ins->src[0], ssa_temp);
-            src_param_init_parameter(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, VKD3D_DATA_FLOAT);
+            src_param_init_parameter(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, VSIR_DATA_F32);
             break;
 
         case VKD3D_SHADER_FOG_FRAGMENT_EXP:
@@ -7605,8 +7595,8 @@ static enum vkd3d_result insert_fragment_fog_before_ret(struct vsir_program *pro
 
             vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_MUL, 1, 2);
             dst_param_init_ssa_float(&ins->dst[0], ssa_temp);
-            src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, VKD3D_DATA_FLOAT);
-            vsir_src_param_init(&ins->src[1], VKD3DSPR_INPUT, VKD3D_DATA_FLOAT, 1);
+            src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, VSIR_DATA_F32);
+            vsir_src_param_init(&ins->src[1], VKD3DSPR_INPUT, VSIR_DATA_F32, 1);
             ins->src[1].reg.idx[0].offset = fog_signature_idx;
             ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
             ins->src[1].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
@@ -7638,8 +7628,8 @@ static enum vkd3d_result insert_fragment_fog_before_ret(struct vsir_program *pro
 
             vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_MUL, 1, 2);
             dst_param_init_ssa_float(&ins->dst[0], ssa_temp);
-            src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, VKD3D_DATA_FLOAT);
-            vsir_src_param_init(&ins->src[1], VKD3DSPR_INPUT, VKD3D_DATA_FLOAT, 1);
+            src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, VSIR_DATA_F32);
+            vsir_src_param_init(&ins->src[1], VKD3DSPR_INPUT, VSIR_DATA_F32, 1);
             ins->src[1].reg.idx[0].offset = fog_signature_idx;
             ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
             ins->src[1].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
@@ -7669,15 +7659,15 @@ static enum vkd3d_result insert_fragment_fog_before_ret(struct vsir_program *pro
     vsir_instruction_init_with_params(program, ++ins, &loc, VSIR_OP_ADD, 1, 2);
     dst_param_init_ssa_float4(&ins->dst[0], program->ssa_count++);
     src_param_init_temp_float4(&ins->src[0], colour_temp);
-    src_param_init_parameter_vec4(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_FOG_COLOUR, VKD3D_DATA_FLOAT);
+    src_param_init_parameter_vec4(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_FOG_COLOUR, VSIR_DATA_F32);
     ins->src[1].modifiers = VKD3DSPSM_NEG;
 
     vsir_instruction_init_with_params(program, ++ins, &loc, VSIR_OP_MAD, 1, 3);
-    dst_param_init_output(&ins->dst[0], VKD3D_DATA_FLOAT, colour_signature_idx,
+    dst_param_init_output(&ins->dst[0], VSIR_DATA_F32, colour_signature_idx,
             program->output_signature.elements[colour_signature_idx].mask);
     src_param_init_ssa_float4(&ins->src[0], program->ssa_count - 1);
     src_param_init_ssa_float(&ins->src[1], ssa_factor);
-    src_param_init_parameter_vec4(&ins->src[2], VKD3D_SHADER_PARAMETER_NAME_FOG_COLOUR, VKD3D_DATA_FLOAT);
+    src_param_init_parameter_vec4(&ins->src[2], VKD3D_SHADER_PARAMETER_NAME_FOG_COLOUR, VSIR_DATA_F32);
 
     return VKD3D_OK;
 }
@@ -7819,7 +7809,7 @@ static enum vkd3d_result insert_vertex_fog_before_ret(struct vsir_program *progr
 
     /* Write the fog output. */
     vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_MOV, 1, 1);
-    dst_param_init_output(&ins->dst[0], VKD3D_DATA_FLOAT, fog_signature_idx, 0x1);
+    dst_param_init_output(&ins->dst[0], VSIR_DATA_F32, fog_signature_idx, 0x1);
     src_param_init_temp_float4(&ins->src[0], temp);
     if (source == VKD3D_SHADER_FOG_SOURCE_Z)
         ins->src[0].swizzle = VKD3D_SHADER_SWIZZLE(Z, Z, Z, Z);
@@ -7829,7 +7819,7 @@ static enum vkd3d_result insert_vertex_fog_before_ret(struct vsir_program *progr
 
     /* Write the position or specular output. */
     vsir_instruction_init_with_params(program, ins, &loc, VSIR_OP_MOV, 1, 1);
-    dst_param_init_output(&ins->dst[0], vkd3d_data_type_from_component_type(e->component_type),
+    dst_param_init_output(&ins->dst[0], vsir_data_type_from_component_type(e->component_type),
             source_signature_idx, e->mask);
     src_param_init_temp_float4(&ins->src[0], temp);
     ++ins;
@@ -8539,11 +8529,11 @@ static uint8_t get_available_writemask(const struct temp_allocator *allocator,
     return writemask;
 }
 
-static void temp_allocator_allocate(struct temp_allocator *allocator, struct liveness_tracker *tracker,
+static bool temp_allocator_allocate(struct temp_allocator *allocator, struct liveness_tracker *tracker,
         struct temp_allocator_reg *reg, const struct liveness_tracker_reg *liveness_reg, uint32_t base_id)
 {
     if (!liveness_reg->written)
-        return;
+        return false;
 
     for (uint32_t id = base_id;; ++id)
     {
@@ -8556,7 +8546,7 @@ static void temp_allocator_allocate(struct temp_allocator *allocator, struct liv
             {
                 reg->temp_id = id;
                 reg->allocated_mask = liveness_reg->mask;
-                return;
+                return true;
             }
         }
         else
@@ -8569,7 +8559,7 @@ static void temp_allocator_allocate(struct temp_allocator *allocator, struct liv
             {
                 reg->temp_id = id;
                 reg->allocated_mask = vsir_combine_write_masks(available_mask, liveness_reg->mask);
-                return;
+                return true;
             }
         }
     }
@@ -8591,6 +8581,7 @@ static void temp_allocator_set_src(struct temp_allocator *allocator, struct vkd3
         return;
 
     src->reg.type = VKD3DSPR_TEMP;
+    src->reg.dimension = VSIR_DIMENSION_VEC4;
     src->reg.idx[0].offset = reg->temp_id;
     src->swizzle = vsir_combine_swizzles(vsir_swizzle_from_writemask(reg->allocated_mask), src->swizzle);
 }
@@ -8678,6 +8669,7 @@ static void temp_allocator_set_dst(struct temp_allocator *allocator,
         return;
 
     dst->reg.type = VKD3DSPR_TEMP;
+    dst->reg.dimension = VSIR_DIMENSION_VEC4;
     dst->reg.idx[0].offset = reg->temp_id;
     if (reg->allocated_mask != dst->write_mask)
     {
@@ -8713,7 +8705,6 @@ enum vkd3d_result vsir_allocate_temp_registers(struct vsir_program *program,
     struct temp_allocator allocator = {0};
     struct temp_allocator_reg *regs;
     struct liveness_tracker tracker;
-    uint32_t temp_count = 0;
     enum vkd3d_result ret;
 
     if (!program->ssa_count)
@@ -8733,12 +8724,16 @@ enum vkd3d_result vsir_allocate_temp_registers(struct vsir_program *program,
     for (unsigned int i = 0; i < program->ssa_count; ++i)
     {
         const struct liveness_tracker_reg *liveness_reg = &tracker.ssa_regs[i];
+        const unsigned int prev_temp_count = program->temp_count;
         struct temp_allocator_reg *reg = &allocator.ssa_regs[i];
 
-        temp_allocator_allocate(&allocator, &tracker, reg, liveness_reg, program->temp_count);
-        TRACE("Allocated r%u%s to sr%u (liveness %u-%u).\n",
-                reg->temp_id, debug_vsir_writemask(reg->allocated_mask), i,
-                liveness_reg->first_write, liveness_reg->last_access);
+        if (temp_allocator_allocate(&allocator, &tracker, reg, liveness_reg, prev_temp_count))
+        {
+            TRACE("Allocated r%u%s to sr%u (liveness %u-%u).\n",
+                    reg->temp_id, debug_vsir_writemask(reg->allocated_mask), i,
+                    liveness_reg->first_write, liveness_reg->last_access);
+            program->temp_count = max(program->temp_count, reg->temp_id + 1);
+        }
         ++allocator.allocated_ssa_count;
     }
 
@@ -8754,13 +8749,25 @@ enum vkd3d_result vsir_allocate_temp_registers(struct vsir_program *program,
             temp_allocator_set_dst(&allocator, &ins->dst[j], ins);
     }
 
-    /* Rewrite dcl_temps to reflect the new temp count.
-     * Note that dcl_temps appears once per phase, and should reflect only the
-     * number of temps needed by that phase.
-     * Therefore we iterate backwards through the shader, finding the maximum
-     * register used by any instruction, update the dcl_temps at the beginning
-     * of each phase, and then reset the temp count back to 0 for the next
-     * phase (if any). */
+    program->ssa_count = 0;
+
+    vkd3d_free(regs);
+    liveness_tracker_cleanup(&tracker);
+    return allocator.result;
+}
+
+/* Rewrite dcl_temps to reflect the new temp count.
+ * Note that dcl_temps appears once per phase, and should reflect only the
+ * number of temps needed by that phase.
+ * Therefore we iterate backwards through the shader, finding the maximum
+ * register used by any instruction, update the dcl_temps at the beginning
+ * of each phase, and then reset the temp count back to 0 for the next
+ * phase (if any). */
+enum vkd3d_result vsir_update_dcl_temps(struct vsir_program *program,
+        struct vkd3d_shader_message_context *message_context)
+{
+    unsigned int temp_count = 0;
+
     for (int i = program->instructions.count - 1; i >= 0; --i)
     {
         struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
@@ -8771,6 +8778,7 @@ enum vkd3d_result vsir_allocate_temp_registers(struct vsir_program *program,
             temp_count = 0;
             continue;
         }
+
         if (temp_count && program->shader_version.major >= 4
                 && (ins->opcode == VSIR_OP_HS_CONTROL_POINT_PHASE
                         || ins->opcode == VSIR_OP_HS_FORK_PHASE
@@ -8779,11 +8787,7 @@ enum vkd3d_result vsir_allocate_temp_registers(struct vsir_program *program,
             /* The phase didn't have a dcl_temps instruction, but we added
              * temps here, so we need to insert one. */
             if (!shader_instruction_array_insert_at(&program->instructions, i + 1, 1))
-            {
-                vkd3d_free(regs);
-                liveness_tracker_cleanup(&tracker);
                 return VKD3D_ERROR_OUT_OF_MEMORY;
-            }
 
             ins = &program->instructions.elements[i + 1];
             vsir_instruction_init(ins, &program->instructions.elements[i].location, VSIR_OP_DCL_TEMPS);
@@ -8792,15 +8796,16 @@ enum vkd3d_result vsir_allocate_temp_registers(struct vsir_program *program,
             continue;
         }
 
-        /* No need to check sources. If we've produced an unwritten source then
-         * that's a bug somewhere in this pass. */
+        for (unsigned int j = 0; j < ins->src_count; ++j)
+        {
+            if (ins->src[j].reg.type == VKD3DSPR_TEMP)
+                temp_count = max(temp_count, ins->src[j].reg.idx[0].offset + 1);
+        }
+
         for (unsigned int j = 0; j < ins->dst_count; ++j)
         {
             if (ins->dst[j].reg.type == VKD3DSPR_TEMP)
-            {
                 temp_count = max(temp_count, ins->dst[j].reg.idx[0].offset + 1);
-                program->temp_count = max(program->temp_count, temp_count);
-            }
         }
     }
 
@@ -8809,22 +8814,14 @@ enum vkd3d_result vsir_allocate_temp_registers(struct vsir_program *program,
         struct vkd3d_shader_instruction *ins;
 
         if (!shader_instruction_array_insert_at(&program->instructions, 0, 1))
-        {
-            vkd3d_free(regs);
-            liveness_tracker_cleanup(&tracker);
             return VKD3D_ERROR_OUT_OF_MEMORY;
-        }
 
         ins = &program->instructions.elements[0];
         vsir_instruction_init(ins, &program->instructions.elements[1].location, VSIR_OP_DCL_TEMPS);
         ins->declaration.count = temp_count;
     }
 
-    program->ssa_count = 0;
-
-    vkd3d_free(regs);
-    liveness_tracker_cleanup(&tracker);
-    return allocator.result;
+    return VKD3D_OK;
 }
 
 struct validation_context
@@ -8848,7 +8845,7 @@ struct validation_context
     struct validation_context_ssa_data
     {
         enum vsir_dimension dimension;
-        enum vkd3d_data_type data_type;
+        enum vsir_data_type data_type;
         size_t first_seen;
         uint32_t write_mask;
         uint32_t read_mask;
@@ -9542,6 +9539,24 @@ static void vsir_validate_src_param(struct validation_context *ctx,
 static void vsir_validate_register(struct validation_context *ctx,
         const struct vkd3d_shader_register *reg)
 {
+    static const struct register_validation_data
+    {
+        bool valid;
+        unsigned int idx_count;
+        enum vsir_dimension dimension;
+    }
+    register_validation_data[] =
+    {
+        [VKD3DSPR_DEPTHOUT]         = {true, 0, VSIR_DIMENSION_SCALAR},
+        [VKD3DSPR_THREADGROUPID]    = {true, 0, VSIR_DIMENSION_VEC4},
+        [VKD3DSPR_LOCALTHREADID]    = {true, 0, VSIR_DIMENSION_VEC4},
+        [VKD3DSPR_LOCALTHREADINDEX] = {true, 0, VSIR_DIMENSION_VEC4},
+        [VKD3DSPR_COVERAGE]         = {true, 0, VSIR_DIMENSION_VEC4},
+        [VKD3DSPR_DEPTHOUTGE]       = {true, 0, VSIR_DIMENSION_SCALAR},
+        [VKD3DSPR_DEPTHOUTLE]       = {true, 0, VSIR_DIMENSION_SCALAR},
+    };
+
+    const struct register_validation_data *validation_data;
     unsigned int i;
 
     if (reg->type >= VKD3DSPR_COUNT)
@@ -9552,7 +9567,7 @@ static void vsir_validate_register(struct validation_context *ctx,
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_PRECISION, "Invalid register precision %#x.",
                 reg->precision);
 
-    if (reg->data_type >= VKD3D_DATA_COUNT)
+    if (reg->data_type >= VSIR_DATA_TYPE_COUNT)
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE, "Invalid register data type %#x.",
                 reg->data_type);
 
@@ -9607,10 +9622,6 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_io_register(ctx, reg);
             break;
 
-        case VKD3DSPR_DEPTHOUT:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
         case VKD3DSPR_MISCTYPE:
             vsir_validate_misctype_register(ctx, reg);
             break;
@@ -9683,22 +9694,6 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_register_without_indices(ctx, reg);
             break;
 
-        case VKD3DSPR_THREADGROUPID:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
-        case VKD3DSPR_LOCALTHREADID:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
-        case VKD3DSPR_LOCALTHREADINDEX:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
-        case VKD3DSPR_COVERAGE:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
         case VKD3DSPR_SAMPLEMASK:
             vsir_validate_register_without_indices(ctx, reg);
             break;
@@ -9707,14 +9702,6 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_register_without_indices(ctx, reg);
             break;
 
-        case VKD3DSPR_DEPTHOUTGE:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
-        case VKD3DSPR_DEPTHOUTLE:
-            vsir_validate_register_without_indices(ctx, reg);
-            break;
-
         case VKD3DSPR_OUTSTENCILREF:
             vsir_validate_register_without_indices(ctx, reg);
             break;
@@ -9734,6 +9721,24 @@ static void vsir_validate_register(struct validation_context *ctx,
         default:
             break;
     }
+
+    if (reg->type >= ARRAY_SIZE(register_validation_data))
+        return;
+
+    validation_data = &register_validation_data[reg->type];
+
+    if (!validation_data->valid)
+        return;
+
+    if (reg->idx_count != validation_data->idx_count)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT,
+                "Invalid index count %u for a register of type %#x, expected %u.",
+                reg->idx_count, reg->type, validation_data->idx_count);
+
+    if (reg->dimension != validation_data->dimension)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT,
+                "Invalid dimension %#x for a register of type %#x, expected %#x.",
+                reg->dimension, reg->type, validation_data->dimension);
 }
 
 static void vsir_validate_io_dst_param(struct validation_context *ctx,
@@ -9783,9 +9788,9 @@ static void vsir_validate_dst_param(struct validation_context *ctx,
     {
         switch (dst->reg.data_type)
         {
-            case VKD3D_DATA_FLOAT:
-            case VKD3D_DATA_DOUBLE:
-            case VKD3D_DATA_HALF:
+            case VSIR_DATA_F16:
+            case VSIR_DATA_F32:
+            case VSIR_DATA_F64:
                 break;
 
             default:
@@ -9807,7 +9812,7 @@ static void vsir_validate_dst_param(struct validation_context *ctx,
         case 13:
         case 14:
         case 15:
-            if (dst->reg.data_type != VKD3D_DATA_FLOAT)
+            if (dst->reg.data_type != VSIR_DATA_F32)
                 validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE,
                         "Invalid data type %#x for destination with shift.", dst->reg.data_type);
             break;
@@ -9891,9 +9896,9 @@ static void vsir_validate_io_src_param(struct validation_context *ctx,
                 "Invalid register type %#x used as source parameter.", src->reg.type);
 }
 
-#define F64_BIT (1u << VKD3D_DATA_DOUBLE)
-#define F32_BIT (1u << VKD3D_DATA_FLOAT)
-#define F16_BIT (1u << VKD3D_DATA_HALF)
+#define F64_BIT (1u << VSIR_DATA_F64)
+#define F32_BIT (1u << VSIR_DATA_F32)
+#define F16_BIT (1u << VSIR_DATA_F16)
 
 #define I32_BIT (1u << VKD3D_DATA_INT)
 
@@ -10494,7 +10499,7 @@ static void vsir_validate_descriptors(struct validation_context *ctx)
                     "Descriptor %u has invalid resource type %#x for descriptor type %#x.",
                     i, descriptor->resource_type, descriptor->type);
 
-        if (descriptor->resource_data_type >= VKD3D_DATA_COUNT)
+        if (descriptor->resource_data_type >= VSIR_DATA_TYPE_COUNT)
             validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE,
                     "Descriptor %u has invalid resource data type %#x.", i, descriptor->resource_data_type);
         else if ((descriptor->resource_data_type == VKD3D_DATA_UNUSED)
@@ -10597,9 +10602,9 @@ static void vsir_validate_hull_shader_phase(struct validation_context *ctx,
 }
 
 static void vsir_validate_elementwise_operation(struct validation_context *ctx,
-        const struct vkd3d_shader_instruction *instruction, const bool types[VKD3D_DATA_COUNT])
+        const struct vkd3d_shader_instruction *instruction, const bool types[VSIR_DATA_TYPE_COUNT])
 {
-    enum vkd3d_data_type dst_data_type;
+    enum vsir_data_type dst_data_type;
     unsigned int i;
 
     if (instruction->dst_count < 1)
@@ -10607,7 +10612,7 @@ static void vsir_validate_elementwise_operation(struct validation_context *ctx,
 
     dst_data_type = instruction->dst[0].reg.data_type;
 
-    if (dst_data_type >= VKD3D_DATA_COUNT)
+    if (dst_data_type >= VSIR_DATA_TYPE_COUNT)
         return;
 
     if (!types[dst_data_type])
@@ -10629,9 +10634,9 @@ static void vsir_validate_elementwise_operation(struct validation_context *ctx,
 static void vsir_validate_double_elementwise_operation(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
-    static const bool types[VKD3D_DATA_COUNT] =
+    static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_DOUBLE] = true,
+        [VSIR_DATA_F64] = true,
     };
 
     vsir_validate_elementwise_operation(ctx, instruction, types);
@@ -10640,9 +10645,9 @@ static void vsir_validate_double_elementwise_operation(struct validation_context
 static void vsir_validate_float_elementwise_operation(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
-    static const bool types[VKD3D_DATA_COUNT] =
+    static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_FLOAT] = true,
+        [VSIR_DATA_F32] = true,
     };
 
     vsir_validate_elementwise_operation(ctx, instruction, types);
@@ -10651,7 +10656,7 @@ static void vsir_validate_float_elementwise_operation(struct validation_context
 static void vsir_validate_integer_elementwise_operation(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
-    static const bool types[VKD3D_DATA_COUNT] =
+    static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
         [VKD3D_DATA_INT] = true,
         [VKD3D_DATA_UINT] = true,
@@ -10664,7 +10669,7 @@ static void vsir_validate_integer_elementwise_operation(struct validation_contex
 static void vsir_validate_logic_elementwise_operation(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
-    static const bool types[VKD3D_DATA_COUNT] =
+    static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
         [VKD3D_DATA_INT] = true,
         [VKD3D_DATA_UINT] = true,
@@ -10676,9 +10681,9 @@ static void vsir_validate_logic_elementwise_operation(struct validation_context
 }
 
 static void vsir_validate_comparison_operation(struct validation_context *ctx,
-        const struct vkd3d_shader_instruction *instruction, const bool types[VKD3D_DATA_COUNT])
+        const struct vkd3d_shader_instruction *instruction, const bool types[VSIR_DATA_TYPE_COUNT])
 {
-    enum vkd3d_data_type dst_data_type, src_data_type;
+    enum vsir_data_type dst_data_type, src_data_type;
     unsigned int i;
 
     if (instruction->dst_count < 1)
@@ -10696,7 +10701,7 @@ static void vsir_validate_comparison_operation(struct validation_context *ctx,
 
     src_data_type = instruction->src[0].reg.data_type;
 
-    if (src_data_type >= VKD3D_DATA_COUNT)
+    if (src_data_type >= VSIR_DATA_TYPE_COUNT)
         return;
 
     if (!types[src_data_type])
@@ -10718,9 +10723,9 @@ static void vsir_validate_comparison_operation(struct validation_context *ctx,
 static void vsir_validate_double_comparison_operation(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
-    static const bool types[VKD3D_DATA_COUNT] =
+    static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_DOUBLE] = true,
+        [VSIR_DATA_F64] = true,
     };
 
     vsir_validate_comparison_operation(ctx, instruction, types);
@@ -10729,9 +10734,10 @@ static void vsir_validate_double_comparison_operation(struct validation_context
 static void vsir_validate_float_comparison_operation(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
-    static const bool types[VKD3D_DATA_COUNT] =
+    static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
-        [VKD3D_DATA_FLOAT] = true,
+        [VSIR_DATA_F32] = true,
+        [VSIR_DATA_F64] = true,
     };
 
     vsir_validate_comparison_operation(ctx, instruction, types);
@@ -10740,7 +10746,7 @@ static void vsir_validate_float_comparison_operation(struct validation_context *
 static void vsir_validate_integer_comparison_operation(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
-    static const bool types[VKD3D_DATA_COUNT] =
+    static const bool types[VSIR_DATA_TYPE_COUNT] =
     {
         [VKD3D_DATA_INT] = true,
         [VKD3D_DATA_UINT] = true,
@@ -10750,6 +10756,32 @@ static void vsir_validate_integer_comparison_operation(struct validation_context
     vsir_validate_comparison_operation(ctx, instruction, types);
 }
 
+static void vsir_validate_cast_operation(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction,
+        const bool src_types[VSIR_DATA_TYPE_COUNT], const bool dst_types[VSIR_DATA_TYPE_COUNT])
+{
+    enum vsir_data_type dst_data_type, src_data_type;
+
+    if (instruction->dst_count < 1 || instruction->src_count < 1)
+        return;
+
+    dst_data_type = instruction->dst[0].reg.data_type;
+    src_data_type = instruction->src[0].reg.data_type;
+
+    if (src_data_type >= VSIR_DATA_TYPE_COUNT || dst_data_type >= VSIR_DATA_TYPE_COUNT)
+        return;
+
+    if (!src_types[src_data_type])
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE,
+                "Invalid source data type %#x for cast operation \"%s\" (%#x).",
+                src_data_type, vsir_opcode_get_name(instruction->opcode, "<unknown>"), instruction->opcode);
+
+    if (!dst_types[dst_data_type])
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE,
+                "Invalid destination data type %#x for cast operation \"%s\" (%#x).",
+                dst_data_type, vsir_opcode_get_name(instruction->opcode, "<unknown>"), instruction->opcode);
+}
+
 static void vsir_validate_branch(struct validation_context *ctx, const struct vkd3d_shader_instruction *instruction)
 {
     size_t i;
@@ -11263,6 +11295,39 @@ static void vsir_validate_endswitch(struct validation_context *ctx, const struct
         --ctx->depth;
 }
 
+static void vsir_validate_ftoi(struct validation_context *ctx, const struct vkd3d_shader_instruction *instruction)
+{
+    static const bool src_types[VSIR_DATA_TYPE_COUNT] =
+    {
+        [VSIR_DATA_F16] = true,
+        [VSIR_DATA_F32] = true,
+        [VSIR_DATA_F64] = true,
+    };
+    static const bool dst_types[VSIR_DATA_TYPE_COUNT] =
+    {
+        [VKD3D_DATA_INT] = true,
+        [VKD3D_DATA_UINT] = true,
+    };
+
+    vsir_validate_cast_operation(ctx, instruction, src_types, dst_types);
+}
+
+static void vsir_validate_ftou(struct validation_context *ctx, const struct vkd3d_shader_instruction *instruction)
+{
+    static const bool src_types[VSIR_DATA_TYPE_COUNT] =
+    {
+        [VSIR_DATA_F16] = true,
+        [VSIR_DATA_F32] = true,
+        [VSIR_DATA_F64] = true,
+    };
+    static const bool dst_types[VSIR_DATA_TYPE_COUNT] =
+    {
+        [VKD3D_DATA_UINT] = true,
+    };
+
+    vsir_validate_cast_operation(ctx, instruction, src_types, dst_types);
+}
+
 static void vsir_validate_if(struct validation_context *ctx, const struct vkd3d_shader_instruction *instruction)
 {
     vsir_validate_cf_type(ctx, instruction, VSIR_CF_STRUCTURED);
@@ -11275,6 +11340,38 @@ static void vsir_validate_ifc(struct validation_context *ctx, const struct vkd3d
     vsir_validator_push_block(ctx, VSIR_OP_IF);
 }
 
+static void vsir_validate_itof(struct validation_context *ctx, const struct vkd3d_shader_instruction *instruction)
+{
+    static const bool src_types[VSIR_DATA_TYPE_COUNT] =
+    {
+        [VKD3D_DATA_INT] = true,
+        [VKD3D_DATA_UINT] = true,
+        [VKD3D_DATA_UINT64] = true,
+        [VKD3D_DATA_BOOL] = true,
+    };
+    static const bool dst_types[VSIR_DATA_TYPE_COUNT] =
+    {
+        [VSIR_DATA_F16] = true,
+        [VSIR_DATA_F32] = true,
+        [VSIR_DATA_F64] = true,
+    };
+
+    vsir_validate_cast_operation(ctx, instruction, src_types, dst_types);
+}
+
+static void vsir_validate_itoi(struct validation_context *ctx, const struct vkd3d_shader_instruction *instruction)
+{
+    static const bool types[VSIR_DATA_TYPE_COUNT] =
+    {
+        [VKD3D_DATA_INT] = true,
+        [VKD3D_DATA_UINT] = true,
+        [VKD3D_DATA_UINT64] = true,
+        [VKD3D_DATA_BOOL] = true,
+    };
+
+    vsir_validate_cast_operation(ctx, instruction, types, types);
+}
+
 static void vsir_validate_label(struct validation_context *ctx, const struct vkd3d_shader_instruction *instruction)
 {
     vsir_validate_cf_type(ctx, instruction, VSIR_CF_BLOCKS);
@@ -11443,6 +11540,25 @@ static const struct vsir_validator_instruction_desc vsir_validator_instructions[
     [VSIR_OP_ATAN] =                             {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_BRANCH] =                           {0, ~0u, vsir_validate_branch},
     [VSIR_OP_DADD] =                             {1,   2, vsir_validate_double_elementwise_operation},
+    [VSIR_OP_DCL_GS_INSTANCES] =                 {0,   0, vsir_validate_dcl_gs_instances},
+    [VSIR_OP_DCL_HS_MAX_TESSFACTOR] =            {0,   0, vsir_validate_dcl_hs_max_tessfactor},
+    [VSIR_OP_DCL_INDEX_RANGE] =                  {0,   0, vsir_validate_dcl_index_range},
+    [VSIR_OP_DCL_INPUT] =                        {0,   0, vsir_validate_dcl_input},
+    [VSIR_OP_DCL_INPUT_PRIMITIVE] =              {0,   0, vsir_validate_dcl_input_primitive},
+    [VSIR_OP_DCL_INPUT_PS] =                     {0,   0, vsir_validate_dcl_input_ps},
+    [VSIR_OP_DCL_INPUT_PS_SGV] =                 {0,   0, vsir_validate_dcl_input_ps_sgv},
+    [VSIR_OP_DCL_INPUT_PS_SIV] =                 {0,   0, vsir_validate_dcl_input_ps_siv},
+    [VSIR_OP_DCL_INPUT_SGV] =                    {0,   0, vsir_validate_dcl_input_sgv},
+    [VSIR_OP_DCL_INPUT_SIV] =                    {0,   0, vsir_validate_dcl_input_siv},
+    [VSIR_OP_DCL_OUTPUT] =                       {0,   0, vsir_validate_dcl_output},
+    [VSIR_OP_DCL_OUTPUT_CONTROL_POINT_COUNT] =   {0,   0, vsir_validate_dcl_output_control_point_count},
+    [VSIR_OP_DCL_OUTPUT_SIV] =                   {0,   0, vsir_validate_dcl_output_siv},
+    [VSIR_OP_DCL_OUTPUT_TOPOLOGY] =              {0,   0, vsir_validate_dcl_output_topology},
+    [VSIR_OP_DCL_TEMPS] =                        {0,   0, vsir_validate_dcl_temps},
+    [VSIR_OP_DCL_TESSELLATOR_DOMAIN] =           {0,   0, vsir_validate_dcl_tessellator_domain},
+    [VSIR_OP_DCL_TESSELLATOR_OUTPUT_PRIMITIVE] = {0,   0, vsir_validate_dcl_tessellator_output_primitive},
+    [VSIR_OP_DCL_TESSELLATOR_PARTITIONING] =     {0,   0, vsir_validate_dcl_tessellator_partitioning},
+    [VSIR_OP_DCL_VERTICES_OUT] =                 {0,   0, vsir_validate_dcl_vertices_out},
     [VSIR_OP_DDIV] =                             {1,   2, vsir_validate_double_elementwise_operation},
     [VSIR_OP_DEQO] =                             {1,   2, vsir_validate_double_comparison_operation},
     [VSIR_OP_DFMA] =                             {1,   3, vsir_validate_double_elementwise_operation},
@@ -11461,22 +11577,31 @@ static const struct vsir_validator_instruction_desc vsir_validator_instructions[
     [VSIR_OP_DSY] =                              {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_DSY_COARSE] =                       {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_DSY_FINE] =                         {1,   1, vsir_validate_float_elementwise_operation},
+    [VSIR_OP_ELSE] =                             {0,   0, vsir_validate_else},
+    [VSIR_OP_ENDIF] =                            {0,   0, vsir_validate_endif},
+    [VSIR_OP_ENDLOOP] =                          {0,   0, vsir_validate_endloop},
+    [VSIR_OP_ENDREP] =                           {0,   0, vsir_validate_endrep},
+    [VSIR_OP_ENDSWITCH] =                        {0,   0, vsir_validate_endswitch},
     [VSIR_OP_EQO] =                              {1,   2, vsir_validate_float_comparison_operation},
     [VSIR_OP_EQU] =                              {1,   2, vsir_validate_float_comparison_operation},
     [VSIR_OP_EXP] =                              {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_FRC] =                              {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_FREM] =                             {1,   2, vsir_validate_float_elementwise_operation},
+    [VSIR_OP_FTOI] =                             {1,   1, vsir_validate_ftoi},
+    [VSIR_OP_FTOU] =                             {1,   1, vsir_validate_ftou},
     [VSIR_OP_GEO] =                              {1,   2, vsir_validate_float_comparison_operation},
     [VSIR_OP_GEU] =                              {1,   2, vsir_validate_float_comparison_operation},
     [VSIR_OP_HCOS] =                             {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_HSIN] =                             {1,   1, vsir_validate_float_elementwise_operation},
-    [VSIR_OP_HTAN] =                             {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_HS_CONTROL_POINT_PHASE] =           {0,   0, vsir_validate_hull_shader_phase},
     [VSIR_OP_HS_DECLS] =                         {0,   0, vsir_validate_hull_shader_phase},
     [VSIR_OP_HS_FORK_PHASE] =                    {0,   0, vsir_validate_hull_shader_phase},
     [VSIR_OP_HS_JOIN_PHASE] =                    {0,   0, vsir_validate_hull_shader_phase},
+    [VSIR_OP_HTAN] =                             {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_IADD] =                             {1,   2, vsir_validate_integer_elementwise_operation},
     [VSIR_OP_IEQ] =                              {1,   2, vsir_validate_integer_comparison_operation},
+    [VSIR_OP_IF] =                               {0,   1, vsir_validate_if},
+    [VSIR_OP_IFC] =                              {0,   2, vsir_validate_ifc},
     [VSIR_OP_IGE] =                              {1,   2, vsir_validate_integer_comparison_operation},
     [VSIR_OP_ILT] =                              {1,   2, vsir_validate_integer_comparison_operation},
     [VSIR_OP_IMAD] =                             {1,   3, vsir_validate_integer_elementwise_operation},
@@ -11485,36 +11610,22 @@ static const struct vsir_validator_instruction_desc vsir_validator_instructions[
     [VSIR_OP_INE] =                              {1,   2, vsir_validate_integer_comparison_operation},
     [VSIR_OP_INEG] =                             {1,   1, vsir_validate_integer_elementwise_operation},
     [VSIR_OP_IREM] =                             {1,   2, vsir_validate_integer_elementwise_operation},
+    [VSIR_OP_ISFINITE] =                         {1,   1, vsir_validate_float_comparison_operation},
     [VSIR_OP_ISHL] =                             {1,   2, vsir_validate_integer_elementwise_operation},
     [VSIR_OP_ISHR] =                             {1,   2, vsir_validate_integer_elementwise_operation},
-    [VSIR_OP_DCL_GS_INSTANCES] =                 {0,   0, vsir_validate_dcl_gs_instances},
-    [VSIR_OP_DCL_HS_MAX_TESSFACTOR] =            {0,   0, vsir_validate_dcl_hs_max_tessfactor},
-    [VSIR_OP_DCL_INDEX_RANGE] =                  {0,   0, vsir_validate_dcl_index_range},
-    [VSIR_OP_DCL_INPUT] =                        {0,   0, vsir_validate_dcl_input},
-    [VSIR_OP_DCL_INPUT_PRIMITIVE] =              {0,   0, vsir_validate_dcl_input_primitive},
-    [VSIR_OP_DCL_INPUT_PS] =                     {0,   0, vsir_validate_dcl_input_ps},
-    [VSIR_OP_DCL_INPUT_PS_SGV] =                 {0,   0, vsir_validate_dcl_input_ps_sgv},
-    [VSIR_OP_DCL_INPUT_PS_SIV] =                 {0,   0, vsir_validate_dcl_input_ps_siv},
-    [VSIR_OP_DCL_INPUT_SGV] =                    {0,   0, vsir_validate_dcl_input_sgv},
-    [VSIR_OP_DCL_INPUT_SIV] =                    {0,   0, vsir_validate_dcl_input_siv},
-    [VSIR_OP_DCL_OUTPUT] =                       {0,   0, vsir_validate_dcl_output},
-    [VSIR_OP_DCL_OUTPUT_CONTROL_POINT_COUNT] =   {0,   0, vsir_validate_dcl_output_control_point_count},
-    [VSIR_OP_DCL_OUTPUT_SIV] =                   {0,   0, vsir_validate_dcl_output_siv},
-    [VSIR_OP_DCL_OUTPUT_TOPOLOGY] =              {0,   0, vsir_validate_dcl_output_topology},
-    [VSIR_OP_DCL_TEMPS] =                        {0,   0, vsir_validate_dcl_temps},
-    [VSIR_OP_DCL_TESSELLATOR_DOMAIN] =           {0,   0, vsir_validate_dcl_tessellator_domain},
-    [VSIR_OP_DCL_TESSELLATOR_OUTPUT_PRIMITIVE] = {0,   0, vsir_validate_dcl_tessellator_output_primitive},
-    [VSIR_OP_DCL_TESSELLATOR_PARTITIONING] =     {0,   0, vsir_validate_dcl_tessellator_partitioning},
-    [VSIR_OP_DCL_VERTICES_OUT] =                 {0,   0, vsir_validate_dcl_vertices_out},
-    [VSIR_OP_ELSE] =                             {0,   0, vsir_validate_else},
-    [VSIR_OP_ENDIF] =                            {0,   0, vsir_validate_endif},
-    [VSIR_OP_ENDLOOP] =                          {0,   0, vsir_validate_endloop},
-    [VSIR_OP_ENDREP] =                           {0,   0, vsir_validate_endrep},
-    [VSIR_OP_ENDSWITCH] =                        {0,   0, vsir_validate_endswitch},
-    [VSIR_OP_IF] =                               {0,   1, vsir_validate_if},
-    [VSIR_OP_IFC] =                              {0,   2, vsir_validate_ifc},
+    [VSIR_OP_ISINF] =                            {1,   1, vsir_validate_float_comparison_operation},
+    [VSIR_OP_ISNAN] =                            {1,   1, vsir_validate_float_comparison_operation},
+    [VSIR_OP_ITOF] =                             {1,   1, vsir_validate_itof},
+    [VSIR_OP_ITOI] =                             {1,   1, vsir_validate_itoi},
     [VSIR_OP_LABEL] =                            {0,   1, vsir_validate_label},
+    [VSIR_OP_LOG] =                              {1,   1, vsir_validate_float_elementwise_operation},
     [VSIR_OP_LOOP] =                             {0, ~0u, vsir_validate_loop},
+    [VSIR_OP_LTO] =                              {1,   2, vsir_validate_float_comparison_operation},
+    [VSIR_OP_LTU] =                              {1,   2, vsir_validate_float_comparison_operation},
+    [VSIR_OP_MAD] =                              {1,   3, vsir_validate_float_elementwise_operation},
+    [VSIR_OP_MAX] =                              {1,   2, vsir_validate_float_elementwise_operation},
+    [VSIR_OP_MIN] =                              {1,   2, vsir_validate_float_elementwise_operation},
+    [VSIR_OP_MUL] =                              {1,   2, vsir_validate_float_elementwise_operation},
     [VSIR_OP_NOP] =                              {0,   0, vsir_validate_nop},
     [VSIR_OP_PHI] =                              {1, ~0u, vsir_validate_phi},
     [VSIR_OP_REP] =                              {0,   1, vsir_validate_rep},
diff --git a/libs/vkd3d/libs/vkd3d-shader/msl.c b/libs/vkd3d/libs/vkd3d-shader/msl.c
index 032b5504319..83cdf9feea0 100644
--- a/libs/vkd3d/libs/vkd3d-shader/msl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/msl.c
@@ -133,11 +133,11 @@ static void msl_print_indent(struct vkd3d_string_buffer *buffer, unsigned int in
 }
 
 static void msl_print_resource_datatype(struct msl_generator *gen,
-        struct vkd3d_string_buffer *buffer, enum vkd3d_data_type data_type)
+        struct vkd3d_string_buffer *buffer, enum vsir_data_type data_type)
 {
     switch (data_type)
     {
-        case VKD3D_DATA_FLOAT:
+        case VSIR_DATA_F32:
         case VKD3D_DATA_UNORM:
         case VKD3D_DATA_SNORM:
             vkd3d_string_buffer_printf(buffer, "float");
@@ -157,12 +157,12 @@ static void msl_print_resource_datatype(struct msl_generator *gen,
 }
 
 static void msl_print_register_datatype(struct vkd3d_string_buffer *buffer,
-        struct msl_generator *gen, enum vkd3d_data_type data_type)
+        struct msl_generator *gen, enum vsir_data_type data_type)
 {
     vkd3d_string_buffer_printf(buffer, ".");
     switch (data_type)
     {
-        case VKD3D_DATA_FLOAT:
+        case VSIR_DATA_F32:
             vkd3d_string_buffer_printf(buffer, "f");
             break;
         case VKD3D_DATA_INT:
@@ -345,7 +345,7 @@ static void msl_print_sampler_name(struct vkd3d_string_buffer *buffer, unsigned
 }
 
 static void msl_print_srv_name(struct vkd3d_string_buffer *buffer, struct msl_generator *gen, unsigned int binding,
-        const struct msl_resource_type_info *resource_type_info, enum vkd3d_data_type resource_data_type, bool compare)
+        const struct msl_resource_type_info *resource_type_info, enum vsir_data_type resource_data_type, bool compare)
 {
     vkd3d_string_buffer_printf(buffer, "descriptors[%u].as<%s%s%s<",
             binding, compare ? "depth" : "texture", resource_type_info->type_suffix,
@@ -355,7 +355,7 @@ static void msl_print_srv_name(struct vkd3d_string_buffer *buffer, struct msl_ge
 }
 
 static void msl_print_uav_name(struct vkd3d_string_buffer *buffer, struct msl_generator *gen, unsigned int binding,
-        const struct msl_resource_type_info *resource_type_info, enum vkd3d_data_type resource_data_type)
+        const struct msl_resource_type_info *resource_type_info, enum vsir_data_type resource_data_type)
 {
     vkd3d_string_buffer_printf(buffer, "descriptors[%u].as<texture%s%s<",
             binding, resource_type_info->type_suffix,
@@ -523,17 +523,17 @@ static void msl_src_cleanup(struct msl_src *src, struct vkd3d_string_buffer_cach
 }
 
 static void msl_print_bitcast(struct vkd3d_string_buffer *dst, struct msl_generator *gen, const char *src,
-        enum vkd3d_data_type dst_data_type, enum msl_data_type src_data_type, enum vsir_dimension dimension)
+        enum vsir_data_type dst_data_type, enum msl_data_type src_data_type, enum vsir_dimension dimension)
 {
     bool write_cast = false;
 
     if (dst_data_type == VKD3D_DATA_UNORM || dst_data_type == VKD3D_DATA_SNORM)
-        dst_data_type = VKD3D_DATA_FLOAT;
+        dst_data_type = VSIR_DATA_F32;
 
     switch (src_data_type)
     {
         case MSL_DATA_FLOAT:
-            write_cast = dst_data_type != VKD3D_DATA_FLOAT;
+            write_cast = dst_data_type != VSIR_DATA_F32;
             break;
 
         case MSL_DATA_UINT:
@@ -561,7 +561,7 @@ static void msl_print_bitcast(struct vkd3d_string_buffer *dst, struct msl_genera
 }
 
 static void msl_print_src_with_type(struct vkd3d_string_buffer *buffer, struct msl_generator *gen,
-    const struct vkd3d_shader_src_param *vsir_src, uint32_t mask, enum vkd3d_data_type data_type)
+    const struct vkd3d_shader_src_param *vsir_src, uint32_t mask, enum vsir_data_type data_type)
 {
     const struct vkd3d_shader_register *reg = &vsir_src->reg;
     struct vkd3d_string_buffer *register_name, *str;
@@ -947,7 +947,7 @@ static void msl_ld(struct msl_generator *gen, const struct vkd3d_shader_instruct
     const struct vkd3d_shader_descriptor_binding *binding;
     enum vkd3d_shader_resource_type resource_type;
     struct vkd3d_string_buffer *read;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     unsigned int srv_binding;
     uint32_t coord_mask;
     struct msl_dst dst;
@@ -975,7 +975,7 @@ static void msl_ld(struct msl_generator *gen, const struct vkd3d_shader_instruct
                 "Internal compiler error: Undeclared resource descriptor %u.", resource_id);
         resource_space = 0;
         resource_type = VKD3D_SHADER_RESOURCE_TEXTURE_2D;
-        data_type = VKD3D_DATA_FLOAT;
+        data_type = VSIR_DATA_F32;
     }
 
     if (resource_type == VKD3D_SHADER_RESOURCE_TEXTURE_CUBE
@@ -1047,7 +1047,7 @@ static void msl_sample(struct msl_generator *gen, const struct vkd3d_shader_inst
     enum vkd3d_shader_resource_type resource_type;
     unsigned int srv_binding, sampler_binding;
     struct vkd3d_string_buffer *sample;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     unsigned int component_idx;
     uint32_t coord_mask;
     struct msl_dst dst;
@@ -1086,7 +1086,7 @@ static void msl_sample(struct msl_generator *gen, const struct vkd3d_shader_inst
                 "Internal compiler error: Undeclared resource descriptor %u.", resource_id);
         resource_space = 0;
         resource_type = VKD3D_SHADER_RESOURCE_TEXTURE_2D;
-        data_type = VKD3D_DATA_FLOAT;
+        data_type = VSIR_DATA_F32;
     }
 
     if (resource_type == VKD3D_SHADER_RESOURCE_BUFFER
@@ -1257,7 +1257,7 @@ static void msl_store_uav_typed(struct msl_generator *gen, const struct vkd3d_sh
     enum vkd3d_shader_resource_type resource_type;
     unsigned int uav_id, uav_idx, uav_space;
     struct vkd3d_string_buffer *image_data;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     unsigned int uav_binding;
     uint32_t coord_mask;
 
@@ -1280,7 +1280,7 @@ static void msl_store_uav_typed(struct msl_generator *gen, const struct vkd3d_sh
                 "Internal compiler error: Undeclared UAV descriptor %u.", uav_id);
         uav_space = 0;
         resource_type = VKD3D_SHADER_RESOURCE_TEXTURE_2D;
-        data_type = VKD3D_DATA_FLOAT;
+        data_type = VSIR_DATA_F32;
     }
 
     if (!(resource_type_info = msl_get_resource_type_info(resource_type)))
@@ -1319,7 +1319,7 @@ static void msl_store_uav_typed(struct msl_generator *gen, const struct vkd3d_sh
                 msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
                         "Internal compiler error: Unhandled data type %#x.", data_type);
                 /* fall through */
-            case VKD3D_DATA_FLOAT:
+            case VSIR_DATA_F32:
             case VKD3D_DATA_UNORM:
             case VKD3D_DATA_SNORM:
                 vkd3d_string_buffer_printf(image_data, "float4(");
@@ -1882,13 +1882,13 @@ static void msl_generate_entrypoint_prologue(struct msl_generator *gen)
         switch (e->sysval_semantic)
         {
             case VKD3D_SHADER_SV_NONE:
-                msl_print_register_datatype(buffer, gen, vkd3d_data_type_from_component_type(e->component_type));
+                msl_print_register_datatype(buffer, gen, vsir_data_type_from_component_type(e->component_type));
                 msl_print_write_mask(buffer, e->mask);
                 vkd3d_string_buffer_printf(buffer, " = input.shader_in_%u", i);
                 break;
 
             case VKD3D_SHADER_SV_POSITION:
-                msl_print_register_datatype(buffer, gen, VKD3D_DATA_FLOAT);
+                msl_print_register_datatype(buffer, gen, VSIR_DATA_F32);
                 msl_print_write_mask(buffer, e->mask);
                 vkd3d_string_buffer_printf(buffer, " = float4(input.position.xyz, 1.0f / input.position.w)");
                 break;
@@ -1944,7 +1944,7 @@ static void msl_generate_entrypoint_epilogue(struct msl_generator *gen)
                 vkd3d_string_buffer_printf(buffer, "    output.shader_out_%u", i);
                 msl_print_write_mask(buffer, e->mask);
                 vkd3d_string_buffer_printf(buffer, " = %s_out[%u]", gen->prefix, e->register_index);
-                msl_print_register_datatype(buffer, gen, vkd3d_data_type_from_component_type(e->component_type));
+                msl_print_register_datatype(buffer, gen, vsir_data_type_from_component_type(e->component_type));
                 msl_print_write_mask(buffer, e->mask);
                 break;
             case VKD3D_SHADER_SV_DEPTH:
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index c51a6a394c0..eb9a90e8b44 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -2568,7 +2568,7 @@ static uint32_t vkd3d_spirv_get_type_id(struct vkd3d_spirv_builder *builder,
 }
 
 static uint32_t vkd3d_spirv_get_type_id_for_data_type(struct vkd3d_spirv_builder *builder,
-        enum vkd3d_data_type data_type, unsigned int component_count)
+        enum vsir_data_type data_type, unsigned int component_count)
 {
     enum vkd3d_shader_component_type component_type;
 
@@ -3012,7 +3012,7 @@ struct vkd3d_hull_shader_variables
 
 struct ssa_register_info
 {
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     uint8_t write_mask;
     uint32_t id;
 };
@@ -3985,7 +3985,7 @@ static uint32_t spirv_compiler_alloc_spec_constant_id(struct spirv_compiler *com
 
 static uint32_t spirv_compiler_emit_spec_constant(struct spirv_compiler *compiler,
         enum vkd3d_shader_parameter_name name, uint32_t spec_id,
-        enum vkd3d_data_type type, unsigned int component_count)
+        enum vsir_data_type type, unsigned int component_count)
 {
     uint32_t scalar_type_id, vector_type_id, id, default_value, components[4];
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
@@ -4024,7 +4024,7 @@ static uint32_t spirv_compiler_emit_spec_constant(struct spirv_compiler *compile
 
 static uint32_t spirv_compiler_get_spec_constant(struct spirv_compiler *compiler,
         enum vkd3d_shader_parameter_name name, uint32_t spec_id,
-        enum vkd3d_data_type type, unsigned int component_count)
+        enum vsir_data_type type, unsigned int component_count)
 {
     unsigned int i;
 
@@ -4038,7 +4038,7 @@ static uint32_t spirv_compiler_get_spec_constant(struct spirv_compiler *compiler
 }
 
 static uint32_t spirv_compiler_get_buffer_parameter(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_parameter1 *parameter, enum vkd3d_data_type type, unsigned int component_count)
+        const struct vkd3d_shader_parameter1 *parameter, enum vsir_data_type type, unsigned int component_count)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     unsigned int index = parameter - compiler->program->parameters;
@@ -4054,18 +4054,18 @@ static uint32_t spirv_compiler_get_buffer_parameter(struct spirv_compiler *compi
 
 static const struct
 {
-    enum vkd3d_data_type type;
+    enum vsir_data_type type;
     unsigned int component_count;
 }
 parameter_data_type_map[] =
 {
-    [VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32]      = {VKD3D_DATA_FLOAT, 1},
+    [VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32]      = {VSIR_DATA_F32, 1},
     [VKD3D_SHADER_PARAMETER_DATA_TYPE_UINT32]       = {VKD3D_DATA_UINT,  1},
-    [VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32_VEC4] = {VKD3D_DATA_FLOAT, 4},
+    [VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32_VEC4] = {VSIR_DATA_F32, 4},
 };
 
 static uint32_t spirv_compiler_emit_shader_parameter(struct spirv_compiler *compiler,
-        enum vkd3d_shader_parameter_name name, enum vkd3d_data_type type, unsigned int component_count)
+        enum vkd3d_shader_parameter_name name, enum vsir_data_type type, unsigned int component_count)
 {
     const struct vkd3d_shader_parameter1 *parameter;
 
@@ -4479,7 +4479,7 @@ static uint32_t spirv_compiler_emit_vector_shuffle(struct spirv_compiler *compil
 }
 
 static uint32_t spirv_compiler_emit_int_to_bool(struct spirv_compiler *compiler,
-        enum vkd3d_shader_conditional_op condition, enum vkd3d_data_type data_type,
+        enum vkd3d_shader_conditional_op condition, enum vsir_data_type data_type,
         unsigned int component_count, uint32_t val_id)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
@@ -4708,14 +4708,14 @@ static uint32_t spirv_compiler_emit_constant_array(struct spirv_compiler *compil
 
     switch (icb->data_type)
     {
-        case VKD3D_DATA_FLOAT:
+        case VSIR_DATA_F32:
         case VKD3D_DATA_INT:
         case VKD3D_DATA_UINT:
             for (i = 0; i < element_count; ++i)
                 elements[i] = spirv_compiler_get_constant(compiler, component_type, component_count,
                         &icb->data[component_count * i]);
             break;
-        case VKD3D_DATA_DOUBLE:
+        case VSIR_DATA_F64:
         case VKD3D_DATA_UINT64:
         {
             uint64_t *data = (uint64_t *)icb->data;
@@ -4903,7 +4903,7 @@ static uint32_t spirv_compiler_emit_load_src_with_type(struct spirv_compiler *co
 {
     struct vkd3d_shader_src_param src_param = *src;
 
-    src_param.reg.data_type = vkd3d_data_type_from_component_type(component_type);
+    src_param.reg.data_type = vsir_data_type_from_component_type(component_type);
     return spirv_compiler_emit_load_src(compiler, &src_param, write_mask);
 }
 
@@ -5029,7 +5029,7 @@ static uint32_t spirv_compiler_emit_sat(struct spirv_compiler *compiler,
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id, zero_id, one_id;
 
-    if (reg->data_type == VKD3D_DATA_DOUBLE)
+    if (reg->data_type == VSIR_DATA_F64)
     {
         zero_id = spirv_compiler_get_constant_double_vector(compiler, 0.0, component_count);
         one_id = spirv_compiler_get_constant_double_vector(compiler, 1.0, component_count);
@@ -5083,7 +5083,7 @@ static void spirv_compiler_emit_store_dst_swizzled(struct spirv_compiler *compil
     /* XXX: The register data type could be fixed by the shader parser. For SM5
      * shaders the data types are stored in instructions modifiers.
      */
-    typed_dst.reg.data_type = vkd3d_data_type_from_component_type(component_type);
+    typed_dst.reg.data_type = vsir_data_type_from_component_type(component_type);
     spirv_compiler_emit_store_dst(compiler, &typed_dst, val_id);
 }
 
@@ -5511,7 +5511,7 @@ static uint32_t spirv_compiler_get_invocation_id(struct spirv_compiler *compiler
 
     VKD3D_ASSERT(compiler->shader_type == VKD3D_SHADER_TYPE_HULL);
 
-    vsir_register_init(&r, VKD3DSPR_OUTPOINTID, VKD3D_DATA_FLOAT, 0);
+    vsir_register_init(&r, VKD3DSPR_OUTPOINTID, VSIR_DATA_F32, 0);
     return spirv_compiler_get_register_id(compiler, &r);
 }
 
@@ -5800,7 +5800,7 @@ static void spirv_compiler_emit_input(struct spirv_compiler *compiler,
     {
         struct vkd3d_shader_register dst_reg;
 
-        vsir_register_init(&dst_reg, reg_type, VKD3D_DATA_FLOAT, 1);
+        vsir_register_init(&dst_reg, reg_type, VSIR_DATA_F32, 1);
         dst_reg.idx[0].offset = element_idx;
 
         type_id = vkd3d_spirv_get_type_id(builder, component_type, input_component_count);
@@ -6502,7 +6502,7 @@ static void spirv_compiler_emit_dcl_indexable_temp(struct spirv_compiler *compil
      * scope is specified, e.g. DXIL alloca. */
     storage_class = temp->has_function_scope ? SpvStorageClassFunction : SpvStorageClassPrivate;
 
-    vsir_register_init(&reg, VKD3DSPR_IDXTEMP, VKD3D_DATA_FLOAT, 1);
+    vsir_register_init(&reg, VKD3DSPR_IDXTEMP, VSIR_DATA_F32, 1);
     reg.idx[0].offset = temp->register_idx;
 
     /* Alignment is supported only in the Kernel execution model and is an optimisation only. */
@@ -6742,7 +6742,7 @@ static void spirv_compiler_emit_cbv_declaration(struct spirv_compiler *compiler,
     struct vkd3d_symbol reg_symbol;
     unsigned int size;
 
-    vsir_register_init(&reg, VKD3DSPR_CONSTBUFFER, VKD3D_DATA_FLOAT, 3);
+    vsir_register_init(&reg, VKD3DSPR_CONSTBUFFER, VSIR_DATA_F32, 3);
     reg.idx[0].offset = descriptor->register_id;
     reg.idx[1].offset = range->first;
     reg.idx[2].offset = range->last;
@@ -6802,7 +6802,7 @@ static void spirv_compiler_emit_dcl_immediate_constant_buffer(struct spirv_compi
     vkd3d_spirv_build_op_name(builder, icb_id, "icb");
 
     /* Set an index count of 2 so vkd3d_symbol_make_register() uses idx[0] as a buffer id. */
-    vsir_register_init(&reg, VKD3DSPR_IMMCONSTBUFFER, VKD3D_DATA_FLOAT, 2);
+    vsir_register_init(&reg, VKD3DSPR_IMMCONSTBUFFER, VSIR_DATA_F32, 2);
     reg.idx[0].offset = icb->register_idx;
     vkd3d_symbol_make_register(&reg_symbol, &reg);
     vkd3d_symbol_set_register_info(&reg_symbol, icb_id, SpvStorageClassPrivate,
@@ -6821,7 +6821,7 @@ static void spirv_compiler_emit_sampler_declaration(struct spirv_compiler *compi
     struct vkd3d_symbol reg_symbol;
     uint32_t type_id, var_id;
 
-    vsir_register_init(&reg, VKD3DSPR_SAMPLER, VKD3D_DATA_FLOAT, 1);
+    vsir_register_init(&reg, VKD3DSPR_SAMPLER, VSIR_DATA_F32, 1);
     reg.idx[0].offset = descriptor->register_id;
 
     vkd3d_symbol_make_sampler(&reg_symbol, &reg);
@@ -7002,7 +7002,7 @@ static void spirv_compiler_emit_resource_declaration(struct spirv_compiler *comp
     struct vkd3d_symbol resource_symbol;
     struct vkd3d_shader_register reg;
 
-    vsir_register_init(&reg, is_uav ? VKD3DSPR_UAV : VKD3DSPR_RESOURCE, VKD3D_DATA_FLOAT, 1);
+    vsir_register_init(&reg, is_uav ? VKD3DSPR_UAV : VKD3DSPR_RESOURCE, VSIR_DATA_F32, 1);
     reg.idx[0].offset = descriptor->register_id;
 
     if (resource_type == VKD3D_SHADER_RESOURCE_TEXTURE_2DMS && sample_count == 1)
@@ -7592,11 +7592,11 @@ static void spirv_compiler_emit_bool_cast(struct spirv_compiler *compiler,
     VKD3D_ASSERT(src->reg.data_type == VKD3D_DATA_BOOL && dst->reg.data_type != VKD3D_DATA_BOOL);
 
     val_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
-    if (dst->reg.data_type == VKD3D_DATA_HALF || dst->reg.data_type == VKD3D_DATA_FLOAT)
+    if (dst->reg.data_type == VSIR_DATA_F16 || dst->reg.data_type == VSIR_DATA_F32)
     {
         val_id = spirv_compiler_emit_bool_to_float(compiler, 1, val_id, instruction->opcode == VSIR_OP_ITOF);
     }
-    else if (dst->reg.data_type == VKD3D_DATA_DOUBLE)
+    else if (dst->reg.data_type == VSIR_DATA_F64)
     {
         /* ITOD is not supported. Frontends which emit bool casts must use ITOF for double. */
         val_id = spirv_compiler_emit_bool_to_double(compiler, 1, val_id, instruction->opcode == VSIR_OP_ITOF);
@@ -8051,7 +8051,7 @@ static void spirv_compiler_emit_rcp(struct spirv_compiler *compiler,
     type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
 
     src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
-    if (src->reg.data_type == VKD3D_DATA_DOUBLE)
+    if (src->reg.data_type == VSIR_DATA_F64)
         div_id = spirv_compiler_get_constant_double_vector(compiler, 1.0, component_count);
     else
         div_id = spirv_compiler_get_constant_float_vector(compiler, 1.0f, component_count);
@@ -8101,7 +8101,7 @@ static void spirv_compiler_emit_ftoi(struct spirv_compiler *compiler,
 
     component_count = vsir_write_mask_component_count(dst->write_mask);
 
-    if (src->reg.data_type == VKD3D_DATA_DOUBLE)
+    if (src->reg.data_type == VSIR_DATA_F64)
     {
         write_mask = vkd3d_write_mask_from_component_count(component_count);
         int_min_id = spirv_compiler_get_constant_double_vector(compiler, -2147483648.0, component_count);
@@ -8157,7 +8157,7 @@ static void spirv_compiler_emit_ftou(struct spirv_compiler *compiler,
 
     component_count = vsir_write_mask_component_count(dst->write_mask);
 
-    if (src->reg.data_type == VKD3D_DATA_DOUBLE)
+    if (src->reg.data_type == VSIR_DATA_F64)
     {
         write_mask = vkd3d_write_mask_from_component_count(component_count);
         zero_id = spirv_compiler_get_constant_double_vector(compiler, 0.0, component_count);
@@ -10952,14 +10952,14 @@ static void spirv_compiler_emit_io_declarations(struct spirv_compiler *compiler)
 
     if (compiler->program->has_point_size)
     {
-        vsir_dst_param_init(&dst, VKD3DSPR_RASTOUT, VKD3D_DATA_FLOAT, 1);
+        vsir_dst_param_init(&dst, VKD3DSPR_RASTOUT, VSIR_DATA_F32, 1);
         dst.reg.idx[0].offset = VSIR_RASTOUT_POINT_SIZE;
         spirv_compiler_emit_io_register(compiler, &dst);
     }
 
     if (compiler->program->has_point_coord)
     {
-        vsir_dst_param_init(&dst, VKD3DSPR_POINT_COORD, VKD3D_DATA_FLOAT, 0);
+        vsir_dst_param_init(&dst, VKD3DSPR_POINT_COORD, VSIR_DATA_F32, 0);
         spirv_compiler_emit_io_register(compiler, &dst);
     }
 
@@ -10970,7 +10970,7 @@ static void spirv_compiler_emit_io_declarations(struct spirv_compiler *compiler)
         if (bitmap_is_set(compiler->program->io_dcls, i)
                 || (compiler->program->shader_version.type == VKD3D_SHADER_TYPE_HULL && i == VKD3DSPR_OUTPOINTID))
         {
-            vsir_dst_param_init(&dst, i, VKD3D_DATA_FLOAT, 0);
+            vsir_dst_param_init(&dst, i, VSIR_DATA_F32, 0);
             spirv_compiler_emit_io_register(compiler, &dst);
         }
     }
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index c7eafbc79f3..26c41a902d2 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -748,16 +748,16 @@ static const enum vkd3d_shader_resource_type resource_type_table[] =
     /* VKD3D_SM4_RESOURCE_STRUCTURED_BUFFER */    VKD3D_SHADER_RESOURCE_BUFFER,
 };
 
-static const enum vkd3d_data_type data_type_table[] =
+static const enum vsir_data_type data_type_table[] =
 {
-    /* 0 */                         VKD3D_DATA_FLOAT,
+    /* 0 */                         VSIR_DATA_F32,
     /* VKD3D_SM4_DATA_UNORM */      VKD3D_DATA_UNORM,
     /* VKD3D_SM4_DATA_SNORM */      VKD3D_DATA_SNORM,
     /* VKD3D_SM4_DATA_INT */        VKD3D_DATA_INT,
     /* VKD3D_SM4_DATA_UINT */       VKD3D_DATA_UINT,
-    /* VKD3D_SM4_DATA_FLOAT */      VKD3D_DATA_FLOAT,
+    /* VKD3D_SM4_DATA_FLOAT */      VSIR_DATA_F32,
     /* VKD3D_SM4_DATA_MIXED */      VKD3D_DATA_MIXED,
-    /* VKD3D_SM4_DATA_DOUBLE */     VKD3D_DATA_DOUBLE,
+    /* VKD3D_SM4_DATA_DOUBLE */     VSIR_DATA_F64,
     /* VKD3D_SM4_DATA_CONTINUED */  VKD3D_DATA_CONTINUED,
     /* VKD3D_SM4_DATA_UNUSED */     VKD3D_DATA_UNUSED,
 };
@@ -770,9 +770,9 @@ static bool shader_is_sm_5_1(const struct vkd3d_shader_sm4_parser *sm4)
 }
 
 static bool shader_sm4_read_src_param(struct vkd3d_shader_sm4_parser *priv, const uint32_t **ptr,
-        const uint32_t *end, enum vkd3d_data_type data_type, struct vkd3d_shader_src_param *src_param);
+        const uint32_t *end, enum vsir_data_type data_type, struct vkd3d_shader_src_param *src_param);
 static bool shader_sm4_read_dst_param(struct vkd3d_shader_sm4_parser *priv, const uint32_t **ptr,
-        const uint32_t *end, enum vkd3d_data_type data_type, struct vkd3d_shader_dst_param *dst_param);
+        const uint32_t *end, enum vsir_data_type data_type, struct vkd3d_shader_dst_param *dst_param);
 
 static bool shader_sm4_read_register_space(struct vkd3d_shader_sm4_parser *priv,
         const uint32_t **ptr, const uint32_t *end, unsigned int *register_space)
@@ -844,7 +844,7 @@ static void shader_sm4_read_shader_data(struct vkd3d_shader_instruction *ins, ui
         return;
     }
     icb->register_idx = 0;
-    icb->data_type = VKD3D_DATA_FLOAT;
+    icb->data_type = VSIR_DATA_F32;
     icb->component_count = VKD3D_VEC4_SIZE;
     icb->element_count = icb_size / VKD3D_VEC4_SIZE;
     icb->is_null = false;
@@ -873,7 +873,7 @@ static void shader_sm4_read_dcl_resource(struct vkd3d_shader_instruction *ins, u
     enum vkd3d_sm4_resource_type resource_type;
     const uint32_t *end = &tokens[token_count];
     enum vkd3d_sm4_data_type data_type;
-    enum vkd3d_data_type reg_data_type;
+    enum vsir_data_type reg_data_type;
     uint32_t components;
     unsigned int i;
 
@@ -907,7 +907,7 @@ static void shader_sm4_read_dcl_resource(struct vkd3d_shader_instruction *ins, u
         if (!data_type || (data_type >= ARRAY_SIZE(data_type_table)))
         {
             FIXME("Unhandled data type %#x.\n", data_type);
-            semantic->resource_data_type[i] = VKD3D_DATA_FLOAT;
+            semantic->resource_data_type[i] = VSIR_DATA_F32;
         }
         else
         {
@@ -926,7 +926,7 @@ static void shader_sm4_read_dcl_constant_buffer(struct vkd3d_shader_instruction
 {
     const uint32_t *end = &tokens[token_count];
 
-    shader_sm4_read_src_param(priv, &tokens, end, VKD3D_DATA_FLOAT, &ins->declaration.cb.src);
+    shader_sm4_read_src_param(priv, &tokens, end, VSIR_DATA_F32, &ins->declaration.cb.src);
     shader_sm4_set_descriptor_register_range(priv, &ins->declaration.cb.src.reg, &ins->declaration.cb.range);
     if (opcode_token & VKD3D_SM4_INDEX_TYPE_MASK)
         ins->flags |= VKD3DSI_INDEXED_DYNAMIC;
@@ -1142,14 +1142,14 @@ static void shader_sm4_read_declaration_count(struct vkd3d_shader_instruction *i
 static void shader_sm4_read_declaration_dst(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT, &ins->declaration.dst);
+    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VSIR_DATA_F32, &ins->declaration.dst);
 }
 
 static void shader_sm4_read_declaration_register_semantic(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT,
-            &ins->declaration.register_semantic.reg);
+    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count],
+            VSIR_DATA_F32, &ins->declaration.register_semantic.reg);
     ins->declaration.register_semantic.sysval_semantic = *tokens;
 }
 
@@ -1159,7 +1159,7 @@ static void shader_sm4_read_dcl_input_ps(struct vkd3d_shader_instruction *ins, u
     struct vkd3d_shader_dst_param *dst = &ins->declaration.dst;
 
     ins->flags = (opcode_token & VKD3D_SM4_INTERPOLATION_MODE_MASK) >> VKD3D_SM4_INTERPOLATION_MODE_SHIFT;
-    if (shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT, dst))
+    if (shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VSIR_DATA_F32, dst))
     {
         struct signature_element *e = vsir_signature_find_element_for_reg(
                 &priv->p.program->input_signature, dst->reg.idx[dst->reg.idx_count - 1].offset, dst->write_mask);
@@ -1185,7 +1185,7 @@ static void shader_sm4_read_dcl_input_ps_siv(struct vkd3d_shader_instruction *in
     struct vkd3d_shader_dst_param *dst = &ins->declaration.register_semantic.reg;
 
     ins->flags = (opcode_token & VKD3D_SM4_INTERPOLATION_MODE_MASK) >> VKD3D_SM4_INTERPOLATION_MODE_SHIFT;
-    if (shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT, dst))
+    if (shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VSIR_DATA_F32, dst))
     {
         struct signature_element *e = vsir_signature_find_element_for_reg(
                 &priv->p.program->input_signature, dst->reg.idx[dst->reg.idx_count - 1].offset, dst->write_mask);
@@ -1212,7 +1212,7 @@ static void shader_sm4_read_dcl_indexable_temp(struct vkd3d_shader_instruction *
     ins->declaration.indexable_temp.register_idx = *tokens++;
     ins->declaration.indexable_temp.register_size = *tokens++;
     ins->declaration.indexable_temp.alignment = 0;
-    ins->declaration.indexable_temp.data_type = VKD3D_DATA_FLOAT;
+    ins->declaration.indexable_temp.data_type = VSIR_DATA_F32;
     ins->declaration.indexable_temp.component_count = *tokens;
     ins->declaration.indexable_temp.has_function_scope = false;
 }
@@ -1339,7 +1339,7 @@ static void shader_sm5_read_dcl_uav_structured(struct vkd3d_shader_instruction *
 static void shader_sm5_read_dcl_tgsm_raw(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT, &ins->declaration.tgsm_raw.reg);
+    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VSIR_DATA_F32, &ins->declaration.tgsm_raw.reg);
     ins->declaration.tgsm_raw.byte_count = *tokens;
     if (ins->declaration.tgsm_raw.byte_count % 4)
         FIXME("Byte count %u is not multiple of 4.\n", ins->declaration.tgsm_raw.byte_count);
@@ -1349,8 +1349,8 @@ static void shader_sm5_read_dcl_tgsm_raw(struct vkd3d_shader_instruction *ins, u
 static void shader_sm5_read_dcl_tgsm_structured(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT,
-            &ins->declaration.tgsm_structured.reg);
+    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count],
+            VSIR_DATA_F32, &ins->declaration.tgsm_structured.reg);
     ins->declaration.tgsm_structured.byte_stride = *tokens++;
     ins->declaration.tgsm_structured.structure_count = *tokens;
     if (ins->declaration.tgsm_structured.byte_stride % 4)
@@ -1430,8 +1430,8 @@ static void init_sm4_lookup_tables(struct vkd3d_sm4_lookup_tables *lookup)
     unsigned int i;
 
     /*
-     * d -> VKD3D_DATA_DOUBLE
-     * f -> VKD3D_DATA_FLOAT
+     * d -> VSIR_DATA_F64
+     * f -> VSIR_DATA_F32
      * i -> VKD3D_DATA_INT
      * u -> VKD3D_DATA_UINT
      * O -> VKD3D_DATA_OPAQUE
@@ -1985,14 +1985,14 @@ static enum vkd3d_sm4_stat_field get_stat_field_from_sm4_opcode(
     return field_info->field;
 }
 
-static enum vkd3d_data_type map_data_type(char t)
+static enum vsir_data_type map_data_type(char t)
 {
     switch (t)
     {
         case 'd':
-            return VKD3D_DATA_DOUBLE;
+            return VSIR_DATA_F64;
         case 'f':
-            return VKD3D_DATA_FLOAT;
+            return VSIR_DATA_F32;
         case 'i':
             return VKD3D_DATA_INT;
         case 'u':
@@ -2003,7 +2003,7 @@ static enum vkd3d_data_type map_data_type(char t)
             return VKD3D_DATA_UNUSED;
         default:
             ERR("Invalid data type '%c'.\n", t);
-            return VKD3D_DATA_FLOAT;
+            return VSIR_DATA_F32;
     }
 }
 
@@ -2036,7 +2036,7 @@ static bool shader_sm4_read_reg_idx(struct vkd3d_shader_sm4_parser *priv, const
 }
 
 static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const uint32_t **ptr, const uint32_t *end,
-        enum vkd3d_data_type data_type, struct vkd3d_shader_register *param, enum vkd3d_shader_src_modifier *modifier)
+        enum vsir_data_type data_type, struct vkd3d_shader_register *param, enum vkd3d_shader_src_modifier *modifier)
 {
     const struct vkd3d_sm4_register_type_info *register_type_info;
     enum vkd3d_shader_register_type vsir_register_type;
@@ -2237,12 +2237,10 @@ bool shader_sm4_is_scalar_register(const struct vkd3d_shader_register *reg)
 {
     switch (reg->type)
     {
-        case VKD3DSPR_COVERAGE:
         case VKD3DSPR_DEPTHOUT:
         case VKD3DSPR_DEPTHOUTGE:
         case VKD3DSPR_DEPTHOUTLE:
         case VKD3DSPR_GSINSTID:
-        case VKD3DSPR_LOCALTHREADINDEX:
         case VKD3DSPR_OUTPOINTID:
         case VKD3DSPR_PRIMID:
         case VKD3DSPR_SAMPLEMASK:
@@ -2354,7 +2352,7 @@ static bool shader_sm4_validate_input_output_register(struct vkd3d_shader_sm4_pa
 }
 
 static bool shader_sm4_read_src_param(struct vkd3d_shader_sm4_parser *priv, const uint32_t **ptr,
-        const uint32_t *end, enum vkd3d_data_type data_type, struct vkd3d_shader_src_param *src_param)
+        const uint32_t *end, enum vsir_data_type data_type, struct vkd3d_shader_src_param *src_param)
 {
     unsigned int dimension, mask;
     uint32_t token;
@@ -2442,7 +2440,7 @@ static bool shader_sm4_read_src_param(struct vkd3d_shader_sm4_parser *priv, cons
 }
 
 static bool shader_sm4_read_dst_param(struct vkd3d_shader_sm4_parser *priv, const uint32_t **ptr,
-        const uint32_t *end, enum vkd3d_data_type data_type, struct vkd3d_shader_dst_param *dst_param)
+        const uint32_t *end, enum vsir_data_type data_type, struct vkd3d_shader_dst_param *dst_param)
 {
     enum vkd3d_sm4_swizzle_type swizzle_type;
     enum vkd3d_shader_src_modifier modifier;
@@ -2512,7 +2510,7 @@ static bool shader_sm4_read_dst_param(struct vkd3d_shader_sm4_parser *priv, cons
             break;
     }
 
-    if (data_type == VKD3D_DATA_DOUBLE)
+    if (data_type == VSIR_DATA_F64)
         dst_param->write_mask = vsir_write_mask_64_from_32(dst_param->write_mask);
     /* Some scalar registers are declared with no write mask in shader bytecode. */
     if (!dst_param->write_mask && shader_sm4_is_scalar_register(&dst_param->reg))
@@ -2573,7 +2571,7 @@ static void shader_sm4_read_instruction_modifier(uint32_t modifier, struct vkd3d
                 if (!data_type || (data_type >= ARRAY_SIZE(data_type_table)))
                 {
                     FIXME("Unhandled data type %#x.\n", data_type);
-                    ins->resource_data_type[i] = VKD3D_DATA_FLOAT;
+                    ins->resource_data_type[i] = VSIR_DATA_F32;
                 }
                 else
                 {
@@ -2683,10 +2681,10 @@ static void shader_sm4_read_instruction(struct vkd3d_shader_sm4_parser *sm4, str
     }
     ins->resource_type = VKD3D_SHADER_RESOURCE_NONE;
     ins->resource_stride = 0;
-    ins->resource_data_type[0] = VKD3D_DATA_FLOAT;
-    ins->resource_data_type[1] = VKD3D_DATA_FLOAT;
-    ins->resource_data_type[2] = VKD3D_DATA_FLOAT;
-    ins->resource_data_type[3] = VKD3D_DATA_FLOAT;
+    ins->resource_data_type[0] = VSIR_DATA_F32;
+    ins->resource_data_type[1] = VSIR_DATA_F32;
+    ins->resource_data_type[2] = VSIR_DATA_F32;
+    ins->resource_data_type[3] = VSIR_DATA_F32;
     memset(&ins->texel_offset, 0, sizeof(ins->texel_offset));
 
     p = *ptr;
@@ -3838,7 +3836,7 @@ static void tpf_dcl_sampler(const struct tpf_compiler *tpf, const struct vkd3d_s
     write_sm4_instruction(tpf, &instr);
 }
 
-static uint32_t pack_resource_data_type(const enum vkd3d_data_type *resource_data_type)
+static uint32_t pack_resource_data_type(const enum vsir_data_type *resource_data_type)
 {
     unsigned int i, k, type = 0;
 
@@ -4503,6 +4501,9 @@ int tpf_compile(struct vsir_program *program, uint64_t config_flags, const struc
     if ((ret = vsir_allocate_temp_registers(program, message_context)))
         return ret;
 
+    if ((ret = vsir_update_dcl_temps(program, message_context)))
+        return ret;
+
     tpf.program = program;
     tpf.buffer = NULL;
     tpf.stat = &stat;
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index 4cda8493696..c60feec4aa2 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -1084,7 +1084,7 @@ static void vkd3d_shader_scan_record_uav_atomic_op(struct vkd3d_shader_scan_cont
 static struct vkd3d_shader_descriptor_info1 *vkd3d_shader_scan_add_descriptor(struct vkd3d_shader_scan_context *context,
         enum vkd3d_shader_descriptor_type type, const struct vkd3d_shader_register *reg,
         const struct vkd3d_shader_register_range *range, enum vkd3d_shader_resource_type resource_type,
-        enum vkd3d_data_type resource_data_type)
+        enum vsir_data_type resource_data_type)
 {
     struct vkd3d_shader_scan_descriptor_info1 *info = context->scan_descriptor_info;
     struct vkd3d_shader_descriptor_info1 *d;
@@ -1145,7 +1145,7 @@ static void vkd3d_shader_scan_combined_sampler_declaration(
     vkd3d_shader_scan_add_descriptor(context, VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER, &semantic->resource.reg.reg,
             &semantic->resource.range, VKD3D_SHADER_RESOURCE_NONE, VKD3D_DATA_UNUSED);
     vkd3d_shader_scan_add_descriptor(context, VKD3D_SHADER_DESCRIPTOR_TYPE_SRV, &semantic->resource.reg.reg,
-            &semantic->resource.range, semantic->resource_type, VKD3D_DATA_FLOAT);
+            &semantic->resource.range, semantic->resource_type, VSIR_DATA_F32);
 }
 
 const struct vkd3d_shader_descriptor_info1 *vkd3d_shader_find_descriptor(
@@ -1235,7 +1235,7 @@ static void vkd3d_shader_scan_combined_sampler_usage(struct vkd3d_shader_scan_co
 
 static void vkd3d_shader_scan_resource_declaration(struct vkd3d_shader_scan_context *context,
         const struct vkd3d_shader_resource *resource, enum vkd3d_shader_resource_type resource_type,
-        enum vkd3d_data_type resource_data_type, unsigned int sample_count,
+        enum vsir_data_type resource_data_type, unsigned int sample_count,
         unsigned int structure_stride, bool raw, uint32_t flags)
 {
     struct vkd3d_shader_descriptor_info1 *d;
@@ -1522,7 +1522,7 @@ static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *conte
     return VKD3D_OK;
 }
 
-static enum vkd3d_shader_resource_data_type vkd3d_resource_data_type_from_data_type(enum vkd3d_data_type data_type)
+static enum vkd3d_shader_resource_data_type vkd3d_resource_data_type_from_data_type(enum vsir_data_type data_type)
 {
     switch (data_type)
     {
@@ -1534,16 +1534,16 @@ static enum vkd3d_shader_resource_data_type vkd3d_resource_data_type_from_data_t
             return VKD3D_SHADER_RESOURCE_DATA_INT;
         case VKD3D_DATA_UINT:
             return VKD3D_SHADER_RESOURCE_DATA_UINT;
-        case VKD3D_DATA_FLOAT:
-            return VKD3D_SHADER_RESOURCE_DATA_FLOAT;
         case VKD3D_DATA_MIXED:
             return VKD3D_SHADER_RESOURCE_DATA_MIXED;
-        case VKD3D_DATA_DOUBLE:
-            return VKD3D_SHADER_RESOURCE_DATA_DOUBLE;
         case VKD3D_DATA_CONTINUED:
             return VKD3D_SHADER_RESOURCE_DATA_CONTINUED;
         case VKD3D_DATA_UNUSED:
             return VKD3D_SHADER_RESOURCE_DATA_NONE;
+        case VSIR_DATA_F32:
+            return VKD3D_SHADER_RESOURCE_DATA_FLOAT;
+        case VSIR_DATA_F64:
+            return VKD3D_SHADER_RESOURCE_DATA_DOUBLE;
         default:
             ERR("Invalid resource data type %#x.\n", data_type);
             return VKD3D_SHADER_RESOURCE_DATA_FLOAT;
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index 978af0a2d17..f7bbadac3df 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -184,6 +184,7 @@ enum vkd3d_shader_error
     VKD3D_SHADER_WARNING_HLSL_IGNORED_ATTRIBUTE         = 5305,
     VKD3D_SHADER_WARNING_HLSL_IGNORED_DEFAULT_VALUE     = 5306,
     VKD3D_SHADER_WARNING_HLSL_IGNORED_MODIFIER          = 5307,
+    VKD3D_SHADER_WARNING_HLSL_OVERRIDDEN_SEMANTIC       = 5308,
 
     VKD3D_SHADER_ERROR_GLSL_INTERNAL                    = 6000,
     VKD3D_SHADER_ERROR_GLSL_BINDING_NOT_FOUND           = 6001,
@@ -707,46 +708,47 @@ enum vkd3d_shader_register_precision
     VKD3D_SHADER_REGISTER_PRECISION_INVALID = ~0u,
 };
 
-enum vkd3d_data_type
+enum vsir_data_type
 {
-    VKD3D_DATA_FLOAT,
     VKD3D_DATA_INT,
     VKD3D_DATA_UINT,
     VKD3D_DATA_UNORM,
     VKD3D_DATA_SNORM,
     VKD3D_DATA_OPAQUE,
     VKD3D_DATA_MIXED,
-    VKD3D_DATA_DOUBLE,
     VKD3D_DATA_CONTINUED,
     VKD3D_DATA_UNUSED,
     VKD3D_DATA_UINT8,
     VKD3D_DATA_UINT64,
     VKD3D_DATA_BOOL,
     VKD3D_DATA_UINT16,
-    VKD3D_DATA_HALF,
 
-    VKD3D_DATA_COUNT,
+    VSIR_DATA_F16,
+    VSIR_DATA_F32,
+    VSIR_DATA_F64,
+
+    VSIR_DATA_TYPE_COUNT,
 };
 
-static inline bool data_type_is_integer(enum vkd3d_data_type data_type)
+static inline bool data_type_is_integer(enum vsir_data_type data_type)
 {
     return data_type == VKD3D_DATA_INT || data_type == VKD3D_DATA_UINT8 || data_type == VKD3D_DATA_UINT16
             || data_type == VKD3D_DATA_UINT || data_type == VKD3D_DATA_UINT64;
 }
 
-static inline bool data_type_is_bool(enum vkd3d_data_type data_type)
+static inline bool data_type_is_bool(enum vsir_data_type data_type)
 {
     return data_type == VKD3D_DATA_BOOL;
 }
 
-static inline bool data_type_is_floating_point(enum vkd3d_data_type data_type)
+static inline bool data_type_is_floating_point(enum vsir_data_type data_type)
 {
-    return data_type == VKD3D_DATA_HALF || data_type == VKD3D_DATA_FLOAT || data_type == VKD3D_DATA_DOUBLE;
+    return data_type == VSIR_DATA_F16 || data_type == VSIR_DATA_F32 || data_type == VSIR_DATA_F64;
 }
 
-static inline bool data_type_is_64_bit(enum vkd3d_data_type data_type)
+static inline bool data_type_is_64_bit(enum vsir_data_type data_type)
 {
-    return data_type == VKD3D_DATA_DOUBLE || data_type == VKD3D_DATA_UINT64;
+    return data_type == VSIR_DATA_F64 || data_type == VKD3D_DATA_UINT64;
 }
 
 enum vsir_dimension
@@ -941,7 +943,7 @@ struct vkd3d_shader_version
 struct vkd3d_shader_immediate_constant_buffer
 {
     unsigned int register_idx;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     /* total count is element_count * component_count */
     unsigned int element_count;
     unsigned int component_count;
@@ -954,7 +956,7 @@ struct vkd3d_shader_indexable_temp
     unsigned int register_idx;
     unsigned int register_size;
     unsigned int alignment;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     unsigned int component_count;
     bool has_function_scope;
     const struct vkd3d_shader_immediate_constant_buffer *initialiser;
@@ -973,7 +975,7 @@ struct vkd3d_shader_register
     enum vkd3d_shader_register_type type;
     enum vkd3d_shader_register_precision precision;
     bool non_uniform;
-    enum vkd3d_data_type data_type;
+    enum vsir_data_type data_type;
     struct vkd3d_shader_register_index idx[3];
     unsigned int idx_count;
     enum vsir_dimension dimension;
@@ -990,7 +992,7 @@ struct vkd3d_shader_register
 };
 
 void vsir_register_init(struct vkd3d_shader_register *reg, enum vkd3d_shader_register_type reg_type,
-        enum vkd3d_data_type data_type, unsigned int idx_count);
+        enum vsir_data_type data_type, unsigned int idx_count);
 
 static inline bool vsir_register_is_descriptor(const struct vkd3d_shader_register *reg)
 {
@@ -1023,9 +1025,9 @@ struct vkd3d_shader_src_param
 };
 
 void vsir_src_param_init(struct vkd3d_shader_src_param *param, enum vkd3d_shader_register_type reg_type,
-        enum vkd3d_data_type data_type, unsigned int idx_count);
+        enum vsir_data_type data_type, unsigned int idx_count);
 void vsir_dst_param_init(struct vkd3d_shader_dst_param *param, enum vkd3d_shader_register_type reg_type,
-        enum vkd3d_data_type data_type, unsigned int idx_count);
+        enum vsir_data_type data_type, unsigned int idx_count);
 void vsir_dst_param_init_null(struct vkd3d_shader_dst_param *dst);
 void vsir_src_param_init_label(struct vkd3d_shader_src_param *param, unsigned int label_id);
 
@@ -1071,7 +1073,7 @@ struct vkd3d_shader_semantic
     unsigned int usage_idx;
     enum vkd3d_shader_resource_type resource_type;
     unsigned int sample_count;
-    enum vkd3d_data_type resource_data_type[VKD3D_VEC4_SIZE];
+    enum vsir_data_type resource_data_type[VKD3D_VEC4_SIZE];
     struct vkd3d_shader_resource resource;
 };
 
@@ -1284,7 +1286,7 @@ struct vkd3d_shader_instruction
     struct vkd3d_shader_texel_offset texel_offset;
     enum vkd3d_shader_resource_type resource_type;
     unsigned int resource_stride;
-    enum vkd3d_data_type resource_data_type[VKD3D_VEC4_SIZE];
+    enum vsir_data_type resource_data_type[VKD3D_VEC4_SIZE];
     bool coissue, structured, raw;
     const struct vkd3d_shader_src_param *predicate;
     union
@@ -1419,6 +1421,51 @@ bool shader_instruction_array_clone_instruction(struct vkd3d_shader_instruction_
         unsigned int dst, unsigned int src);
 void shader_instruction_array_destroy(struct vkd3d_shader_instruction_array *instructions);
 
+struct vsir_program_iterator
+{
+    struct vkd3d_shader_instruction_array *array;
+    size_t idx;
+};
+
+static inline struct vsir_program_iterator vsir_program_iterator(struct vkd3d_shader_instruction_array *array)
+{
+    return (struct vsir_program_iterator){ .array = array };
+}
+
+static inline struct vkd3d_shader_instruction *vsir_program_iterator_current(
+        struct vsir_program_iterator *iterator)
+{
+    if (iterator->idx >= iterator->array->count)
+        return NULL;
+
+    return &iterator->array->elements[iterator->idx];
+}
+
+static inline struct vkd3d_shader_instruction *vsir_program_iterator_head(
+        struct vsir_program_iterator *iterator)
+{
+    iterator->idx = 0;
+
+    return vsir_program_iterator_current(iterator);
+}
+
+static inline struct vkd3d_shader_instruction *vsir_program_iterator_next(
+        struct vsir_program_iterator *iterator)
+{
+    if (iterator->idx < iterator->array->count)
+        ++iterator->idx;
+
+    return vsir_program_iterator_current(iterator);
+}
+
+/* When insertion takes place, argument `it' is updated to point to the same
+ * instruction as before the insertion, but all other iterators and pointers
+ * to the same container are invalidated and cannot be used any more. */
+static inline bool vsir_program_iterator_insert_after(struct vsir_program_iterator *it, unsigned int count)
+{
+    return shader_instruction_array_insert_at(it->array, it->idx + 1, count);
+}
+
 enum vkd3d_shader_config_flags
 {
     VKD3D_SHADER_CONFIG_FLAG_FORCE_VALIDATION = 0x00000001,
@@ -1445,7 +1492,7 @@ struct vkd3d_shader_descriptor_info1
     unsigned int register_index;
     unsigned int register_id;
     enum vkd3d_shader_resource_type resource_type;
-    enum vkd3d_data_type resource_data_type;
+    enum vsir_data_type resource_data_type;
     unsigned int flags;
     unsigned int sample_count;
     unsigned int buffer_size;
@@ -1511,6 +1558,8 @@ struct vsir_program
 
 enum vkd3d_result vsir_allocate_temp_registers(struct vsir_program *program,
         struct vkd3d_shader_message_context *message_context);
+enum vkd3d_result vsir_update_dcl_temps(struct vsir_program *program,
+        struct vkd3d_shader_message_context *message_context);
 void vsir_program_cleanup(struct vsir_program *program);
 int vsir_program_compile(struct vsir_program *program, uint64_t config_flags,
         const struct vkd3d_shader_compile_info *compile_info, struct vkd3d_shader_code *out,
@@ -1739,23 +1788,22 @@ int preproc_lexer_parse(const struct vkd3d_shader_compile_info *compile_info,
 int hlsl_compile_shader(const struct vkd3d_shader_code *hlsl, const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context);
 
-static inline enum vkd3d_shader_component_type vkd3d_component_type_from_data_type(
-        enum vkd3d_data_type data_type)
+static inline enum vkd3d_shader_component_type vkd3d_component_type_from_data_type( enum vsir_data_type data_type)
 {
     switch (data_type)
     {
-        case VKD3D_DATA_HALF: /* Minimum precision. TODO: native 16-bit */
-        case VKD3D_DATA_FLOAT:
+        case VSIR_DATA_F16: /* Minimum precision. TODO: native 16-bit */
+        case VSIR_DATA_F32:
         case VKD3D_DATA_UNORM:
         case VKD3D_DATA_SNORM:
             return VKD3D_SHADER_COMPONENT_FLOAT;
+        case VSIR_DATA_F64:
+            return VKD3D_SHADER_COMPONENT_DOUBLE;
         case VKD3D_DATA_UINT16: /* Minimum precision. TODO: native 16-bit */
         case VKD3D_DATA_UINT:
             return VKD3D_SHADER_COMPONENT_UINT;
         case VKD3D_DATA_INT:
             return VKD3D_SHADER_COMPONENT_INT;
-        case VKD3D_DATA_DOUBLE:
-            return VKD3D_SHADER_COMPONENT_DOUBLE;
         case VKD3D_DATA_UINT64:
             return VKD3D_SHADER_COMPONENT_UINT64;
         case VKD3D_DATA_BOOL:
@@ -1768,22 +1816,21 @@ static inline enum vkd3d_shader_component_type vkd3d_component_type_from_data_ty
     }
 }
 
-static inline enum vkd3d_data_type vkd3d_data_type_from_component_type(
-        enum vkd3d_shader_component_type component_type)
+static inline enum vsir_data_type vsir_data_type_from_component_type(enum vkd3d_shader_component_type component_type)
 {
     switch (component_type)
     {
         case VKD3D_SHADER_COMPONENT_FLOAT:
-            return VKD3D_DATA_FLOAT;
+            return VSIR_DATA_F32;
         case VKD3D_SHADER_COMPONENT_UINT:
             return VKD3D_DATA_UINT;
         case VKD3D_SHADER_COMPONENT_INT:
             return VKD3D_DATA_INT;
         case VKD3D_SHADER_COMPONENT_DOUBLE:
-            return VKD3D_DATA_DOUBLE;
+            return VSIR_DATA_F64;
         default:
             FIXME("Unhandled component type %#x.\n", component_type);
-            return VKD3D_DATA_FLOAT;
+            return VSIR_DATA_F32;
     }
 }
 
-- 
2.50.1

