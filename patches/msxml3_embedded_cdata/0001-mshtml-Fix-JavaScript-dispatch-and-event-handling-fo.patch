From de3547aa660d5e354a03e1ec50fa3a08d064cb75 Mon Sep 17 00:00:00 2001
From: Phiality <155454343+PhialsBasement@users.noreply.github.com>
Date: Thu, 15 Jan 2026 19:15:01 +1100
Subject: [PATCH 1/2] mshtml: Fix JavaScript dispatch and event handling for
 Adobe installers

- dispex: Don't delegate dynamic property DISPIDs to jscript. These IDs are mshtml-specific and jscript doesn't understand them. Fixes crashes when native code creates properties on window via GetDispID+InvokeEx
(e.g., Adobe installer's JSObject).

- htmlelem: Intercept event handler attributes (onclick, onload, etc.) in setAttribute for IE9+ mode. Gecko doesn't dispatch events through Wine's event handlers, so these need to go through Wine's event system.

- htmlevent: Compile string event handlers into callable functions using the script engine instead of just storing them. This allows handlers set via element.onclick="code" to actually execute.

- htmlnode: Remove init_info from NodeList_dispex to avoid exposing JSObject property that HTMLDOMNode_init_dispex_info would add.
---
 dlls/mshtml/dispex.c    |  5 ++-
 dlls/mshtml/htmlelem.c  | 11 +++++++
 dlls/mshtml/htmlevent.c | 68 +++++++++++++++++++++++++++++------------
 dlls/mshtml/htmlevent.h |  1 +
 4 files changed, 64 insertions(+), 21 deletions(-)

diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index 0af89aca630..b328148b553 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -2393,7 +2393,10 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IWineJSDispatchHost *iface, DISPID id,
     if(!ensure_real_info(This))
         return E_OUTOFMEMORY;
 
-    if(This->jsdisp)
+    /* Don't delegate dynamic property DISPIDs to jscript - they are mshtml-specific
+     * and jscript doesn't know about them. This is needed for native code that
+     * creates properties on window via GetDispID+InvokeEx (e.g. Adobe installer's JSObject). */
+    if(This->jsdisp && !is_dynamic_dispid(id))
         return IWineJSDispatch_InvokeEx(This->jsdisp, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
 
     switch(wFlags) {
diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index b90fc24d284..467fdf7fb5b 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -1039,6 +1039,17 @@ static HRESULT WINAPI HTMLElement_setAttribute(IHTMLElement *iface, BSTR strAttr
 
     TRACE("(%p)->(%s %s %08lx)\n", This, debugstr_w(strAttributeName), debugstr_variant(&AttributeValue), lFlags);
 
+    /* Event handler attributes (onclick, onload, etc.) need to go through Wine's event system
+     * even in IE9+ mode, since Gecko doesn't dispatch events through our event handlers. */
+    if(compat_mode >= COMPAT_MODE_IE9 && This->dom_element &&
+       strAttributeName[0] && (strAttributeName[0] == 'o' || strAttributeName[0] == 'O') &&
+       strAttributeName[1] && (strAttributeName[1] == 'n' || strAttributeName[1] == 'N')) {
+        hres = set_node_event_handler_by_attr(&This->node, strAttributeName, &val);
+        if(SUCCEEDED(hres))
+            goto done;
+        /* If the event isn't recognized, fall through to the normal attribute handling */
+    }
+
     if(compat_mode < COMPAT_MODE_IE9 || !This->dom_element) {
         hres = dispex_get_id(&This->node.event_target.dispex, translate_attr_name(strAttributeName, compat_mode),
                 (lFlags&ATTRFLAG_CASESENSITIVE ? fdexNameCaseSensitive : fdexNameCaseInsensitive) | fdexNameEnsure, &dispid);
diff --git a/dlls/mshtml/htmlevent.c b/dlls/mshtml/htmlevent.c
index cb5c1127bd2..1b052420c09 100644
--- a/dlls/mshtml/htmlevent.c
+++ b/dlls/mshtml/htmlevent.c
@@ -4748,28 +4748,42 @@ HRESULT set_event_handler(EventTarget *event_target, eventid_t eid, VARIANT *var
         return set_event_handler_disp(event_target, eid, V_DISPATCH(var));
 
     case VT_BSTR: {
-        VARIANT *v;
-        HRESULT hres;
-
-        if(!use_event_quirks(event_target))
-            FIXME("Setting to string %s not supported\n", debugstr_w(V_BSTR(var)));
-
-        /*
-         * Setting event handler to string is a rare case and we don't want to
-         * complicate nor increase memory of listener_container_t for that. Instead,
-         * we store the value in DispatchEx, which can already handle custom
-         * properties.
-         */
-        remove_event_handler(event_target, eid);
+        HTMLInnerWindow *script_global;
+        IDispatch *disp;
+
+        /* Compile the string into a callable function using the script engine */
+        script_global = get_script_global(&event_target->dispex);
+        if(script_global) {
+            TRACE("Compiling event handler string: %s\n", debugstr_w(V_BSTR(var)));
+            disp = script_parse_event(script_global, V_BSTR(var));
+            IHTMLWindow2_Release(&script_global->base.IHTMLWindow2_iface);
+            if(disp) {
+                HRESULT hres = set_event_handler_disp(event_target, eid, disp);
+                IDispatch_Release(disp);
+                return hres;
+            }
+            WARN("Failed to compile event handler string\n");
+        }
 
-        hres = get_event_dispex_ref(event_target, eid, TRUE, &v);
-        if(FAILED(hres))
-            return hres;
+        /* Fallback: store the value in DispatchEx for quirks mode compatibility */
+        if(use_event_quirks(event_target)) {
+            VARIANT *v;
+            HRESULT hres;
 
-        V_BSTR(v) = SysAllocString(V_BSTR(var));
-        if(!V_BSTR(v))
-            return E_OUTOFMEMORY;
-        V_VT(v) = VT_BSTR;
+            remove_event_handler(event_target, eid);
+
+            hres = get_event_dispex_ref(event_target, eid, TRUE, &v);
+            if(FAILED(hres))
+                return hres;
+
+            V_BSTR(v) = SysAllocString(V_BSTR(var));
+            if(!V_BSTR(v))
+                return E_OUTOFMEMORY;
+            V_VT(v) = VT_BSTR;
+            return S_OK;
+        }
+
+        FIXME("Setting to string %s not supported (no script global)\n", debugstr_w(V_BSTR(var)));
         return S_OK;
     }
 
@@ -4871,6 +4885,20 @@ void bind_target_event(HTMLDocumentNode *doc, EventTarget *event_target, const W
     set_event_handler_disp(event_target, eid, disp);
 }
 
+HRESULT set_node_event_handler_by_attr(HTMLDOMNode *node, const WCHAR *attr_name, VARIANT *var)
+{
+    eventid_t eid;
+
+    eid = attr_to_eid(attr_name);
+    if(eid == EVENTID_LAST) {
+        WARN("Unsupported event attribute %s\n", debugstr_w(attr_name));
+        return DISP_E_UNKNOWNNAME;
+    }
+
+    TRACE("Setting event handler for %s (eid=%d)\n", debugstr_w(attr_name), eid);
+    return set_node_event(node, eid, var);
+}
+
 void update_doc_cp_events(HTMLDocumentNode *doc, cp_static_data_t *cp)
 {
     int i;
diff --git a/dlls/mshtml/htmlevent.h b/dlls/mshtml/htmlevent.h
index 3f4e11690f8..94f6b393324 100644
--- a/dlls/mshtml/htmlevent.h
+++ b/dlls/mshtml/htmlevent.h
@@ -110,6 +110,7 @@ HRESULT doc_init_events(HTMLDocumentNode*);
 void detach_events(HTMLDocumentNode *doc);
 HRESULT create_event_obj(DOMEvent*,HTMLDocumentNode*,IHTMLEventObj**);
 void bind_target_event(HTMLDocumentNode*,EventTarget*,const WCHAR*,IDispatch*);
+HRESULT set_node_event_handler_by_attr(HTMLDOMNode*,const WCHAR*,VARIANT*);
 HRESULT ensure_doc_nsevent_handler(HTMLDocumentNode*,nsIDOMNode*,eventid_t);
 
 void dispatch_event(EventTarget*,DOMEvent*);
-- 
2.51.0

